<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何学习一门编程语言</title>
    <url>/coding/programming-guide/</url>
    <content><![CDATA[<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>很多人喜欢争论什么什么编程语言好，我认为这个话题如果不限定应用范围，就毫无意义。</p>
<p>每种编程语言必然有其优点和缺点，这也决定了它有适合的应用场景和不适合的应用场景。现代软件行业，想一门编程语言包打天下是不现实的。这中现状也造成了一种现象，一个程序员往往要掌握多种编程语言。</p>
<p>学习任何一门编程语言，都会面临的第一个问题都是：如何学习 XX 语言？</p>
<p>我不想说什么多看、多学、多写、多练之类的废话。世上事有难易乎？无他，唯手熟尔。谁不知道熟能生巧的道理？</p>
<p>我觉得有必要谈谈的是：如何由浅入深的学习一门编程语言？学习所有编程语言有没有一个相对统一的学习方法？</p>
<p>曾几何时，当我还是一名小菜鸟时，总是叹服那些大神掌握多门编程语言。后来，在多年编程工作和学习中，我陆陆续续也接触过不少编程语言：C、C++、Java、C#、Javascript、shell 等等。每次学习一门新的编程语言，掌握程度或深或浅，但是学习的曲线却大抵相似。</p>
<p>下面，我按照个人的学习经验总结一下，学习编程语言的基本步骤。</p>
<h2 id="学习编程语言的步骤"><a class="markdownIt-Anchor" href="#学习编程语言的步骤"></a> 学习编程语言的步骤</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/programming/learn-programming-language.png"/></div>
<h3 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h3>
<p>首先当然是了解语言的最基本语法。</p>
<p>控制台输出，如 C 的 printf，Java 的 System.out.println 等。</p>
<p>普通程序员的第一行代码一般都是输出 “Hello World” 吧。</p>
<ul>
<li>
<p>基本数据类型</p>
<p>不同编程语言的基本数据类型不同。基本数据类型是的申请内存空间变得方便、规范化。</p>
</li>
<li>
<p>变量</p>
<p>不同编程语言的声明变量方式有很大不同。有的如 Java 、C++ 需要明确指定变量数据类型，这种叫强类型定义语言。有的语言（主要是脚本语言），如 Javascript、Shell 等，不需要明确指定数据类型，这种叫弱类型定义语言。</p>
<p>还需要注意的一点是变量的作用域范围和生命周期。不同语言变量的作用域范围和生命周期不一定一样，这个需要在代码中细细体会，有时会为此埋雷。</p>
</li>
<li>
<p>逻辑控制语句</p>
<p>编程语言都会有逻辑控制语句，哪怕是汇编语言。</p>
<p>掌握条件语句、循环语句、中断循环语句（break、continue）、选择语句。一般区别仅仅在于关键字、语法格式略有不同。</p>
</li>
<li>
<p>运算符</p>
<p>掌握基本运算符，如算术运算符、关系运算符、逻辑运算符、赋值运算符等。</p>
<p>有些语言还提供位运算符、特殊运算符，视情节掌握。</p>
</li>
<li>
<p>注释（没啥好说的）</p>
</li>
<li>
<p>函数</p>
<p>编程语言基本都有函数。注意语法格式：是否支持出参；支持哪些数据作为入参，有些语言允许将函数作为参数传入另一个参数（即回调）；返回值；如何退出函数（如 Java、C++的 return，）。</p>
</li>
</ul>
<h3 id="数组-枚举-集合"><a class="markdownIt-Anchor" href="#数组-枚举-集合"></a> 数组、枚举、集合</h3>
<p>枚举只有部分编程语言有，如 Java、C++、C#。</p>
<p>但是数组和集合（有些语言叫容器）一般编程语言都有，只是有的编程语言提供的集合比较丰富。使用方法基本类似。</p>
<h3 id="常用类"><a class="markdownIt-Anchor" href="#常用类"></a> 常用类</h3>
<p>比较常用的类（当然有些语言中不叫类，叫对象或者其他什么，这个不重要，领会精神）请了解其 API 用法，如：字符串、日期、数学计算等等。</p>
<h3 id="语言特性"><a class="markdownIt-Anchor" href="#语言特性"></a> 语言特性</h3>
<p>语言特性这个特字反映的就是各个编程语言自身的&quot;独特个性&quot;，这涉及的点比较多，简单列举一些。</p>
<p><strong>编程模式</strong></p>
<p>比较流行的编程模式大概有：</p>
<p>面向对象编程，主要是封装、继承、多态；函数式编程，主要是应用 Lambda；过程式编程，可以理解为实现需求功能的特定步骤。</p>
<p>每种编程模式都有一定的道理，我从不认为只有面向对象编程才是王道。</p>
<p>Java 是面向对象语言，从 Java8 开始也支持函数编程（引入 Lambda 表达式）；C++ 可以算是半面向对象，半面向过程式语言。</p>
<p><strong>语言自身特性</strong></p>
<p>每个语言自身都有一些重要特性需要了解。例如，学习 C、C++，你必须了解内存的申请和释放，了解指针、引用。而学习 Java，你需要了解 JVM，垃圾回收机制。学习 Javascript，你需要了解 DOM 操作等。</p>
<h3 id="代码组织-模块加载-库管理"><a class="markdownIt-Anchor" href="#代码组织-模块加载-库管理"></a> 代码组织、模块加载、库管理</h3>
<p>一个程序一般都有很多个源代码文件。这就会引入这些问题：如何将代码文件组织起来？如何根据业务需要，选择将部分模块启动时进行加载，部分模块使用懒加载（或者热加载）？</p>
<p>最基本的引用文件就不提了，如 C、C++的#include，Java 的 import 等。</p>
<p>针对代码组织、模块加载、库管理这些问题，不同语言会有不同的解决方案。</p>
<p>如 Java 可以用 maven、gradle 管理项目依赖、组织代码结构；Javascript （包括 Nodejs、jquery、react 等等库）可以用 npm、yarn 管理依赖，用 webpack 等工具管理模块加载。</p>
<h3 id="容错处理"><a class="markdownIt-Anchor" href="#容错处理"></a> 容错处理</h3>
<p>程序总难免会有 bug。</p>
<p>所以为了代码健壮性也好，为了方便定位问题也好，代码中需要有容错处理。常见的手段有：</p>
<ul>
<li>异常</li>
<li>断言</li>
<li>日志</li>
<li>调试</li>
<li>单元测试</li>
</ul>
<h3 id="输入输出和文件处理"><a class="markdownIt-Anchor" href="#输入输出和文件处理"></a> 输入输出和文件处理</h3>
<p>这块知识比较繁杂。建议提纲挈领的学习一下，理解基本概念，比如输入输出流、管道等等。至于 API，用到的时候再查一下即可。</p>
<h3 id="回调机制"><a class="markdownIt-Anchor" href="#回调机制"></a> 回调机制</h3>
<p>每种语言实现回调的方式有所不同，如 .Net 的 delegate （大量被用于 WinForm 程序）；Javascript 中函数天然支持回调：Javascript 函数允许传入另一个函数作为入参，然后在方法中调用它。其它语言的回调方式不一一列举。</p>
<h3 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h3>
<p>首先需要了解的是，序列化和反序列化的作用是为了在不同平台之间传输对象。</p>
<p>其次，要知道序列化存在多种方式，不同编程语言可能有多种方案。根据应用的序列化方式，选择性了解即可。</p>
<h3 id="进阶特性"><a class="markdownIt-Anchor" href="#进阶特性"></a> 进阶特性</h3>
<p>以下学习内容属于进阶性内容。可以根据开发需要去学习、掌握。需要注意的是，学习这些特性的态度应该是不学则已，学则死磕。因为半懂半不懂，特别容易引入问题。</p>
<p><em>对于半桶水的同学，我想说：放过自己，也放过别人，活着不好吗？</em></p>
<ul>
<li>
<p>**并发编程：**好处多多，十分重要，但是并发代码容易出错，且出错难以定位。要学习还是要花很大力气的，需要了解大量知识，如：进程、线程、同步、异步、读写锁等等。</p>
</li>
<li>
<p><strong>反射</strong> - 让你可以动态编程（慎用）。</p>
</li>
<li>
<p><strong>泛型</strong> - 集合（或者叫容器）的基石。精通泛型，能大大提高你的代码效率。</p>
</li>
<li>
<p><strong>元数据</strong> - 描述数据的数据。Java 中叫做注解。</p>
</li>
</ul>
<h3 id="库和框架"><a class="markdownIt-Anchor" href="#库和框架"></a> 库和框架</h3>
<p>学习一门编程语言，难免需要用到围绕它构建的技术生态圈——库和框架。这方面知识范围太庞大，根据实际应用领域去学习吧。比如搞 JavaWeb，你多多少少肯定要用到 Spring、Mybatis、Hibernate、Shiro 等大量开发框架；如果做 Javascript 前端，你可能会用到 React、Vue、Angular 、jQuery 等库或框架。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>总结以上，编程语言学习的道路是任重而道远的，未来是光明的。</p>
<p>最后一句话与君共勉：路漫漫兮其修远，吾将上下而求索。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你彻底掌握 Python</title>
    <url>/coding/python/</url>
    <content><![CDATA[<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<h1 id="python-编程"><a class="markdownIt-Anchor" href="#python-编程"></a> Python 编程</h1>
<h2 id="解释器"><a class="markdownIt-Anchor" href="#解释器"></a> 解释器</h2>
<p>Linux/Unix 的系统上，Python 解释器通常被安装在 <code>/usr/local/bin/python3.4</code> 这样的有效路径（目录）里。</p>
<p>我们可以将路径 <code>/usr/local/bin</code> 添加到您的 Linux/Unix 操作系统的环境变量中，这样您就可以通过 shell 终端输入下面的命令来启动 Python 。</p>
<p>在 Linux/Unix 系统中，你可以在脚本顶部添加以下命令让 Python 脚本可以像 SHELL 脚本一样可直接执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3.4</span></span><br></pre></td></tr></table></figure>
<h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2>
<p>Python 中的注释有三种形式：</p>
<ul>
<li>以 <code>#</code> 开头</li>
<li>以 <code>'''</code> 开始，以 <code>'''</code> 结尾</li>
<li>以 <code>&quot;&quot;&quot;</code> 开始，以 <code>&quot;&quot;&quot;</code> 结尾</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionaries（字典）</li>
</ul>
<h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h2>
<p>Python 语言支持以下类型的运算符:</p>
<ul>
<li>
<p>算术运算符</p>
</li>
<li>
<p>比较（关系）运算符</p>
</li>
<li>
<p>赋值运算符</p>
</li>
<li>
<p>逻辑运算符</p>
</li>
<li>
<p>位运算符</p>
</li>
<li>
<p>成员运算符</p>
</li>
<li>
<p>身份运算符</p>
</li>
<li>
<p>运算符优先级</p>
</li>
</ul>
<h3 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加 - 两个对象相加</td>
<td>a + b 输出结果 31</td>
</tr>
<tr>
<td>-</td>
<td>减 - 得到负数或是一个数减去另一个数</td>
<td>a - b 输出结果 -11</td>
</tr>
<tr>
<td>*</td>
<td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td>a * b 输出结果 210</td>
</tr>
<tr>
<td>/</td>
<td>除 - x 除以 y</td>
<td>b / a 输出结果 2.1</td>
</tr>
<tr>
<td>%</td>
<td>取模 - 返回除法的余数</td>
<td>b % a 输出结果 1</td>
</tr>
<tr>
<td>**</td>
<td>幂 - 返回 x 的 y 次幂</td>
<td>a**b 为 10 的 21 次方</td>
</tr>
<tr>
<td>//</td>
<td>取整除 - 返回商的整数部分</td>
<td>9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td>
</tr>
</tbody>
</table>
<h3 id="比较运算符"><a class="markdownIt-Anchor" href="#比较运算符"></a> 比较运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>等于 - 比较对象是否相等</td>
<td>(a == b) 返回 False。</td>
</tr>
<tr>
<td>!=</td>
<td>不等于 - 比较两个对象是否不相等</td>
<td>(a != b) 返回 True.</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于 - 返回 x 是否大于 y</td>
<td>(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于 - 返回 x 是否小于 y。所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True 和 False 等价。注意，这些变量名的大写。</td>
<td>(a &lt; b) 返回 True。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于 - 返回 x 是否大于等于 y。</td>
<td>(a &gt;= b) 返回 False。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于 - 返回 x 是否小于等于 y。</td>
<td>(a &lt;= b) 返回 True。</td>
</tr>
</tbody>
</table>
<h3 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>简单的赋值运算符</td>
<td>c = a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c _= a 等效于 c = c _ a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c **= a 等效于 c = c ** a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
</tbody>
</table>
<h3 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与运算符：参与运算的两个值,如果两个相应位都为 1,则该位的结果为 1,否则为 0</td>
<td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>按位或运算符：只要对应的二个二进位有一个为 1 时，结果位就为 1。</td>
<td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符：当两对应的二进位相异时，结果为 1</td>
<td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符：对数据的每个二进制位取反,即把 1 变为 0,把 0 变为 1</td>
<td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补 0。</td>
<td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移动运算符：把&quot;&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数</td>
<td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>逻辑表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>x and y</td>
<td>布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td>
<td>(a and b) 返回 20。</td>
</tr>
<tr>
<td>or</td>
<td>x or y</td>
<td>布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td>
<td>(a or b) 返回 10。</td>
</tr>
<tr>
<td>not</td>
<td>not x</td>
<td>布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td>not(a and b) 返回 False</td>
</tr>
</tbody>
</table>
<h3 id="成员运算符"><a class="markdownIt-Anchor" href="#成员运算符"></a> 成员运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody>
</table>
<h3 id="身份运算符"><a class="markdownIt-Anchor" href="#身份运算符"></a> 身份运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>is</td>
<td>is 是判断两个标识符是不是引用自一个对象</td>
<td>x is y, 如果 id(x) 等于 id(y) , <strong>is</strong> 返回结果 1</td>
</tr>
<tr>
<td>is not</td>
<td>is not 是判断两个标识符是不是引用自不同对象</td>
<td>x is not y, 如果 id(x) 不等于 id(y). <strong>is not</strong> 返回结果 1</td>
</tr>
</tbody>
</table>
<h3 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>**</td>
<td>指数 (最高优先级)</td>
</tr>
<tr>
<td>~ + -</td>
<td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘，除，取模和取整除</td>
</tr>
<tr>
<td>+ -</td>
<td>加法减法</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>右移，左移运算符</td>
</tr>
<tr>
<td>&amp;</td>
<td>位 ‘AND’</td>
</tr>
<tr>
<td>^ |</td>
<td>位运算符</td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>比较运算符</td>
</tr>
<tr>
<td>&lt;&gt; == !=</td>
<td>等于运算符</td>
</tr>
<tr>
<td>= %= /= //= -= += *= **=</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td>成员运算符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
</tbody>
</table>
<h2 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h2>
<h3 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> 条件语句</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure>
<h3 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h3>
<h4 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件：</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure>
<h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">  &lt;statements&gt;</span><br></pre></td></tr></table></figure>
<h4 id="range"><a class="markdownIt-Anchor" href="#range"></a> range()</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h4 id="break-和-continue"><a class="markdownIt-Anchor" href="#break-和-continue"></a> break 和 continue</h4>
<ul>
<li>break 语句可以跳出 for 和 while 的循环体。</li>
<li>continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</li>
</ul>
<h4 id="pass"><a class="markdownIt-Anchor" href="#pass"></a> pass</h4>
<p>pass 语句什么都不做。它只在语法上需要一条语句但程序不需要任何操作时使用.例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 等待键盘中断 (Ctrl+C)</span></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  函数名（参数列表）：</span></span><br><span class="line"><span class="function">    函数体</span></span><br></pre></td></tr></table></figure>
<h3 id="函数变量作用域"><a class="markdownIt-Anchor" href="#函数变量作用域"></a> 函数变量作用域</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line">a = <span class="number">4</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func1</span>():</span></span><br><span class="line">    a = <span class="number">17</span> <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in print_func a = &quot;</span>, a)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in print_func a = &quot;</span>, a)</span><br><span class="line">print_func1()</span><br><span class="line">print_func2()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, a)</span><br></pre></td></tr></table></figure>
<p>以上实例运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> print_func a =  <span class="number">17</span></span><br><span class="line"><span class="keyword">in</span> print_func a =  <span class="number">4</span></span><br><span class="line">a =  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="关键字参数"><a class="markdownIt-Anchor" href="#关键字参数"></a> 关键字参数</h3>
<p>函数也可以使用 kwarg=value 的关键字参数形式被调用.例如,以下函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parrot</span>(<span class="params">voltage, state=<span class="string">&#x27;a stiff&#x27;</span>, action=<span class="string">&#x27;voom&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;Norwegian Blue&#x27;</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- This parrot wouldn&#x27;t&quot;</span>, action, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;if you put&quot;</span>, voltage, <span class="string">&quot;volts through it.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- Lovely plumage, the&quot;</span>, <span class="built_in">type</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- It&#x27;s&quot;</span>, state, <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以以下几种方式被调用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parrot(<span class="number">1000</span>)                                          <span class="comment"># 1 positional argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000</span>)                                  <span class="comment"># 1 keyword argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000000</span>, action=<span class="string">&#x27;VOOOOOM&#x27;</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(action=<span class="string">&#x27;VOOOOOM&#x27;</span>, voltage=<span class="number">1000000</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(<span class="string">&#x27;a million&#x27;</span>, <span class="string">&#x27;bereft of life&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>)         <span class="comment"># 3 positional arguments</span></span><br><span class="line">parrot(<span class="string">&#x27;a thousand&#x27;</span>, state=<span class="string">&#x27;pushing up the daisies&#x27;</span>)  <span class="comment"># 1 positional, 1 keyword</span></span><br></pre></td></tr></table></figure>
<p>以下为错误调用方法：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">parrot<span class="params">()</span>                     <span class="comment"># required argument missing</span></span><br><span class="line">parrot<span class="params">(<span class="attr">voltage</span>=5.0, &#x27;dead&#x27;)</span>  <span class="comment"># non-keyword argument after a keyword argument</span></span><br><span class="line">parrot<span class="params">(110, <span class="attr">voltage</span>=220)</span>     <span class="comment"># duplicate value for the same argument</span></span><br><span class="line">parrot<span class="params">(<span class="attr">actor</span>=&#x27;John Cleese&#x27;)</span>  <span class="comment"># unknown keyword argument</span></span><br></pre></td></tr></table></figure>
<h3 id="可变参数列表"><a class="markdownIt-Anchor" href="#可变参数列表"></a> 可变参数列表</h3>
<p>最后,一个最不常用的选择是可以让函数调用可变个数的参数.这些参数被包装进一个元组(查看元组和序列).在这些可变个数的参数之前,可以有零到多个普通的参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arithmetic_mean</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">sum</span> += x</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h3>
<p>Python 的函数的返回值使用 return 语句，可以将函数作为一个值赋值给指定变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    c = x + y</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3>
<p>try 语句按照如下方式工作；</p>
<ul>
<li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）</li>
<li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</li>
<li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。最后执行 try 语句之后的代码。</li>
<li>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。</li>
<li>不管 try 子句里面有没有发生异常，finally 子句都会执行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = <span class="built_in">int</span>(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OS error: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(err))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Could not convert data to an integer.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unexpected error:&quot;</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 清理行为</span></span><br></pre></td></tr></table></figure>
<h3 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h3>
<p>Python 使用 raise 语句抛出一个指定的异常。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">&#x27;HiThere&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>
<h3 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h3>
<p>可以通过创建一个新的 exception 类来拥有自己的异常。异常应该继承自 Exception 类，或者直接继承，或者间接继承。</p>
<p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputError</span>(<span class="params">Error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Exception raised for errors in the input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        expression -- input expression in which the error occurred</span></span><br><span class="line"><span class="string">        message -- explanation of the error</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, expression, message</span>):</span></span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionError</span>(<span class="params">Error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not</span></span><br><span class="line"><span class="string">    allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        previous -- state at beginning of transition</span></span><br><span class="line"><span class="string">        next -- attempted new state</span></span><br><span class="line"><span class="string">        message -- explanation of why the specific transition is not allowed</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, previous, <span class="built_in">next</span>, message</span>):</span></span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure>
<p>大多数的异常的名字都以&quot;Error&quot;结尾，就跟标准的异常命名一样。</p>
<h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2>
<h3 id="面向对象技术简介"><a class="markdownIt-Anchor" href="#面向对象技术简介"></a> 面向对象技术简介</h3>
<ul>
<li>
<p><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
</li>
<li>
<p>**类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>
</li>
<li>
<p>**数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。</p>
</li>
<li>
<p>**方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
</li>
<li>
<p>**实例变量：**定义在方法中的变量，只作用于当前实例的类。</p>
</li>
<li>
<p>**继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog 是一个 Animal）。</p>
</li>
<li>
<p>**实例化：**创建一个类的实例，类的具体对象。</p>
</li>
<li>
<p>**方法：**类中定义的函数。</p>
</li>
<li>
<p>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
</li>
</ul>
<h3 id="类定义"><a class="markdownIt-Anchor" href="#类定义"></a> 类定义</h3>
<p>语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p>
<h3 id="类对象"><a class="markdownIt-Anchor" href="#类对象"></a> 类对象</h3>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong><a href="http://obj.name">obj.name</a></strong>。</p>
<p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())</span><br></pre></td></tr></table></figure>
<p>实例化类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br></pre></td></tr></table></figure>
<p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p>
<p>执行以上程序输出结果为：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MyClass</span> 类的属性 i 为： <span class="number">12345</span></span><br><span class="line"><span class="keyword">MyClass</span> 类的方法 f 输出为： hello world</span><br></pre></td></tr></table></figure>
<p>很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 <strong>init</strong>() 的特殊方法（构造方法），像下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure>
<p>类定义了 <strong>init</strong>() 方法的话，类的实例化操作会自动调用 <strong>init</strong>() 方法。所以在下例中，可以这样创建一个新的实例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>
<p>当然， <strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.r = realpart</span><br><span class="line"><span class="meta">... </span>        self.i = imagpart</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.r, x.i</span><br><span class="line">(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="类的方法"><a class="markdownIt-Anchor" href="#类的方法"></a> 类的方法</h3>
<p>在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">p = people(<span class="string">&#x27;W3Cschool&#x27;</span>,<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">p.speak()</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">W3Cschool</span> 说: 我 <span class="number">10</span> 岁。</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<p>Python 同样支持类的继承，如果一种语言不支持继承就，类就没有什么意义。派生类的定义如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">BaseClassName1</span>):</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python 从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。</p>
<p>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DerivedClassName</span>(<span class="title">modname</span>.<span class="type">BaseClassName</span>):</span></span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ken</span> 说: 我 <span class="number">10</span> 岁了，我在读 <span class="number">3</span> 年级</span><br></pre></td></tr></table></figure>
<h3 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h3>
<p>Python 同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">Base1, Base2, Base3</span>):</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python 从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span>():</span></span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,t</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"></span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span>(<span class="params">speaker,student</span>):</span></span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"></span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">我叫 Tim，我是一个演说家，我演讲的主题是 Python</span><br></pre></td></tr></table></figure>
<h3 id="方法重写"><a class="markdownIt-Anchor" href="#方法重写"></a> 方法重写</h3>
<p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用父类方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用子类方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">调用子类方法</span><br></pre></td></tr></table></figure>
<h3 id="类属性与方法"><a class="markdownIt-Anchor" href="#类属性与方法"></a> 类属性与方法</h3>
<h4 id="类的私有属性"><a class="markdownIt-Anchor" href="#类的私有属性"></a> 类的私有属性</h4>
<p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时<strong>self.__private_attrs</strong>。</p>
<h4 id="类的方法-2"><a class="markdownIt-Anchor" href="#类的方法-2"></a> 类的方法</h4>
<p>在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</p>
<h4 id="类的私有方法"><a class="markdownIt-Anchor" href="#类的私有方法"></a> 类的私有方法</h4>
<p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 <strong>slef.__private_methods</strong>。</p>
<p>实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span> (self.__secretCount)</span><br><span class="line"></span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="built_in">print</span> (counter.publicCount)</span><br><span class="line"><span class="built_in">print</span> (counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序输出结果为：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, <span class="built_in">line</span> <span class="number">16</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">print</span> (counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: <span class="string">&#x27;JustCounter&#x27;</span> object <span class="built_in">has</span> <span class="keyword">no</span> attribute <span class="string">&#x27;__secretCount&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="类的专有方法"><a class="markdownIt-Anchor" href="#类的专有方法"></a> 类的专有方法：</h4>
<ul>
<li>*<strong>*init</strong> 😗* 构造函数，在生成对象时调用</li>
<li>*<strong>*del</strong> 😗* 析构函数，释放对象时使用</li>
<li>*<strong>*repr</strong> 😗* 打印，转换</li>
<li>*<strong>*setitem</strong> 😗* 按照索引赋值</li>
<li>*<strong>*getitem</strong>😗* 按照索引获取值</li>
<li>*<strong>*len</strong>😗* 获得长度</li>
<li>*<strong>*cmp</strong>😗* 比较运算</li>
<li>*<strong>*call</strong>😗* 函数调用</li>
<li>*<strong>*add</strong>😗* 加运算</li>
<li>*<strong>*sub</strong>😗* 减运算</li>
<li>*<strong>*mul</strong>😗* 乘运算</li>
<li>*<strong>*div</strong>😗* 除运算</li>
<li>*<strong>*mod</strong>😗* 求余运算</li>
<li>*<strong>*pow</strong>😗* 乘方</li>
</ul>
<h4 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h4>
<p>Python 同样支持运算符重载，我么可以对类的专有方法进行重载，实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下所示:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Vector</span><span class="params">(<span class="number">7</span>,<span class="number">8</span>)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="标准库概览"><a class="markdownIt-Anchor" href="#标准库概览"></a> 标准库概览</h2>
<h3 id="操作系统接口"><a class="markdownIt-Anchor" href="#操作系统接口"></a> 操作系统接口</h3>
<p>os 模块提供了不少与操作系统相关联的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()      <span class="comment"># 返回当前的工作目录</span></span><br><span class="line"><span class="string">&#x27;C:\\Python34&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.chdir(<span class="string">&#x27;/server/accesslogs&#x27;</span>)   <span class="comment"># 修改当前的工作目录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">&#x27;mkdir today&#x27;</span>)   <span class="comment"># 执行系统命令 mkdir</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="文件通配符"><a class="markdownIt-Anchor" href="#文件通配符"></a> 文件通配符</h3>
<p>glob 模块提供了一个函数用于从目录通配符搜索中生成文件列表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">&#x27;*.py&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;primes.py&#x27;</span>, <span class="string">&#x27;random.py&#x27;</span>, <span class="string">&#x27;quote.py&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h3>
<p>通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 <code>python demo.py one two three</code> 后可以得到以下输出结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(sys.argv)</span><br><span class="line">[<span class="string">&#x27;demo.py&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="错误输出重定向和程序终止"><a class="markdownIt-Anchor" href="#错误输出重定向和程序终止"></a> 错误输出重定向和程序终止</h3>
<p>sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write(<span class="string">&#x27;Warning, log file not found starting a new one\n&#x27;</span>)</span><br><span class="line">Warning, log file <span class="keyword">not</span> found starting a new one</span><br></pre></td></tr></table></figure>
<h3 id="字符串正则匹配"><a class="markdownIt-Anchor" href="#字符串正则匹配"></a> 字符串正则匹配</h3>
<p>re 模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;\bf[a-z]*&#x27;</span>, <span class="string">&#x27;which foot or hand fell fastest&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;foot&#x27;</span>, <span class="string">&#x27;fell&#x27;</span>, <span class="string">&#x27;fastest&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;(\b[a-z]+) \1&#x27;</span>, <span class="string">r&#x27;\1&#x27;</span>, <span class="string">&#x27;cat in the the hat&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;cat in the hat&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h3>
<p>math 模块为浮点运算提供了对底层 C 函数库的访问:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.cos(math.pi / <span class="number">4</span>)</span><br><span class="line"><span class="number">0.70710678118654757</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.log(<span class="number">1024</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">10.0</span></span><br></pre></td></tr></table></figure>
<h1 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h1>
<ul>
<li><a href="https://github.com/vinta/awesome-python">https://github.com/vinta/awesome-python</a> - 资源大全</li>
<li><a href="https://github.com/jobbole/awesome-python-cn">https://github.com/jobbole/awesome-python-cn</a> - 资源大全</li>
<li><a href="https://github.com/scrapy/scrapy">https://github.com/scrapy/scrapy</a> - python 爬虫框架</li>
<li><a href="https://github.com/faif/python-patterns">https://github.com/faif/python-patterns</a> - python 设计模式</li>
<li><a href="https://github.com/kennethreitz/python-guide">https://github.com/kennethreitz/python-guide</a> - python 最佳实践</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你彻底掌握 Scala</title>
    <url>/coding/scala/</url>
    <content><![CDATA[<h1 id="scala-入门"><a class="markdownIt-Anchor" href="#scala-入门"></a> Scala 入门</h1>
<blockquote>
<p>Scala 是大数据领域的热门语言，如：Akka、Kafka，所以，想要学习大数据顶级开源项目的源码，有必要具备一定的 Scala 基础。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1. 基本语法</a></li>
<li><a href="#2-%E6%B3%A8%E9%87%8A">2. 注释</a></li>
<li><a href="#3-%E5%8F%98%E9%87%8F">3. 变量</a>
<ul>
<li><a href="#31-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E">3.1. 变量类型声明</a></li>
</ul>
</li>
<li><a href="#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4. 数据类型</a></li>
<li><a href="#5-%E6%95%B0%E7%BB%84">5. 数组</a></li>
<li><a href="#6-%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">6. 逻辑控制语句</a>
<ul>
<li><a href="#61-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">6.1. 条件语句</a></li>
<li><a href="#62-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">6.2. 循环语句</a></li>
<li><a href="#63-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">6.3. 模式匹配</a></li>
</ul>
</li>
<li><a href="#7-%E8%BF%90%E7%AE%97%E7%AC%A6">7. 运算符</a></li>
<li><a href="#8-%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0">8. 方法与函数</a></li>
<li><a href="#9-%E9%97%AD%E5%8C%85">9. 闭包</a></li>
<li><a href="#10-%E9%9B%86%E5%90%88">10. 集合</a>
<ul>
<li><a href="#101-%E8%BF%AD%E4%BB%A3%E5%99%A8">10.1. 迭代器</a></li>
</ul>
</li>
<li><a href="#11-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">11. 类和对象</a></li>
<li><a href="#12-trait">12. Trait</a></li>
<li><a href="#13-%E5%BC%82%E5%B8%B8">13. 异常</a></li>
<li><a href="#14-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">14. 输入输出</a>
<ul>
<li><a href="#141-%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">14.1. 读取用户输入</a></li>
<li><a href="#142-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">14.2. 读取文件内容</a></li>
</ul>
</li>
<li><a href="#15-%E5%8C%85">15. 包</a>
<ul>
<li><a href="#151-%E5%AE%9A%E4%B9%89%E5%8C%85">15.1. 定义包</a></li>
<li><a href="#152-%E5%BC%95%E7%94%A8">15.2. 引用</a></li>
<li><a href="#153-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">15.3. 访问修饰符</a></li>
</ul>
</li>
<li><a href="#16-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">16. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-基本语法"><a class="markdownIt-Anchor" href="#1-基本语法"></a> 1. 基本语法</h2>
<p>Scala 基本语法需要注意以下几点：</p>
<ul>
<li><strong>区分大小写</strong> - Scala 是大小写敏感的。</li>
<li><strong>类名</strong> - 对于所有的类名的第一个字母要大写。示例：<code>class MyFirstScalaClass</code></li>
<li><strong>方法名称</strong> - 所有的方法名称的第一个字母用小写。示例：<code>def myMethodName()</code></li>
<li><strong>程序文件名</strong> - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)。示例: 假设&quot;HelloWorld&quot;是对象的名称。那么该文件应保存为’HelloWorld.scala&quot;</li>
<li><strong><code>def main(args: Array[String])</code></strong> - Scala 程序从 <code>main()</code> 方法开始处理，这是每一个 Scala 程序的强制程序入口部分。</li>
<li>一行中只有空格或者带有注释，Scala 会认为其是空行，会忽略它。标记可以被空格或者注释来分割。</li>
<li>Scala 是面向行的语言，语句可以用分号（;）结束或换行符。</li>
</ul>
<h2 id="2-注释"><a class="markdownIt-Anchor" href="#2-注释"></a> 2. 注释</h2>
<p>Scala 类似 Java 支持单行和多行注释。</p>
<p>【示例】单行和多行注释</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这是我的第一个 Scala 程序</span></span><br><span class="line"><span class="comment">   * 以下程序将输出&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, world!&quot;</span>) <span class="comment">// 输出 Hello World</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-变量"><a class="markdownIt-Anchor" href="#3-变量"></a> 3. 变量</h2>
<p>在 Scala 中，使用关键词 <code>var</code> 声明变量，使用关键词 <code>val</code> 声明常量。</p>
<p>【示例】声明变量</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">&quot;Foo&quot;</span></span><br><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">&quot;Too&quot;</span></span><br></pre></td></tr></table></figure>
<p>【示例】声明常量</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myVal : <span class="type">String</span> = <span class="string">&quot;Foo&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="31-变量类型声明"><a class="markdownIt-Anchor" href="#31-变量类型声明"></a> 3.1. 变量类型声明</h3>
<p>变量的类型在变量名之后等号之前声明。定义变量的类型的语法格式如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量类型</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">Initial</span> <span class="type">Value</span>]</span><br><span class="line"><span class="comment">// 声明常量类型</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">Initial</span> <span class="type">Value</span>]</span><br></pre></td></tr></table></figure>
<p>在 Scala 中声明变量和常量不一定要指明数据类型，在没有指明数据类型的情况下，其数据类型是通过变量或常量的初始值推断出来的。所以，如果在没有指明数据类型的情况下声明变量或常量必须要给出其初始值，否则将会报错。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">val</span> myVal = <span class="string">&quot;Hello, Scala!&quot;</span>;</span><br><span class="line"><span class="keyword">val</span> xmax, ymax = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="4-数据类型"><a class="markdownIt-Anchor" href="#4-数据类型"></a> 4. 数据类型</h2>
<p>Scala 与 Java 有着相同的数据类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Byte</td>
<td style="text-align:left">8 位有符号补码整数。数值区间为 -128 到 127</td>
</tr>
<tr>
<td style="text-align:left">Short</td>
<td style="text-align:left">16 位有符号补码整数。数值区间为 -32768 到 32767</td>
</tr>
<tr>
<td style="text-align:left">Int</td>
<td style="text-align:left">32 位有符号补码整数。数值区间为 -2147483648 到 2147483647</td>
</tr>
<tr>
<td style="text-align:left">Long</td>
<td style="text-align:left">64 位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td>
</tr>
<tr>
<td style="text-align:left">Float</td>
<td style="text-align:left">32 位, IEEE 754 标准的单精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">Double</td>
<td style="text-align:left">64 位 IEEE 754 标准的双精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">Char</td>
<td style="text-align:left">16 位无符号 Unicode 字符, 区间值为 U+0000 到 U+FFFF</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">字符序列</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">true 或 false</td>
</tr>
<tr>
<td style="text-align:left">Unit</td>
<td style="text-align:left">表示无值，和其他语言中 void 等同。用作不返回任何结果的方法的结果类型。Unit 只有一个实例值，写成()。</td>
</tr>
<tr>
<td style="text-align:left">Null</td>
<td style="text-align:left">null 或空引用</td>
</tr>
<tr>
<td style="text-align:left">Nothing</td>
<td style="text-align:left">Nothing 类型在 Scala 的类层级的最底端；它是任何其他类型的子类型。</td>
</tr>
<tr>
<td style="text-align:left">Any</td>
<td style="text-align:left">Any 是所有其他类的超类</td>
</tr>
<tr>
<td style="text-align:left">AnyRef</td>
<td style="text-align:left">AnyRef 类是 Scala 里所有引用类(reference class)的基类</td>
</tr>
</tbody>
</table>
<p>上表中列出的数据类型都是<strong>对象</strong>，也就是说 scala 没有 java 中的原生类型。在 scala 是可以对数字等基础类型调用方法的。</p>
<h2 id="5-数组"><a class="markdownIt-Anchor" href="#5-数组"></a> 5. 数组</h2>
<p>Scala 数组声明的语法格式：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> z:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="6-逻辑控制语句"><a class="markdownIt-Anchor" href="#6-逻辑控制语句"></a> 6. 逻辑控制语句</h2>
<h3 id="61-条件语句"><a class="markdownIt-Anchor" href="#61-条件语句"></a> 6.1. 条件语句</h3>
<p>【示例】条件语句</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IfDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">10</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;X 的值为 10&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">20</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;X 的值为 20&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;X 的值为 30&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;无法判断 X 的值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="62-循环语句"><a class="markdownIt-Anchor" href="#62-循环语句"></a> 6.2. 循环语句</h3>
<p>和 Java 一样，Scala 支持 <code>while</code>、<code>do ... while</code>、<code>for</code> 三种循环语句。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WhileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while 循环执行</span></span><br><span class="line">    <span class="keyword">while</span> (a &lt; <span class="number">20</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;Value of a: &quot;</span> + a);</span><br><span class="line">      a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>scala 不支持 <code>break</code> 和 <code>continue</code></strong>。但是，可以通过 <code>Breaks</code> 对象来进行循环控制。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BreakDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">val</span> numList1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">val</span> numList2 = <span class="type">List</span>(<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> outer = <span class="keyword">new</span> <span class="type">Breaks</span>;</span><br><span class="line">    <span class="keyword">val</span> inner = <span class="keyword">new</span> <span class="type">Breaks</span>;</span><br><span class="line"></span><br><span class="line">    outer.breakable &#123;</span><br><span class="line">      <span class="keyword">for</span> (a &lt;- numList1) &#123;</span><br><span class="line">        println(<span class="string">&quot;Value of a: &quot;</span> + a);</span><br><span class="line">        inner.breakable &#123;</span><br><span class="line">          <span class="keyword">for</span> (b &lt;- numList2) &#123;</span><br><span class="line">            println(<span class="string">&quot;Value of b: &quot;</span> + b);</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">12</span>) &#123;</span><br><span class="line">              inner.<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="comment">// 内嵌循环中断</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="comment">// 外部循环中断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="63-模式匹配"><a class="markdownIt-Anchor" href="#63-模式匹配"></a> 6.3. 模式匹配</h3>
<p>scala 的 <code>match</code> 对应 Java 里的 <code>switch</code>，但是写在选择器表达式之后。即： <strong>选择器 match {备选项}。</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author peng.zhang</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(matchTest(<span class="string">&quot;two&quot;</span>))</span><br><span class="line">    println(matchTest(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">    println(matchTest(<span class="number">1</span>))</span><br><span class="line">    println(matchTest(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Any</span>): <span class="type">Any</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>      =&gt; <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;two&quot;</span>  =&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> y: <span class="type">Int</span> =&gt; <span class="string">&quot;scala.Int&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _      =&gt; <span class="string">&quot;many&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-运算符"><a class="markdownIt-Anchor" href="#7-运算符"></a> 7. 运算符</h2>
<p>Scala 含有丰富的内置运算符，包括以下几种类型：</p>
<ul>
<li>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></li>
<li>关系运算符：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></li>
<li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li>
<li>位运算符：<code>~</code>、<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code> （无符号右移）</li>
<li>赋值运算符：<code>=</code></li>
</ul>
<h2 id="8-方法与函数"><a class="markdownIt-Anchor" href="#8-方法与函数"></a> 8. 方法与函数</h2>
<p>Scala 有方法与函数，二者在语义上的区别很小。</p>
<p>Scala 中的方法跟 Java 的类似，方法是组成类的一部分。</p>
<p>Scala 中的函数则是一个完整的对象，Scala 中的函数其实就是继承了 Trait 的类的对象。</p>
<p>Scala 中使用 <code>val</code> 语句可以定义函数，<code>def</code> 语句定义方法。</p>
<p>【示例】</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m</span></span>(x: <span class="type">Int</span>) = x + <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> f = (x: <span class="type">Int</span>) =&gt; x + <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-闭包"><a class="markdownIt-Anchor" href="#9-闭包"></a> 9. 闭包</h2>
<p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p>
<p>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</p>
<p>如下面这段匿名的函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>函数体内有一个变量 i，它作为函数的一个参数。如下面的另一段代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br></pre></td></tr></table></figure>
<p>在 multiplier 中有两个变量：i 和 factor。其中的一个 i 是函数的形式参数，在 multiplier 函数被调用时，i 被赋予一个新的值。然而，factor 不是形式参数，而是自由变量，考虑下面代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br></pre></td></tr></table></figure>
<p>这里我们引入一个自由变量 factor，这个变量定义在函数外面。</p>
<p>这样定义的函数变量 multiplier 成为一个&quot;闭包&quot;，因为它引用到函数外面定义的变量，定义这个函数的过程是将这个自由变量捕获而构成一个封闭的函数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClosureDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">&quot;muliplier(1) value = &quot;</span> + multiplier(<span class="number">1</span>))</span><br><span class="line">    println(<span class="string">&quot;muliplier(2) value = &quot;</span> + multiplier(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> multiplier = (i: <span class="type">Int</span>) =&gt; i * factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-集合"><a class="markdownIt-Anchor" href="#10-集合"></a> 10. 集合</h2>
<p>Scala 集合支持 List、Set、Map、元祖、Option。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义整型 List</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Set</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Map</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Map</span>(<span class="string">&quot;one&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;two&quot;</span> -&gt; <span class="number">2</span>, <span class="string">&quot;three&quot;</span> -&gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个不同类型元素的元组</span></span><br><span class="line"><span class="keyword">val</span> x = (<span class="number">10</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Option</span></span><br><span class="line"><span class="keyword">val</span> x:<span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="101-迭代器"><a class="markdownIt-Anchor" href="#101-迭代器"></a> 10.1. 迭代器</h3>
<p>迭代器 it 的两个基本操作是 <strong>next</strong> 和 <strong>hasNext</strong>。</p>
<p>调用 <strong>it.next()</strong> 会返回迭代器的下一个元素，并且更新迭代器的状态。</p>
<p>调用 <strong>it.hasNext()</strong> 用于检测集合中是否还有元素。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="keyword">val</span> it = <span class="type">Iterator</span>(<span class="string">&quot;Baidu&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (it.hasNext)&#123;</span><br><span class="line">         println(it.next())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-类和对象"><a class="markdownIt-Anchor" href="#11-类和对象"></a> 11. 类和对象</h2>
<p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">val xc: <span class="type">Int</span>, val yc: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = x + dx</span><br><span class="line">    y = y + dy</span><br><span class="line">    println(<span class="string">&quot;x 的坐标点 : &quot;</span> + x);</span><br><span class="line">    println(<span class="string">&quot;y 的坐标点 : &quot;</span> + y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>(<span class="params">override val xc: <span class="type">Int</span>, override val yc: <span class="type">Int</span>, val zc: <span class="type">Int</span></span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">Point</span>(xc, yc) &#123;</span><br><span class="line">  <span class="keyword">var</span> z: <span class="type">Int</span> = zc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>, dz: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = x + dx</span><br><span class="line">    y = y + dy</span><br><span class="line">    z = z + dz</span><br><span class="line">    println(<span class="string">&quot;x 的坐标点 : &quot;</span> + x);</span><br><span class="line">    println(<span class="string">&quot;y 的坐标点 : &quot;</span> + y);</span><br><span class="line">    println(<span class="string">&quot;z 的坐标点 : &quot;</span> + z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> loc = <span class="keyword">new</span> <span class="type">Location</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移到一个新的位置</span></span><br><span class="line">    loc.move(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-trait"><a class="markdownIt-Anchor" href="#12-trait"></a> 12. Trait</h2>
<p>Scala Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。</p>
<p>与接口不同的是，它还可以定义属性和方法的实现。</p>
<p>一般情况下 Scala 的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Equal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNotEqual</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = !isEqual(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">xc: <span class="type">Int</span>, yc: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Equal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(obj: <span class="type">Any</span>) =</span><br><span class="line">    obj.isInstanceOf[<span class="type">Point</span>] &amp;&amp;</span><br><span class="line">      obj.asInstanceOf[<span class="type">Point</span>].x == x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> p3 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    println(p1.isNotEqual(p2))</span><br><span class="line">    println(p1.isNotEqual(p3))</span><br><span class="line">    println(p1.isNotEqual(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-异常"><a class="markdownIt-Anchor" href="#13-异常"></a> 13. 异常</h2>
<p>Scala 抛出异常的方法和 Java 一样，使用 <code>throw</code> 关键词。</p>
<p>【示例】抛出异常</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span></span><br></pre></td></tr></table></figure>
<p>【示例】捕获异常</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">FileNotFoundException</span>, <span class="type">FileReader</span>, <span class="type">IOException</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">FileNotFoundException</span> =&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;Missing file exception&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">IOException</span> =&gt; &#123;</span><br><span class="line">        println(<span class="string">&quot;IO Exception&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;Exiting finally...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-输入输出"><a class="markdownIt-Anchor" href="#14-输入输出"></a> 14. 输入输出</h2>
<h3 id="141-读取用户输入"><a class="markdownIt-Anchor" href="#141-读取用户输入"></a> 14.1. 读取用户输入</h3>
<p>使用 <code>scala.io.StdIn.readLine()</code> 方法读取用户输入</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StdInDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    print(<span class="string">&quot;请输入内容: &quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> line = <span class="type">StdIn</span>.readLine()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;你输入的是: &quot;</span> + line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="142-读取文件内容"><a class="markdownIt-Anchor" href="#142-读取文件内容"></a> 14.2. 读取文件内容</h3>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SourceDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">&quot;文件内容为:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">Source</span>.fromFile(<span class="string">&quot;test.txt&quot;</span>).foreach &#123;</span><br><span class="line">      print</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-包"><a class="markdownIt-Anchor" href="#15-包"></a> 15. 包</h2>
<h3 id="151-定义包"><a class="markdownIt-Anchor" href="#151-定义包"></a> 15.1. 定义包</h3>
<p>Scala 使用 <code>package</code> 关键字定义包，在 Scala 将代码定义到某个包中有两种方式：</p>
<p>第一种方法和 Java 一样，在文件的头定义包名，这种方法就后续所有代码都放在该包中。 比如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br></pre></td></tr></table></figure>
<p>第二种方法有些类似 C#，如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="152-引用"><a class="markdownIt-Anchor" href="#152-引用"></a> 15.2. 引用</h3>
<p>Scala 使用 <code>import</code> 关键字引用包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color  <span class="comment">// 引入Color</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt._  <span class="comment">// 引入包内所有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">handler</span><span class="params">(evt: event.ActionEvent)</span> </span>&#123; <span class="comment">// java.awt.event.ActionEvent</span></span><br><span class="line">  ...  <span class="comment">// 因为引入了java.awt，所以可以省去前面的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>import 语句可以出现在任何地方，而不是只能在文件顶部。import 的效果从开始延伸到语句块的结束。这可以大幅减少名称冲突的可能性。</p>
<p>如果想要引入包中的几个成员，可以使用 selector（选取器）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.&#123;Color, Font&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名成员</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;HashMap =&gt; JavaHashMap&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏成员</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;HashMap =&gt; _, _&#125; <span class="comment">// 引入了util包的所有成员，但是HashMap被隐藏了</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意：**默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以 scala 开头的包，在使用时都是省去 scala.的。</p>
</blockquote>
<h3 id="153-访问修饰符"><a class="markdownIt-Anchor" href="#153-访问修饰符"></a> 15.3. 访问修饰符</h3>
<p>Scala 访问修饰符基本和 Java 的一样，分别有：private，protected，public。</p>
<p>如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public。</p>
<p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() &#123;</span><br><span class="line">      println(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerMost</span> </span>&#123;</span><br><span class="line">      f() <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">new</span> <span class="type">Inner</span>).f() <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-参考资料"><a class="markdownIt-Anchor" href="#16-参考资料"></a> 16. 参考资料</h2>
<ul>
<li><a href="https://www.scala-lang.org/">Scala 官网</a></li>
<li><a href="https://www.runoob.com/scala/scala-tutorial.html">Scala 菜鸟教程</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 DNS</title>
    <url>/network/dns/</url>
    <content><![CDATA[<h1 id="网络通信之-cdn"><a class="markdownIt-Anchor" href="#网络通信之-cdn"></a> 网络通信之 CDN</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p>
<p>关键词：DNS, 域名解析</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-dns">什么是 DNS</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%9F%E5%90%8D">什么是域名</a></li>
<li><a href="#dns-%E7%9A%84%E5%88%86%E5%B1%82">DNS 的分层</a></li>
<li><a href="#dns-%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B">DNS 服务类型</a></li>
<li><a href="#%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B">记录类型</a></li>
</ul>
</li>
<li><a href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90">域名解析</a></li>
<li><a href="#linux-%E4%B8%8A%E7%9A%84%E5%9F%9F%E5%90%8D%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">Linux 上的域名相关命令</a>
<ul>
<li><a href="#hostname">hostname</a></li>
<li><a href="#nslookup">nslookup</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9">更多内容</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="什么是-dns"><a class="markdownIt-Anchor" href="#什么是-dns"></a> 什么是 DNS</h3>
<p>DNS 是一个应用层协议。</p>
<p>域名系统 (DNS) 的作用是将人类可读的域名 (如，<a href="http://www.example.com">www.example.com</a>) 转换为机器可读的 IP 地址 (如，192.0.2.44)。</p>
<h3 id="什么是域名"><a class="markdownIt-Anchor" href="#什么是域名"></a> 什么是域名</h3>
<p>域名是由一串用点分隔符 <code>.</code> 组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的方位。域名可以说是一个 IP 地址的代称，目的是为了便于记忆后者。例如，<a href="http://wikipedia.org">wikipedia.org</a> 是一个域名，和 IP 地址 208.80.152.2 相对应。人们可以直接访问 <a href="http://wikipedia.org">wikipedia.org</a> 来代替 IP 地址，然后域名系统（DNS）就会将它转化成便于机器识别的 IP 地址。这样，人们只需要记忆 <a href="http://wikipedia.org">wikipedia.org</a> 这一串带有特殊含义的字符，而不需要记忆没有含义的数字。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/dns/dns-domain.png"/></div>
<h3 id="dns-的分层"><a class="markdownIt-Anchor" href="#dns-的分层"></a> DNS 的分层</h3>
<p><strong>域名系统是分层次的。</strong></p>
<p>在域名系统的层次结构中，各种域名都隶属于域名系统根域的下级。域名的第一级是顶级域，它包括通用顶级域，例如 <code>.com</code>、<code>.net</code> 和 <code>.org</code>；以及国家和地区顶级域，例如 <code>.us</code>、<code>.cn</code> 和 <code>.tk</code>。顶级域名下一层是二级域名，一级一级地往下。这些域名向人们提供注册服务，人们可以用它创建公开的互联网资源或运行网站。顶级域名的管理服务由对应的域名注册管理机构（域名注册局）负责，注册服务通常由域名注册商负责。</p>
<h3 id="dns-服务类型"><a class="markdownIt-Anchor" href="#dns-服务类型"></a> DNS 服务类型</h3>
<ul>
<li><strong>授权型 DNS</strong> - 一种授权型 DNS 服务提供一种更新机制，供开发人员用于管理其公用 DNS 名称。然后，它响应 DNS 查询，将域名转换为 IP 地址，以便计算机可以相互通信。授权型 DNS 对域有最终授权且负责提供递归型 DNS 服务器对 IP 地址信息的响应。Amazon Route 53 是一种授权型 DNS 系统。</li>
<li><strong>递归型 DNS</strong> - 客户端通常不会对授权型 DNS 服务直接进行查询。而是通常连接到称为解析程序的其他类型 DNS 服务，或递归型 DNS 服务。递归型 DNS 服务就像是旅馆的门童：尽管没有任何自身的 DNS 记录，但是可充当代表您获得 DNS 信息的中间程序。如果递归型 DNS 拥有已缓存或存储一段时间的 DNS 参考，那么它会通过提供源或 IP 信息来响应 DNS 查询。如果没有，则它会将查询传递到一个或多个授权型 DNS 服务器以查找信息。</li>
</ul>
<h3 id="记录类型"><a class="markdownIt-Anchor" href="#记录类型"></a> 记录类型</h3>
<p>DNS 中，常见的资源记录类型有：</p>
<ul>
<li><strong>NS 记录（域名服务）</strong> ─ 指定解析域名或子域名的 DNS 服务器。</li>
<li><strong>MX 记录（邮件交换）</strong> ─ 指定接收信息的邮件服务器。</li>
<li><strong>A 记录（地址）</strong> ─ 指定域名对应的 IPv4 地址记录。</li>
<li><strong>AAAA 记录（地址）</strong> ─ 指定域名对应的 IPv6 地址记录。</li>
<li><strong>CNAME（规范）</strong> ─ 一个域名映射到另一个域名或 <code>CNAME</code> 记录（ <a href="http://example.com">example.com</a> 指向 <a href="http://www.example.com/">www.example.com</a> ）或映射到一个 <code>A</code>记录。</li>
<li><strong>PTR 记录（反向记录）</strong> ─ PTR 记录用于定义与 IP 地址相关联的名称。 PTR 记录是 A 或 AAAA 记录的逆。 PTR 记录是唯一的，因为它们以 .arpa 根开始并被委派给 IP 地址的所有者。</li>
</ul>
<blockquote>
<p>详细可以参考：<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8">维基百科 - 域名服务器记录类型列表</a></p>
</blockquote>
<h2 id="域名解析"><a class="markdownIt-Anchor" href="#域名解析"></a> 域名解析</h2>
<p>主机名到 IP 地址的映射有两种方式：</p>
<ul>
<li><strong>静态映射</strong> - 在本机上配置域名和 IP 的映射，旨在本机上使用。Windows 和 Linux 的 hosts 文件中的内容就属于静态映射。</li>
<li><strong>动态映射</strong> - 建立一套域名解析系统（DNS），只在专门的 DNS 服务器上配置主机到 IP 地址的映射，网络上需要使用主机名通信的设备，首先需要到 DNS 服务器查询主机所对应的 IP 地址。</li>
</ul>
<p>通过域名去查询域名服务器，得到 IP 地址的过程叫做域名解析。在解析域名时，一般先静态域名解析，再动态解析域名。可以将一些常用的域名放入静态域名解析表中，这样可以大大提高域名解析效率。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/dns/dns-resolve.png"/></div>
<p>上图展示了一个动态域名解析的流程，步骤如下：</p>
<ol>
<li>用户打开 Web 浏览器，在地址栏中输入 <a href="http://www.example.com">www.example.com</a>，然后按 Enter 键。</li>
<li><a href="http://www.example.com">www.example.com</a> 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。</li>
<li>ISP 的 DNS 解析程序将 <a href="http://www.example.com">www.example.com</a> 的请求转发到 DNS 根名称服务器。</li>
<li>ISP 的 DNS 解析程序再次转发 <a href="http://www.example.com">www.example.com</a> 的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 <a href="http://example.com">example.com</a> 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。</li>
<li>ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将 <a href="http://www.example.com">www.example.com</a> 的请求转发到该名称服务器。</li>
<li>Amazon Route 53 名称服务器在 <a href="http://example.com">example.com</a> 托管区域中查找 <a href="http://www.example.com">www.example.com</a> 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。</li>
<li>ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 <a href="http://example.com">example.com</a> 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 <a href="http://example.com">example.com</a> 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。</li>
<li>Web 浏览器将 <a href="http://www.example.com">www.example.com</a> 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。</li>
<li>192.0.2.44 上的 Web 服务器或其他资源将 <a href="http://www.example.com">www.example.com</a> 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。</li>
</ol>
<blockquote>
<p>🔔 注意：只有配置了域名服务器，才能执行域名解析。</p>
<p>例如，在 Linux 中执行 <code>vim /etc/resolv.conf</code> 命令，在其中添加下面的内容来配置域名服务器地址：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nameserver</span> <span class="number">218.2.135.1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="linux-上的域名相关命令"><a class="markdownIt-Anchor" href="#linux-上的域名相关命令"></a> Linux 上的域名相关命令</h2>
<h3 id="hostname"><a class="markdownIt-Anchor" href="#hostname"></a> hostname</h3>
<blockquote>
<p>hostname 命令用于查看和设置系统的主机名称。环境变量 HOSTNAME 也保存了当前的主机名。在使用 hostname 命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改 <code>/etc/hosts</code> 和 <code>/etc/sysconfig/network</code> 的相关内容。</p>
<p>参考：<a href="http://man.linuxde.net/hostname">http://man.linuxde.net/hostname</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">AY1307311912260196fcZ</span><br></pre></td></tr></table></figure>
<h3 id="nslookup"><a class="markdownIt-Anchor" href="#nslookup"></a> nslookup</h3>
<blockquote>
<p>nslookup 命令是常用域名查询工具，就是查 DNS 信息用的命令。</p>
<p>参考：<a href="http://man.linuxde.net/nslookup">http://man.linuxde.net/nslookup</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nslookup www.jsdig.com</span></span><br><span class="line">Server:         202.96.104.15</span><br><span class="line">Address:        202.96.104.15<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.jsdig.com canonical name = host.1.jsdig.com.</span><br><span class="line">Name:   host.1.jsdig.com</span><br><span class="line">Address: 100.42.212.8</span><br></pre></td></tr></table></figure>
<h2 id="更多内容"><a class="markdownIt-Anchor" href="#更多内容"></a> 更多内容</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D">维基百科 - 域名</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">维基百科 - 域名系统</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8">维基百科 - 域名服务器记录类型列表</a></li>
<li><a href="https://aws.amazon.com/cn/route53/what-is-dns/">什么是 DNS？</a></li>
<li><a href="https://tools.ietf.org/html/rfc1034">RFC 1034</a></li>
<li><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络通信之 CDN</title>
    <url>/network/cdn/</url>
    <content><![CDATA[<h1 id="网络通信之-cdn"><a class="markdownIt-Anchor" href="#网络通信之-cdn"></a> 网络通信之 CDN</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#cdn-%E6%98%AF%E4%BB%80%E4%B9%88">CDN 是什么</a></li>
<li><a href="#cdn-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">CDN 的优缺点</a></li>
</ul>
</li>
<li><a href="#cdn-%E5%8E%9F%E7%90%86">CDN 原理</a>
<ul>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8">分布式存储</a></li>
<li><a href="#%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86">内容管理</a></li>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91">网络请求的重定向</a></li>
</ul>
</li>
<li><a href="#cdn-%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B">CDN 访问流程</a></li>
<li><a href="#%E6%8E%A8%E9%80%81%E5%92%8C%E6%8B%89%E5%8F%96">推送和拉取</a>
<ul>
<li><a href="#cdn-%E6%8E%A8%E9%80%81">CDN 推送</a></li>
<li><a href="#cdn-%E6%8B%89%E5%8F%96">CDN 拉取</a></li>
</ul>
</li>
<li><a href="#%E8%B5%84%E6%BA%90">资源</a></li>
</ul>
<!-- /TOC -->
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559138689425.png"/></div>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="cdn-是什么"><a class="markdownIt-Anchor" href="#cdn-是什么"></a> CDN 是什么</h3>
<p>CDN(<strong>Content Delivery Network</strong>)，即<strong>内容分发网络</strong>。</p>
<p>CDN 是一个全球性的代理服务器分布式网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供。CDN 的 DNS 解析会告知客户端连接哪台服务器。CDN 的关键技术主要有内容存储和分发技术。</p>
<h3 id="cdn-的优缺点"><a class="markdownIt-Anchor" href="#cdn-的优缺点"></a> CDN 的优缺点</h3>
<ul>
<li>优点
<ul>
<li><strong>访问加速</strong> - 由于 CDN 就近服务，大大降低了网络传播时延，所以自然提高了访问速度。</li>
<li><strong>降低负载</strong> - 如果 CDN 已经能获取数据，那么就不必请求源站，这自然降低了源站（服务器）的负载。</li>
</ul>
</li>
<li>缺点
<ul>
<li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li>
<li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li>
<li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li>
</ul>
</li>
</ul>
<h2 id="cdn-原理"><a class="markdownIt-Anchor" href="#cdn-原理"></a> CDN 原理</h2>
<p>CDN 的基本原理是：</p>
<ul>
<li>广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中；</li>
<li>在用户访问网站时，实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息来选择最佳缓存服务器；</li>
<li>然后，将用户的请求重新导向最佳的缓存服务器上，由缓存服务器直接响应用户请求。</li>
</ul>
<p>CDN 网络架构主要由两大部分，分为<strong>中心</strong>和<strong>边缘</strong>两部分：</p>
<ul>
<li>中心指 CDN 网管中心和 DNS 重定向解析中心，负责全局负载均衡，设备系统安装在管理中心机房；</li>
<li>边缘主要指异地节点，CDN 分发的载体，主要由 Cache 和负载均衡器等组成。</li>
</ul>
<p>CDN 是一个策略性部署的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>内容管理</strong>和<strong>网络请求的重定向</strong>４个要件。</p>
<h3 id="分布式存储"><a class="markdownIt-Anchor" href="#分布式存储"></a> 分布式存储</h3>
<p>CDN 网络将存储资源分布到各个地理位置、各个网段。存储系统作为 CDN 系统密不可分的一部分，将 CDN 分发的文件和数据库表记录内容存储起来，提供持续服务。存储系统采用三级存储架构，包括核心存储、CDN 服务节点分布式缓存和终端本地缓存。任意一个点的存储崩溃或失效，并不影响系统服务的可用性。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559140068433.png"/></div>
<p>如 CDN 系统在 5 大运营商（中国电信、中国网通、中国铁通、中国移动、中国联通）以及 2 大专有网络（中国教育和科研计算机网、中国科技网）都布有 CDN 节点。<strong>这样就消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。</strong></p>
<h3 id="内容管理"><a class="markdownIt-Anchor" href="#内容管理"></a> 内容管理</h3>
<p>内容管理和全局的网络流量管理(Traffic Management)是 CDN 的核心所在。<strong>通过用户就近性和服务器负载的判断，CDN 确保内容以一种极为高效的方式为用户的请求提供服务</strong>。总的来说，内容服务基于<strong>缓存服务器</strong>，也称作<strong>代理缓存(Surrogate)</strong>，它位于网络的边缘，距用户仅有&quot;一跳&quot;(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于 CDN 服务提供商的数据中心）的一个透明镜像。这样的架构使得 CDN 服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。据统计，采用 CDN 技术，能处理整个网站页面的 70%～ 95％的内容访问量，减轻服务器的压力，提升了网站的性能和可扩展性。</p>
<h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3>
<p>CDN 负载均衡系统实现 CDN 的<strong>内容路由功能</strong>。它的作用是将用户的请求导向整个 CDN 网络中的最佳节点。最佳节点的选定可以根据多种策略，例如<strong>距离最近</strong>、<strong>节点负载最轻</strong>等。负载均衡系统是整个 CDN 的核心，负载均衡的准确性和效率直接决定了整个 CDN 的效率和性能。通常负载均衡可以分为两个层次：<strong>全局负载均衡（GSLB）<strong>和</strong>本地负载均衡（SLB）</strong>。</p>
<h3 id="网络请求的重定向"><a class="markdownIt-Anchor" href="#网络请求的重定向"></a> 网络请求的重定向</h3>
<p>当用户访问了使用 CDN 服务的资源时，DNS 域名服务器通过 CNAME 方式将最终域名请求重定向到 CDN 系统中的智能 DNS 负载均衡系统。<strong>智能 DNS 负载均衡系统通过一组预先定义好的策略（如内容类型、地理区域、网络负载状况等），将当时能够最快响应用户的节点地址提供给用户，使用户可以得到快速的服务</strong>。</p>
<p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html">CDN-内容推送网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39028766">闲话 CDN</a></li>
</ul>
</blockquote>
<h2 id="cdn-访问流程"><a class="markdownIt-Anchor" href="#cdn-访问流程"></a> CDN 访问流程</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559126750010.png"/></div>
<ol>
<li>用户在浏览器中访问域名，域名解析的请求被发往网站的 DNS 域名解析服务器；</li>
<li>由于网站的 DNS 域名解析服务器对此域名的解析设置了 CNAME，请求被指向 CDN 网络中的智能 DNS 负载均衡系统；</li>
<li>智能 DNS 负载均衡系统对域名进行智能解析，将响应速度最快的节点 IP 返回给用户；浏览器在得到速度最快节点的 IP 地址以后，向 CDN 节点发出访问请求；</li>
<li>由于是第一次访问，CDN 节点将回到源站取用户请求的数据并发给用户；</li>
<li>当有其他用户再次访问同样内容时，CDN 将直接将数据返回给客户，完成请求/服务过程。</li>
</ol>
<p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html">CDN-内容推送网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39028766">闲话 CDN</a></li>
</ul>
</blockquote>
<h2 id="推送和拉取"><a class="markdownIt-Anchor" href="#推送和拉取"></a> 推送和拉取</h2>
<p>CDN 服务有推送和拉取两种方式：</p>
<h3 id="cdn-推送"><a class="markdownIt-Anchor" href="#cdn-推送"></a> CDN 推送</h3>
<p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p>
<p>优点在于节省源站带宽，提前将要分发的内容放到 CDN 节点上了，当某个流量高峰来临时，不会把你的源站带宽占满（源站还要留点带宽提供动态 HTML 啊）。</p>
<p>缺点是需要针对 CDN 做接口开发，在被分发内容生成时主动上传给 CDN。</p>
<h3 id="cdn-拉取"><a class="markdownIt-Anchor" href="#cdn-拉取"></a> CDN 拉取</h3>
<p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p>
<p><a href="https://en.wikipedia.org/wiki/Time_to_live">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p>
<p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p>
<p>优点在于实现简单。</p>
<blockquote>
<p>参考：<a href="https://segmentfault.com/q/1010000000119794">推送式与拉取式 CDN 服务的优劣问题</a></p>
</blockquote>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li>文章
<ul>
<li><a href="https://en.wikipedia.org/wiki/Content_delivery_network">Wikipedia - CDN</a></li>
<li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html">CDN-内容推送网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39028766">闲话 CDN</a></li>
<li><a href="https://www.cnblogs.com/losbyday/p/5843960.html">CDN 技术详解</a></li>
<li><a href="https://segmentfault.com/q/1010000000119794">推送式与拉取式 CDN 服务的优劣问题</a></li>
</ul>
</li>
<li>CDN 资源
<ul>
<li><a href="https://staticfile.org/">https://staticfile.org/</a></li>
<li><a href="https://unpkg.com/">https://unpkg.com/</a></li>
<li><a href="https://cdnjs.com/">https://cdnjs.com/</a></li>
<li><a href="https://github.com/ossrs/srs">https://github.com/ossrs/srs</a></li>
<li><a href="https://github.com/jsdelivr/jsdelivr">https://github.com/jsdelivr/jsdelivr</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你彻底掌握 Shell</title>
    <url>/coding/shell/</url>
    <content><![CDATA[<blockquote>
<p>由于 bash 是 Linux 标准默认的 shell 解释器，可以说 bash 是 shell 编程的基础。</p>
<p><em>本文主要介绍 bash 的语法，对于 linux 指令不做任何介绍</em>。</p>
<p>📦 本文已归档到：『<a href="https://github.com/dunwu/blog"><em><strong>blog</strong></em></a>』<br />
💻 本文的源码已归档到『 <a href="https://github.com/dunwu/linux-tutorial/tree/master/codes/shell/demos"><em><strong>linux-tutorial</strong></em></a>』</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">███████╗██╗  ██╗███████╗██╗     ██╗</span><br><span class="line">██╔════╝██║  ██║██╔════╝██║     ██║</span><br><span class="line">███████╗███████║█████╗  ██║     ██║</span><br><span class="line">╚════██║██╔══██║██╔══╝  ██║     ██║</span><br><span class="line">███████║██║  ██║███████╗███████╗███████╗</span><br></pre></td></tr></table></figure>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="什么是-shell"><a class="markdownIt-Anchor" href="#什么是-shell"></a> 什么是 shell</h3>
<ul>
<li>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。</li>
<li>Shell 既是一种命令语言，又是一种程序设计语言。</li>
<li>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。</li>
</ul>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<h3 id="什么是-shell-脚本"><a class="markdownIt-Anchor" href="#什么是-shell-脚本"></a> 什么是 shell 脚本</h3>
<p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 <code>.sh</code>。</p>
<p>业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。</p>
<h3 id="shell-环境"><a class="markdownIt-Anchor" href="#shell-环境"></a> Shell 环境</h3>
<p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>Shell 的解释器种类众多，常见的有：</p>
<ul>
<li><a href="https://www.gnu.org/software/bash/">sh</a> - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。</li>
<li><a href="https://www.gnu.org/software/bash/">bash</a> - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。</li>
<li><a href="https://fishshell.com/">fish</a> - 智能和用户友好的命令行 shell。</li>
<li><a href="http://xiki.org/">xiki</a> - 使 shell 控制台更友好，更强大。</li>
<li><a href="http://www.zsh.org/">zsh</a> - 功能强大的 shell 与脚本语言。</li>
</ul>
<h4 id="指定脚本解释器"><a class="markdownIt-Anchor" href="#指定脚本解释器"></a> 指定脚本解释器</h4>
<p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang">shebang（也称为 Hashbang ）</a>。</p>
<p>所以，你应该会在 shell 中，见到诸如以下的注释：</p>
<ul>
<li>指定 sh 解释器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定 bash 解释器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>
<p>这样做的好处是，系统会自动在 <code>PATH</code> 环境变量中查找你指定的程序（本例中的<code>bash</code>）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的<code>PATH</code>变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的<code>bash</code>，我们可能将其路径添加到<code>PATH</code>中，来“隐藏”老版本。如果直接用<code>#!/bin/bash</code>，那么系统会选择老版本的<code>bash</code>来执行脚本，如果用<code>#!/usr/bin/env bash</code>，则会使用新版本。</p>
</blockquote>
<h3 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h3>
<p>shell 有交互和非交互两种模式。</p>
<h4 id="交互模式"><a class="markdownIt-Anchor" href="#交互模式"></a> 交互模式</h4>
<blockquote>
<p>简单来说，你可以将 shell 的交互模式理解为执行命令行。</p>
</blockquote>
<p>看到形如下面的东西，说明 shell 处于交互模式下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user@host:~$</span><br></pre></td></tr></table></figure>
<p>接着，便可以输入一系列 Linux 命令，比如 <code>ls</code>，<code>grep</code>，<code>cd</code>，<code>mkdir</code>，<code>rm</code> 等等。</p>
<h4 id="非交互模式"><a class="markdownIt-Anchor" href="#非交互模式"></a> 非交互模式</h4>
<blockquote>
<p>简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。</p>
</blockquote>
<p>在非交互模式下，shell 从文件或者管道中读取命令并执行。</p>
<p>当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。</p>
<p>可以使用下面的命令让 shell 以非交互模式运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /path/to/script.sh</span><br><span class="line">bash /path/to/script.sh</span><br><span class="line">source /path/to/script.sh</span><br><span class="line">./path/to/script.sh</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>script.sh</code>是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，<code>sh</code>和<code>bash</code>是 shell 解释器程序。你可以使用任何喜欢的编辑器创建<code>script.sh</code>（vim，nano，Sublime Text, Atom 等等）。</p>
<p>其中，<code>source /path/to/script.sh</code> 和 <code>./path/to/script.sh</code> 是等价的。</p>
<p>除此之外，你还可以通过<code>chmod</code>命令给文件添加可执行的权限，来直接执行脚本文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /path/to/script.sh #使脚本具有执行权限</span><br><span class="line">/path/to/test.sh</span><br></pre></td></tr></table></figure>
<p>这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如：</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line">echo &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们使用了一个很有用的命令<code>echo</code>来输出字符串到屏幕上。</p>
<h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2>
<h3 id="解释器"><a class="markdownIt-Anchor" href="#解释器"></a> 解释器</h3>
<p>前面虽然两次提到了<code>#!</code> ，但是本着重要的事情说三遍的精神，这里再强调一遍：</p>
<p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang">shebang（也称为 Hashbang ）</a>。</p>
<p><code>#!</code> 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入<code>sh</code>, <code>bash</code>, <code>python</code>, <code>php</code>等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure>
<h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3>
<p>注释可以说明你的代码是什么作用，以及为什么这样写。</p>
<p>shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。</p>
<ul>
<li>单行注释 - 以 <code>#</code> 开头，到行尾结束。</li>
<li>多行注释 - 以 <code>:&lt;&lt;EOF</code> 开头，到 <code>EOF</code> 结束。</li>
</ul>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">--------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell 注释示例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author：zp</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--------------------------------------------</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;这是单行注释&#x27;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######### 这是分割线 ##########</span></span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">echo &#x27;这是多行注释&#x27;</span><br><span class="line">echo &#x27;这是多行注释&#x27;</span><br><span class="line">echo &#x27;这是多行注释&#x27;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="echo"><a class="markdownIt-Anchor" href="#echo"></a> echo</h3>
<p>echo 用于字符串的输出。</p>
<p>输出普通字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello, world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: hello, world</span></span><br></pre></td></tr></table></figure>
<p>输出含变量的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;hello, \&quot;zp\&quot;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: hello, <span class="string">&quot;zp&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>输出含变量的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=zp</span><br><span class="line">echo &quot;hello, \&quot;$&#123;name&#125;\&quot;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: hello, <span class="string">&quot;zp&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>输出含换行符的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出含换行符的字符串</span></span><br><span class="line">echo &quot;YES\nNO&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output: YES\nNO</span></span><br><span class="line"></span><br><span class="line">echo -e &quot;YES\nNO&quot; # -e 开启转义</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  NO</span></span><br></pre></td></tr></table></figure>
<p>输出含不换行符的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;YES&quot;</span><br><span class="line">echo &quot;NO&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  NO</span></span><br><span class="line"></span><br><span class="line">echo -e &quot;YES\c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;NO&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  YESNO</span></span><br></pre></td></tr></table></figure>
<p>输出重定向至文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;test&quot; &gt; test.txt</span><br></pre></td></tr></table></figure>
<p>输出执行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo `pwd`</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:(当前目录路径)</span></span><br></pre></td></tr></table></figure>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出普通字符串</span></span><br><span class="line">echo &quot;hello, world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output: hello, world</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出含变量的字符串</span></span><br><span class="line">echo &quot;hello, \&quot;zp\&quot;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output: hello, <span class="string">&quot;zp&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出含变量的字符串</span></span><br><span class="line">name=zp</span><br><span class="line">echo &quot;hello, \&quot;$&#123;name&#125;\&quot;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output: hello, <span class="string">&quot;zp&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出含换行符的字符串</span></span><br><span class="line">echo &quot;YES\nNO&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output: YES\nNO</span></span><br><span class="line">echo -e &quot;YES\nNO&quot; # -e 开启转义</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  NO</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出含不换行符的字符串</span></span><br><span class="line">echo &quot;YES&quot;</span><br><span class="line">echo &quot;NO&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  YES</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  NO</span></span><br><span class="line"></span><br><span class="line">echo -e &quot;YES\c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;NO&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  YESNO</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出内容定向至文件</span></span><br><span class="line">echo &quot;test&quot; &gt; test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出执行结果</span></span><br><span class="line">echo `pwd`</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:(当前目录路径)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="printf"><a class="markdownIt-Anchor" href="#printf"></a> printf</h3>
<p>printf 用于格式化输出字符串。</p>
<p>默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 <code>\n</code>。</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单引号</span></span><br><span class="line">printf &#x27;%d %s\n&#x27; 1 &quot;abc&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:1 abc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 双引号</span></span><br><span class="line">printf &quot;%d %s\n&quot; 1 &quot;abc&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:1 abc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 无引号</span></span><br><span class="line">printf %s abcdef</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output: abcdef(并不会换行)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式只指定了一个参数，但多出的参数仍然会按照该格式输出</span></span><br><span class="line">printf &quot;%s\n&quot; abc def</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  abc</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  def</span></span><br><span class="line"></span><br><span class="line">printf &quot;%s %s %s\n&quot; a b c d e f g h i j</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  a b c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  d e f</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  g h i</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  j</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替</span></span><br><span class="line">printf &quot;%s and %d \n&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   and 0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式化输出</span></span><br><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  姓名     性别   体重kg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  郭靖     男      66.12</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  杨过     男      48.65</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  郭芙     女      47.99</span></span><br></pre></td></tr></table></figure>
<h4 id="printf-的转义符"><a class="markdownIt-Anchor" href="#printf-的转义符"></a> printf 的转义符</h4>
<table>
<thead>
<tr>
<th>序列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\a</code></td>
<td>警告字符，通常为 ASCII 的 BEL 字符</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>后退</td>
</tr>
<tr>
<td><code>\c</code></td>
<td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页（formfeed）</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车（Carriage return）</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>水平制表符</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表符</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>一个字面上的反斜杠字符</td>
</tr>
<tr>
<td><code>\ddd</code></td>
<td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td><code>\0ddd</code></td>
<td>表示 1 到 3 位的八进制值字符</td>
</tr>
</tbody>
</table>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<p>跟许多程序设计语言一样，你可以在 bash 中创建变量。</p>
<p>Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。</p>
<h3 id="变量命名原则"><a class="markdownIt-Anchor" href="#变量命名原则"></a> 变量命名原则</h3>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li>
</ul>
<h3 id="声明变量"><a class="markdownIt-Anchor" href="#声明变量"></a> 声明变量</h3>
<p>访问变量的语法形式为：<code>$&#123;var&#125;</code> 和 <code>$var</code> 。</p>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">word=&quot;hello&quot;</span><br><span class="line">echo $&#123;word&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: hello</span></span><br></pre></td></tr></table></figure>
<h3 id="只读变量"><a class="markdownIt-Anchor" href="#只读变量"></a> 只读变量</h3>
<p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rword=&quot;hello&quot;</span><br><span class="line">echo $&#123;rword&#125;</span><br><span class="line">readonly rword</span><br><span class="line"><span class="meta">#</span><span class="bash"> rword=<span class="string">&quot;bye&quot;</span>  <span class="comment"># 如果放开注释，执行时会报错</span></span></span><br></pre></td></tr></table></figure>
<h3 id="删除变量"><a class="markdownIt-Anchor" href="#删除变量"></a> 删除变量</h3>
<p>使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dword=&quot;hello&quot;  # 声明变量</span><br><span class="line">echo $&#123;dword&#125;  # 输出变量值</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: hello</span></span><br><span class="line"></span><br><span class="line">unset dword    # 删除变量</span><br><span class="line">echo $&#123;dword&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: （空）</span></span><br></pre></td></tr></table></figure>
<h3 id="变量类型"><a class="markdownIt-Anchor" href="#变量类型"></a> 变量类型</h3>
<ul>
<li><strong>局部变量</strong> - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。</li>
<li><strong>环境变量</strong> - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 <code>export</code> 关键字，shell 脚本也可以定义环境变量。</li>
</ul>
<p>常见的环境变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$HOME</code></td>
<td>当前用户的用户目录</td>
</tr>
<tr>
<td><code>$PATH</code></td>
<td>用分号分隔的目录列表，shell 会到这些目录中查找命令</td>
</tr>
<tr>
<td><code>$PWD</code></td>
<td>当前工作目录</td>
</tr>
<tr>
<td><code>$RANDOM</code></td>
<td>0 到 32767 之间的整数</td>
</tr>
<tr>
<td><code>$UID</code></td>
<td>数值类型，当前用户的用户 ID</td>
</tr>
<tr>
<td><code>$PS1</code></td>
<td>主要系统输入提示符</td>
</tr>
<tr>
<td><code>$PS2</code></td>
<td>次要系统输入提示符</td>
</tr>
</tbody>
</table>
<p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html###sect_03_02_04">这里</a> 有一张更全面的 Bash 环境变量列表。</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 声明变量 ###################</span></span></span><br><span class="line">name=&quot;world&quot;</span><br><span class="line">echo &quot;hello $&#123;name&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: hello world</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 输出变量 ###################</span></span></span><br><span class="line">folder=$(pwd)</span><br><span class="line">echo &quot;current path: $&#123;folder&#125;&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 只读变量 ###################</span></span></span><br><span class="line">rword=&quot;hello&quot;</span><br><span class="line">echo $&#123;rword&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: hello</span></span><br><span class="line">readonly rword</span><br><span class="line"><span class="meta">#</span><span class="bash"> rword=<span class="string">&quot;bye&quot;</span>  <span class="comment"># 如果放开注释，执行时会报错</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 删除变量 ###################</span></span></span><br><span class="line">dword=&quot;hello&quot; # 声明变量</span><br><span class="line">echo $&#123;dword&#125; # 输出变量值</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: hello</span></span><br><span class="line"></span><br><span class="line">unset dword # 删除变量</span><br><span class="line">echo $&#123;dword&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: （空）</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 系统变量 ###################</span></span></span><br><span class="line">echo &quot;UID:$UID&quot;</span><br><span class="line">echo LOGNAME:$LOGNAME</span><br><span class="line">echo User:$USER</span><br><span class="line">echo HOME:$HOME</span><br><span class="line">echo PATH:$PATH</span><br><span class="line">echo HOSTNAME:$HOSTNAME</span><br><span class="line">echo SHELL:$SHELL</span><br><span class="line">echo LANG:$LANG</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 自定义变量 ###################</span></span></span><br><span class="line">days=10</span><br><span class="line">user=&quot;admin&quot;</span><br><span class="line">echo &quot;$user logged in $days days age&quot;</span><br><span class="line">days=5</span><br><span class="line">user=&quot;root&quot;</span><br><span class="line">echo &quot;$user logged in $days days age&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> admin logged <span class="keyword">in</span> 10 days age</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> root logged <span class="keyword">in</span> 5 days age</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 从变量读取列表 ###################</span></span></span><br><span class="line">colors=&quot;Red Yellow Blue&quot;</span><br><span class="line">colors=$colors&quot; White Black&quot;</span><br><span class="line"></span><br><span class="line">for color in $colors</span><br><span class="line">do</span><br><span class="line">	echo &quot; $color&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2>
<h3 id="单引号和双引号"><a class="markdownIt-Anchor" href="#单引号和双引号"></a> 单引号和双引号</h3>
<p>shell 字符串可以用单引号 <code>''</code>，也可以用双引号 <code>“”</code>，也可以不用引号。</p>
<ul>
<li>单引号的特点
<ul>
<li>单引号里不识别变量</li>
<li>单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
</li>
<li>双引号的特点
<ul>
<li>双引号里识别变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
</li>
</ul>
<p>综上，推荐使用双引号。</p>
<h3 id="拼接字符串"><a class="markdownIt-Anchor" href="#拼接字符串"></a> 拼接字符串</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用单引号拼接</span></span><br><span class="line">name1=&#x27;white&#x27;</span><br><span class="line">str1=&#x27;hello, &#x27;$&#123;name1&#125;&#x27;&#x27;</span><br><span class="line">str2=&#x27;hello, $&#123;name1&#125;&#x27;</span><br><span class="line">echo $&#123;str1&#125;_$&#123;str2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hello, white_hello, <span class="variable">$&#123;name1&#125;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用双引号拼接</span></span><br><span class="line">name2=&quot;black&quot;</span><br><span class="line">str3=&quot;hello, &quot;$&#123;name2&#125;&quot;&quot;</span><br><span class="line">str4=&quot;hello, $&#123;name2&#125;&quot;</span><br><span class="line">echo $&#123;str3&#125;_$&#123;str4&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hello, black_hello, black</span></span><br></pre></td></tr></table></figure>
<h3 id="获取字符串长度"><a class="markdownIt-Anchor" href="#获取字符串长度"></a> 获取字符串长度</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">text=&quot;12345&quot;</span><br><span class="line">echo $&#123;#text&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5</span></span><br></pre></td></tr></table></figure>
<h3 id="截取子字符串"><a class="markdownIt-Anchor" href="#截取子字符串"></a> 截取子字符串</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">text=&quot;12345&quot;</span><br><span class="line">echo $&#123;text:2:2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 34</span></span><br></pre></td></tr></table></figure>
<p>从第 3 个字符开始，截取 2 个字符</p>
<h3 id="查找子字符串"><a class="markdownIt-Anchor" href="#查找子字符串"></a> 查找子字符串</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">text=&quot;hello&quot;</span><br><span class="line">echo `expr index &quot;$&#123;text&#125;&quot; ll`</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Execute: ./str-demo5.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3</span></span><br></pre></td></tr></table></figure>
<p>查找 <code>ll</code> 子字符在 <code>hello</code> 字符串中的起始位置。</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 使用单引号拼接字符串 ###################</span></span></span><br><span class="line">name1=&#x27;white&#x27;</span><br><span class="line">str1=&#x27;hello, &#x27;$&#123;name1&#125;&#x27;&#x27;</span><br><span class="line">str2=&#x27;hello, $&#123;name1&#125;&#x27;</span><br><span class="line">echo $&#123;str1&#125;_$&#123;str2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hello, white_hello, <span class="variable">$&#123;name1&#125;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 使用双引号拼接字符串 ###################</span></span></span><br><span class="line">name2=&quot;black&quot;</span><br><span class="line">str3=&quot;hello, &quot;$&#123;name2&#125;&quot;&quot;</span><br><span class="line">str4=&quot;hello, $&#123;name2&#125;&quot;</span><br><span class="line">echo $&#123;str3&#125;_$&#123;str4&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hello, black_hello, black</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 获取字符串长度 ###################</span></span></span><br><span class="line">text=&quot;12345&quot;</span><br><span class="line">echo &quot;$&#123;text&#125; length is: $&#123;#text&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 12345 length is: 5</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取子字符串</span></span><br><span class="line">text=&quot;12345&quot;</span><br><span class="line">echo $&#123;text:2:2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 34</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 查找子字符串 ###################</span></span></span><br><span class="line">text=&quot;hello&quot;</span><br><span class="line">echo `expr index &quot;$&#123;text&#125;&quot; ll`</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 判断字符串中是否包含子字符串 ###################</span></span></span><br><span class="line">result=$(echo &quot;$&#123;str&#125;&quot; | grep &quot;feature/&quot;)</span><br><span class="line">if [[ &quot;$result&quot; != &quot;&quot; ]]; then</span><br><span class="line">	echo &quot;feature/ 是 $&#123;str&#125; 的子字符串&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;feature/ 不是 $&#123;str&#125; 的子字符串&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 截取关键字左边内容 ###################</span></span></span><br><span class="line">full_branch=&quot;feature/1.0.0&quot;</span><br><span class="line">branch=`echo $&#123;full_branch#feature/&#125;`</span><br><span class="line">echo &quot;branch is $&#123;branch&#125;&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 截取关键字右边内容 ###################</span></span></span><br><span class="line">full_version=&quot;0.0.1-SNAPSHOT&quot;</span><br><span class="line">version=`echo $&#123;full_version%-SNAPSHOT&#125;`</span><br><span class="line">echo &quot;version is $&#123;version&#125;&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 字符串分割成数组 ###################</span></span></span><br><span class="line">str=&quot;0.0.0.1&quot;</span><br><span class="line">OLD_IFS=&quot;$IFS&quot;</span><br><span class="line">IFS=&quot;.&quot;</span><br><span class="line">array=( $&#123;str&#125; )</span><br><span class="line">IFS=&quot;$OLD_IFS&quot;</span><br><span class="line">size=$&#123;#array[*]&#125;</span><br><span class="line">lastIndex=`expr $&#123;size&#125; - 1`</span><br><span class="line">echo &quot;数组长度：$&#123;size&#125;&quot;</span><br><span class="line">echo &quot;最后一个数组元素：$&#123;array[$&#123;lastIndex&#125;]&#125;&quot;</span><br><span class="line">for item in $&#123;array[@]&#125;</span><br><span class="line">do</span><br><span class="line">	echo &quot;$item&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 判断字符串是否为空 ###################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-n 判断长度是否非零</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-z 判断长度是否为零</span></span><br><span class="line"></span><br><span class="line">str=testing</span><br><span class="line">str2=&#x27;&#x27;</span><br><span class="line">if [[ -n &quot;$str&quot; ]]</span><br><span class="line">then</span><br><span class="line">	echo &quot;The string $str is not empty&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;The string $str is empty&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -n &quot;$str2&quot; ]]</span><br><span class="line">then</span><br><span class="line">	echo &quot;The string $str2 is not empty&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;The string $str2 is empty&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">	Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	The string testing is not empty</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	The string  is empty</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 字符串比较 ###################</span></span></span><br><span class="line">str=hello</span><br><span class="line">str2=world</span><br><span class="line">if [[ $str = &quot;hello&quot; ]]; then</span><br><span class="line">	echo &quot;str equals hello&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;str not equals hello&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $str2 = &quot;hello&quot; ]]; then</span><br><span class="line">	echo &quot;str2 equals hello&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;str2 not equals hello&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<p>bash 只支持一维数组。</p>
<p>数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<h3 id="创建数组"><a class="markdownIt-Anchor" href="#创建数组"></a> 创建数组</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建数组的不同方式</span></span><br><span class="line">nums=([2]=2 [0]=0 [1]=1)</span><br><span class="line">colors=(red yellow &quot;dark blue&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="访问数组元素"><a class="markdownIt-Anchor" href="#访问数组元素"></a> 访问数组元素</h3>
<ul>
<li><strong>访问数组的单个元素：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;nums[1]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>访问数组的所有元素：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;colors[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line">echo $&#123;colors[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: red yellow dark blue</span></span><br></pre></td></tr></table></figure>
<p>上面两行有很重要（也很微妙）的区别：</p>
<p>为了将数组中每个元素单独一行输出，我们用 <code>printf</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &quot;+ %s\n&quot; $&#123;colors[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + red</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + yellow</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + dark</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + blue</span></span><br></pre></td></tr></table></figure>
<p>为什么<code>dark</code>和<code>blue</code>各占了一行？尝试用引号包起来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &quot;+ %s\n&quot; &quot;$&#123;colors[*]&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + red yellow dark blue</span></span><br></pre></td></tr></table></figure>
<p>现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试<code>$&#123;colors[@]&#125;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &quot;+ %s\n&quot; &quot;$&#123;colors[@]&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + red</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + yellow</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + dark blue</span></span><br></pre></td></tr></table></figure>
<p>在引号内，<code>$&#123;colors[@]&#125;</code>将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。</p>
<ul>
<li><strong>访问数组的部分元素：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;nums[@]:0:2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0 1</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>$&#123;array[@]&#125;</code> 扩展为整个数组，<code>:0:2</code>取出了数组中从 0 开始，长度为 2 的元素。</p>
<h3 id="访问数组长度"><a class="markdownIt-Anchor" href="#访问数组长度"></a> 访问数组长度</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;#nums[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3</span></span><br></pre></td></tr></table></figure>
<h3 id="向数组中添加元素"><a class="markdownIt-Anchor" href="#向数组中添加元素"></a> 向数组中添加元素</h3>
<p>向数组中添加元素也非常简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">colors=(white &quot;$&#123;colors[@]&#125;&quot; green black)</span><br><span class="line">echo $&#123;colors[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> white red yellow dark blue green black</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>$&#123;colors[@]&#125;</code> 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组<code>colors</code>的赋值覆盖了它原来的值。</p>
<h3 id="从数组中删除元素"><a class="markdownIt-Anchor" href="#从数组中删除元素"></a> 从数组中删除元素</h3>
<p>用<code>unset</code>命令来从数组中删除一个元素：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset nums[0]</span><br><span class="line">echo $&#123;nums[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 2</span></span><br></pre></td></tr></table></figure>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 创建数组 ###################</span></span></span><br><span class="line">nums=( [ 2 ] = 2 [ 0 ] = 0 [ 1 ] = 1 )</span><br><span class="line">colors=( red yellow &quot;dark blue&quot; )</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 访问数组的单个元素 ###################</span></span></span><br><span class="line">echo $&#123;nums[1]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: 1</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 访问数组的所有元素 ###################</span></span></span><br><span class="line">echo $&#123;colors[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line">echo $&#123;colors[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line">printf &quot;+ %s\n&quot; $&#123;colors[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + red</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + yellow</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + dark</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + blue</span></span><br><span class="line"></span><br><span class="line">printf &quot;+ %s\n&quot; &quot;$&#123;colors[*]&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + red yellow dark blue</span></span><br><span class="line"></span><br><span class="line">printf &quot;+ %s\n&quot; &quot;$&#123;colors[@]&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + red</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + yellow</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + dark blue</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 访问数组的部分元素 ###################</span></span></span><br><span class="line">echo $&#123;nums[@]:0:2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0 1</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 获取数组长度 ###################</span></span></span><br><span class="line">echo $&#123;#nums[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 向数组中添加元素 ###################</span></span></span><br><span class="line">colors=( white &quot;$&#123;colors[@]&#125;&quot; green black )</span><br><span class="line">echo $&#123;colors[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> white red yellow dark blue green black</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## 从数组中删除元素 ###################</span></span></span><br><span class="line">unset nums[ 0 ]</span><br><span class="line">echo $&#123;nums[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 2</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2>
<h3 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h3>
<p>下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td><code>expr $x + $y</code> 结果为 30。</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $x - $y</code> 结果为 -10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $x * $y</code> 结果为 200。</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $y / $x</code> 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $y % $x</code> 结果为 0。</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td><code>x=$y</code> 将把变量 y 的值赋给 x。</td>
</tr>
<tr>
<td>==</td>
<td>相等。用于比较两个数字，相同则返回 true。</td>
<td><code>[ $x == $y ]</code> 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>不相等。用于比较两个数字，不相同则返回 true。</td>
<td><code>[ $x != $y ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p>**注意：**条件表达式要放在方括号之间，并且要有空格，例如: <code>[$x==$y]</code> 是错误的，必须写成 <code>[ $x == $y ]</code>。</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line">echo &quot;x=$&#123;x&#125;, y=$&#123;y&#125;&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $&#123;x&#125; + $&#123;y&#125;`</span><br><span class="line">echo &quot;$&#123;x&#125; + $&#123;y&#125; = $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $&#123;x&#125; - $&#123;y&#125;`</span><br><span class="line">echo &quot;$&#123;x&#125; - $&#123;y&#125; = $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $&#123;x&#125; \* $&#123;y&#125;`</span><br><span class="line">echo &quot;$&#123;x&#125; * $&#123;y&#125; = $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $&#123;y&#125; / $&#123;x&#125;`</span><br><span class="line">echo &quot;$&#123;y&#125; / $&#123;x&#125; = $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $&#123;y&#125; % $&#123;x&#125;`</span><br><span class="line">echo &quot;$&#123;y&#125; % $&#123;x&#125; = $val&quot;</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; == $&#123;y&#125; ]]</span><br><span class="line">then</span><br><span class="line">  echo &quot;$&#123;x&#125; = $&#123;y&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ $&#123;x&#125; != $&#123;y&#125; ]]</span><br><span class="line">then</span><br><span class="line">  echo &quot;$&#123;x&#125; != $&#123;y&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  x=10, y=20</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 + 20 = 30</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 - 20 = -10</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 * 20 = 200</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  20 / 10 = 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  20 % 10 = 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 != 20</span></span><br></pre></td></tr></table></figure>
<h3 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h3>
<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-eq</code></td>
<td>检测两个数是否相等，相等返回 true。</td>
<td><code>[ $a -eq $b ]</code>返回 false。</td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>检测两个数是否相等，不相等返回 true。</td>
<td><code>[ $a -ne $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td><code>[ $a -gt $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td><code>[ $a -lt $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td><code>[ $a -ge $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-le</code></td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td><code>[ $a -le $b ]</code>返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line">echo &quot;x=$&#123;x&#125;, y=$&#123;y&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -eq $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; -eq $&#123;y&#125; : x 等于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; -eq $&#123;y&#125;: x 不等于 y&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -ne $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; -ne $&#123;y&#125;: x 不等于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; -ne $&#123;y&#125;: x 等于 y&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -gt $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; -gt $&#123;y&#125;: x 大于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; -gt $&#123;y&#125;: x 不大于 y&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -lt $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; -lt $&#123;y&#125;: x 小于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; -lt $&#123;y&#125;: x 不小于 y&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -ge $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; -ge $&#123;y&#125;: x 大于或等于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; -ge $&#123;y&#125;: x 小于 y&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -le $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; -le $&#123;y&#125;: x 小于或等于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; -le $&#123;y&#125;: x 大于 y&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  x=10, y=20</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 -eq 20: x 不等于 y</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 -ne 20: x 不等于 y</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 -gt 20: x 不大于 y</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 -lt 20: x 小于 y</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 -ge 20: x 小于 y</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 -le 20: x 小于或等于 y</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔运算符"><a class="markdownIt-Anchor" href="#布尔运算符"></a> 布尔运算符</h3>
<p>下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>!</code></td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td><code>[ ! false ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-o</code></td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td>
</tr>
</tbody>
</table>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line">echo &quot;x=$&#123;x&#125;, y=$&#123;y&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; != $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; != $&#123;y&#125; : x 不等于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; != $&#123;y&#125;: x 等于 y&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -lt 100 &amp;&amp; $&#123;y&#125; -gt 15 ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; 小于 100 且 $&#123;y&#125; 大于 15 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; 小于 100 且 $&#123;y&#125; 大于 15 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -lt 100 || $&#123;y&#125; -gt 100 ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; 小于 100 或 $&#123;y&#125; 大于 100 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; 小于 100 或 $&#123;y&#125; 大于 100 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -lt 5 || $&#123;y&#125; -gt 100 ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; 小于 5 或 $&#123;y&#125; 大于 100 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; 小于 5 或 $&#123;y&#125; 大于 100 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  x=10, y=20</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 != 20 : x 不等于 y</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 小于 100 且 20 大于 15 : 返回 <span class="literal">true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 小于 100 或 20 大于 100 : 返回 <span class="literal">true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 小于 5 或 20 大于 100 : 返回 <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h3>
<p>以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑的 AND</td>
<td><code>[[ $&#123;x&#125; -lt 100 &amp;&amp; $&#123;y&#125; -gt 100 ]]</code> 返回 false</td>
</tr>
<tr>
<td><code>||</code></td>
<td>逻辑的 OR</td>
<td><code>[[ $&#123;x&#125; -lt 100 || $&#123;y&#125; -gt 100 ]]</code> 返回 true</td>
</tr>
</tbody>
</table>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line">echo &quot;x=$&#123;x&#125;, y=$&#123;y&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -lt 100 &amp;&amp; $&#123;y&#125; -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$&#123;x&#125; -lt 100 &amp;&amp; $&#123;y&#125; -gt 100 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; -lt 100 &amp;&amp; $&#123;y&#125; -gt 100 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; -lt 100 || $&#123;y&#125; -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$&#123;x&#125; -lt 100 || $&#123;y&#125; -gt 100 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; -lt 100 || $&#123;y&#125; -gt 100 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  x=10, y=20</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 -lt 100 &amp;&amp; 20 -gt 100 返回 <span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  10 -lt 100 || 20 -gt 100 返回 <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>
<h3 id="字符串运算符"><a class="markdownIt-Anchor" href="#字符串运算符"></a> 字符串运算符</h3>
<p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td><code>[ $a = $b ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td><code>[ $a != $b ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>-z</code></td>
<td>检测字符串长度是否为 0，为 0 返回 true。</td>
<td><code>[ -z $a ]</code> 返回 false。</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>检测字符串长度是否为 0，不为 0 返回 true。</td>
<td><code>[ -n $a ]</code> 返回 true。</td>
</tr>
<tr>
<td><code>str</code></td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td><code>[ $a ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=&quot;abc&quot;</span><br><span class="line">y=&quot;xyz&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;x=$&#123;x&#125;, y=$&#123;y&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; = $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; = $&#123;y&#125; : x 等于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; = $&#123;y&#125;: x 不等于 y&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; != $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; != $&#123;y&#125; : x 不等于 y&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; != $&#123;y&#125;: x 等于 y&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -z $&#123;x&#125; ]]; then</span><br><span class="line">   echo &quot;-z $&#123;x&#125; : 字符串长度为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-z $&#123;x&#125; : 字符串长度不为 0&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -n &quot;$&#123;x&#125;&quot; ]]; then</span><br><span class="line">   echo &quot;-n $&#123;x&#125; : 字符串长度不为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-n $&#123;x&#125; : 字符串长度为 0&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;x&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; : 字符串不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; : 字符串为空&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  x=abc, y=xyz</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  abc = xyz: x 不等于 y</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  abc != xyz : x 不等于 y</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -z abc : 字符串长度不为 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -n abc : 字符串长度不为 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  abc : 字符串不为空</span></span><br></pre></td></tr></table></figure>
<h3 id="文件测试运算符"><a class="markdownIt-Anchor" href="#文件测试运算符"></a> 文件测试运算符</h3>
<p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b file</td>
<td>检测文件是否是块设备文件，如果是，则返回 true。</td>
<td><code>[ -b $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td><code>[ -c $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td><code>[ -d $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td><code>[ -f $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td><code>[ -g $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td><code>[ -k $file ]</code>返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是有名管道，如果是，则返回 true。</td>
<td><code>[ -p $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td><code>[ -u $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td><code>[ -r $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td><code>[ -w $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td><code>[ -x $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td>
<td><code>[ -s $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td><code>[ -e $file ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file=&quot;/etc/hosts&quot;</span><br><span class="line"></span><br><span class="line">if [[ -r $&#123;file&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件可读&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件不可读&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -w $&#123;file&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件可写&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件不可写&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -x $&#123;file&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件可执行&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件不可执行&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -f $&#123;file&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件为普通文件&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件为特殊文件&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -d $&#123;file&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件是个目录&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件不是个目录&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -s $&#123;file&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件为空&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -e $&#123;file&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件存在&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;file&#125; 文件不存在&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:(根据文件的实际情况，输出结果可能不同)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  /etc/hosts 文件可读</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  /etc/hosts 文件可写</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  /etc/hosts 文件不可执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  /etc/hosts 文件为普通文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  /etc/hosts 文件不是个目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  /etc/hosts 文件不为空</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  /etc/hosts 文件存在</span></span><br></pre></td></tr></table></figure>
<h2 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h2>
<h3 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> 条件语句</h3>
<p>跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在<code>[[ ]]</code>里的表达式。</p>
<p>由<code>[[ ]]</code>（<code>sh</code>中是<code>[ ]</code>）包起来的表达式被称作 <strong>检测命令</strong> 或 <strong>基元</strong>。这些表达式帮助我们检测一个条件的结果。这里可以找到有关<a href="http://serverfault.com/a/52050">bash 中单双中括号区别</a>的答案。</p>
<p>共有两个不同的条件表达式：<code>if</code>和<code>case</code>。</p>
<h4 id="if"><a class="markdownIt-Anchor" href="#if"></a> <code>if</code></h4>
<p>（1）<code>if</code> 语句</p>
<p><code>if</code>在使用上跟其它语言相同。如果中括号里的表达式为真，那么<code>then</code>和<code>fi</code>之间的代码会被执行。<code>fi</code>标志着条件代码块的结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 写成一行</span></span><br><span class="line">if [[ 1 -eq 1 ]]; then echo &quot;1 -eq 1 result is: true&quot;; fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: 1 -eq 1 result is: <span class="literal">true</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 写成多行</span></span><br><span class="line">if [[ &quot;abc&quot; -eq &quot;abc&quot; ]]</span><br><span class="line">then</span><br><span class="line">  echo &quot;&quot;abc&quot; -eq &quot;abc&quot; result is: true&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: abc -eq abc result is: <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>
<p>（2）<code>if else</code> 语句</p>
<p>同样，我们可以使用<code>if..else</code>语句，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[ 2 -ne 1 ]]; then</span><br><span class="line">  echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>
<p>（3）<code>if elif else</code> 语句</p>
<p>有些时候，<code>if..else</code>不能满足我们的要求。别忘了<code>if..elif..else</code>，使用起来也很方便。</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line">if [[ $&#123;x&#125; &gt; $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; &gt; $&#123;y&#125;&quot;</span><br><span class="line">elif [[ $&#123;x&#125; &lt; $&#123;y&#125; ]]; then</span><br><span class="line">   echo &quot;$&#123;x&#125; &lt; $&#123;y&#125;&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$&#123;x&#125; = $&#123;y&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: 10 &lt; 20</span></span><br></pre></td></tr></table></figure>
<h4 id="case"><a class="markdownIt-Anchor" href="#case"></a> <code>case</code></h4>
<p>如果你需要面对很多情况，分别要采取不同的措施，那么使用<code>case</code>会比嵌套的<code>if</code>更有用。使用<code>case</code>来解决复杂的条件判断，看起来像下面这样：</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec</span><br><span class="line">case $&#123;oper&#125; in</span><br><span class="line">  &quot;+&quot;)</span><br><span class="line">    val=`expr $&#123;x&#125; + $&#123;y&#125;`</span><br><span class="line">    echo &quot;$&#123;x&#125; + $&#123;y&#125; = $&#123;val&#125;&quot;</span><br><span class="line">  ;;</span><br><span class="line">  &quot;-&quot;)</span><br><span class="line">    val=`expr $&#123;x&#125; - $&#123;y&#125;`</span><br><span class="line">    echo &quot;$&#123;x&#125; - $&#123;y&#125; = $&#123;val&#125;&quot;</span><br><span class="line">  ;;</span><br><span class="line">  &quot;*&quot;)</span><br><span class="line">    val=`expr $&#123;x&#125; \* $&#123;y&#125;`</span><br><span class="line">    echo &quot;$&#123;x&#125; * $&#123;y&#125; = $&#123;val&#125;&quot;</span><br><span class="line">  ;;</span><br><span class="line">  &quot;/&quot;)</span><br><span class="line">    val=`expr $&#123;x&#125; / $&#123;y&#125;`</span><br><span class="line">    echo &quot;$&#123;x&#125; / $&#123;y&#125; = $&#123;val&#125;&quot;</span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    echo &quot;Unknown oper!&quot;</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>每种情况都是匹配了某个模式的表达式。<code>|</code>用来分割多个模式，<code>)</code>用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。<code>*</code>代表任何不匹配以上给定模式的模式。命令块儿之间要用<code>;;</code>分隔。</p>
<h3 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h3>
<p>循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。</p>
<p>Bash 中有四种循环：<code>for</code>，<code>while</code>，<code>until</code>和<code>select</code>。</p>
<h4 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> <code>for</code>循环</h4>
<p><code>for</code>与它在 C 语言中的姊妹非常像。看起来是这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for arg in elem1 elem2 ... elemN</span><br><span class="line">do</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">## 语句</span></span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>在每次循环的过程中，<code>arg</code>依次被赋值为从<code>elem1</code>到<code>elemN</code>。这些值还可以是通配符或者<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95">大括号扩展</a>。</p>
<p>当然，我们还可以把<code>for</code>循环写在一行，但这要求<code>do</code>之前要有一个分号，就像下面这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in &#123;1..5&#125;; do echo $i; done</span><br></pre></td></tr></table></figure>
<p>还有，如果你觉得<code>for..in..do</code>对你来说有点奇怪，那么你也可以像 C 语言那样使用<code>for</code>，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (( i = 0; i &lt; 10; i++ )); do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>当我们想对一个目录下的所有文件做同样的操作时，<code>for</code>就很方便了。举个例子，如果我们想把所有的<code>.bash</code>文件移动到<code>script</code>文件夹中，并给它们可执行权限，我们的脚本可以这样写：</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DIR=/home/zp</span><br><span class="line">for FILE in $&#123;DIR&#125;/*.sh; do</span><br><span class="line">  mv &quot;$FILE&quot; &quot;$&#123;DIR&#125;/scripts&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts</span></span><br></pre></td></tr></table></figure>
<h4 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> <code>while</code>循环</h4>
<p><code>while</code>循环检测一个条件，只要这个条件为 <em>真</em>，就执行一段命令。被检测的条件跟<code>if..then</code>中使用的<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%9F%BA%E5%85%83%E5%92%8C%E7%BB%84%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">基元</a>并无二异。因此一个<code>while</code>循环看起来会是这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [[ condition ]]</span><br><span class="line">do</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">## 语句</span></span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>跟<code>for</code>循环一样，如果我们把<code>do</code>和被检测的条件写到一行，那么必须要在<code>do</code>之前加一个分号。</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 0到9之间每个数的平方</span></span></span><br><span class="line">x=0</span><br><span class="line">while [[ $&#123;x&#125; -lt 10 ]]; do</span><br><span class="line">  echo $((x * x))</span><br><span class="line">  x=$((x + 1))</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  9</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  25</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  36</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  49</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  81</span></span><br></pre></td></tr></table></figure>
<h4 id="until循环"><a class="markdownIt-Anchor" href="#until循环"></a> <code>until</code>循环</h4>
<p><code>until</code>循环跟<code>while</code>循环正好相反。它跟<code>while</code>一样也需要检测一个测试条件，但不同的是，只要该条件为 <em>假</em> 就一直执行循环：</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=0</span><br><span class="line">until [[ $&#123;x&#125; -ge 5 ]]; do</span><br><span class="line">  echo $&#123;x&#125;</span><br><span class="line">  x=`expr $&#123;x&#125; + 1`</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  4</span></span><br></pre></td></tr></table></figure>
<h4 id="select循环"><a class="markdownIt-Anchor" href="#select循环"></a> <code>select</code>循环</h4>
<p><code>select</code>循环帮助我们组织一个用户菜单。它的语法几乎跟<code>for</code>循环一致：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select answer in elem1 elem2 ... elemN</span><br><span class="line">do</span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">## 语句</span></span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><code>select</code>会打印<code>elem1..elemN</code>以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是<code>$?</code>（<code>PS3</code>变量）。用户的选择结果会被保存到<code>answer</code>中。如果<code>answer</code>是一个在<code>1..N</code>之间的数字，那么<code>语句</code>会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用<code>break</code>语句。</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">PS3=&quot;Choose the package manager: &quot;</span><br><span class="line">select ITEM in bower npm gem pip</span><br><span class="line">do</span><br><span class="line">echo -n &quot;Enter the package name: &quot; &amp;&amp; read PACKAGE</span><br><span class="line">case $&#123;ITEM&#125; in</span><br><span class="line">  bower) bower install $&#123;PACKAGE&#125; ;;</span><br><span class="line">  npm) npm install $&#123;PACKAGE&#125; ;;</span><br><span class="line">  gem) gem install $&#123;PACKAGE&#125; ;;</span><br><span class="line">  pip) pip install $&#123;PACKAGE&#125; ;;</span><br><span class="line">esac</span><br><span class="line">break # 避免无限循环</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。</p>
<p>运行这个脚本，会得到如下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./my_script</span></span><br><span class="line">1) bower</span><br><span class="line">2) npm</span><br><span class="line">3) gem</span><br><span class="line">4) pip</span><br><span class="line">Choose the package manager: 2</span><br><span class="line">Enter the package name: gitbook-cli</span><br></pre></td></tr></table></figure>
<h4 id="break-和-continue"><a class="markdownIt-Anchor" href="#break-和-continue"></a> <code>break</code> 和 <code>continue</code></h4>
<p>如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的<code>break</code>和<code>continue</code>语句来实现。它们可以在任何循环中使用。</p>
<blockquote>
<p><code>break</code>语句用来提前结束当前循环。</p>
<p><code>continue</code>语句用来跳过某次迭代。</p>
</blockquote>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找 10 以内第一个能整除 2 和 3 的正整数</span></span><br><span class="line">i=1</span><br><span class="line">while [[ $&#123;i&#125; -lt 10 ]]; do</span><br><span class="line">  if [[ $((i % 3)) -eq 0 ]] &amp;&amp; [[ $((i % 2)) -eq 0 ]]; then</span><br><span class="line">    echo $&#123;i&#125;</span><br><span class="line">    break;</span><br><span class="line">  fi</span><br><span class="line">  i=`expr $&#123;i&#125; + 1`</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: 6</span></span><br></pre></td></tr></table></figure>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印10以内的奇数</span></span><br><span class="line">for (( i = 0; i &lt; 10; i ++ )); do</span><br><span class="line">  if [[ $((i % 2)) -eq 0 ]]; then</span><br><span class="line">    continue;</span><br><span class="line">  fi</span><br><span class="line">  echo $&#123;i&#125;</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  5</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  7</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  9</span></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<p>bash 函数定义语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ function ] funname [()] &#123;</span><br><span class="line">    action;</span><br><span class="line">    [return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>💡 说明：</p>
<ol>
<li>函数定义时，<code>function</code> 关键字可有可无。</li>
<li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。</li>
<li>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</li>
<li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li>
</ol>
</blockquote>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">calc()&#123;</span><br><span class="line">  PS3=&quot;choose the oper: &quot;</span><br><span class="line">  select oper in + - \* / # 生成操作符选择菜单</span><br><span class="line">  do</span><br><span class="line">  echo -n &quot;enter first num: &quot; &amp;&amp; read x # 读取输入参数</span><br><span class="line">  echo -n &quot;enter second num: &quot; &amp;&amp; read y # 读取输入参数</span><br><span class="line">  exec</span><br><span class="line">  case $&#123;oper&#125; in</span><br><span class="line">    &quot;+&quot;)</span><br><span class="line">      return $(($&#123;x&#125; + $&#123;y&#125;))</span><br><span class="line">    ;;</span><br><span class="line">    &quot;-&quot;)</span><br><span class="line">      return $(($&#123;x&#125; - $&#123;y&#125;))</span><br><span class="line">    ;;</span><br><span class="line">    &quot;*&quot;)</span><br><span class="line">      return $(($&#123;x&#125; * $&#123;y&#125;))</span><br><span class="line">    ;;</span><br><span class="line">    &quot;/&quot;)</span><br><span class="line">      return $(($&#123;x&#125; / $&#123;y&#125;))</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">      echo &quot;$&#123;oper&#125; is not support!&quot;</span><br><span class="line">      return 0</span><br><span class="line">    ;;</span><br><span class="line">  esac</span><br><span class="line">  break</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br><span class="line">calc</span><br><span class="line">echo &quot;the result is: $?&quot; # $? 获取 calc 函数返回值</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./function-demo.sh</span></span><br><span class="line">1) +</span><br><span class="line">2) -</span><br><span class="line">3) *</span><br><span class="line">4) /</span><br><span class="line">choose the oper: 3</span><br><span class="line">enter first num: 10</span><br><span class="line">enter second num: 10</span><br><span class="line">the result is: 100</span><br></pre></td></tr></table></figure>
<h3 id="位置参数"><a class="markdownIt-Anchor" href="#位置参数"></a> 位置参数</h3>
<p><strong>位置参数</strong>是在调用一个函数并传给它参数时创建的变量。</p>
<p>位置参数变量表：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$0</code></td>
<td>脚本名称</td>
</tr>
<tr>
<td><code>$1 … $9</code></td>
<td>第 1 个到第 9 个参数列表</td>
</tr>
<tr>
<td><code>$&#123;10&#125; … $&#123;N&#125;</code></td>
<td>第 10 个到 N 个参数列表</td>
</tr>
<tr>
<td><code>$*</code> or <code>$@</code></td>
<td>除了<code>$0</code>外的所有位置参数</td>
</tr>
<tr>
<td><code>$#</code></td>
<td>不包括<code>$0</code>在内的位置参数的个数</td>
</tr>
<tr>
<td><code>$FUNCNAME</code></td>
<td>函数名称（仅在函数内部有值）</td>
</tr>
</tbody>
</table>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">x=0</span><br><span class="line">if [[ -n $1 ]]; then</span><br><span class="line">  echo &quot;第一个参数为：$1&quot;</span><br><span class="line">  x=$1</span><br><span class="line">else</span><br><span class="line">  echo &quot;第一个参数为空&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">y=0</span><br><span class="line">if [[ -n $2 ]]; then</span><br><span class="line">  echo &quot;第二个参数为：$2&quot;</span><br><span class="line">  y=$2</span><br><span class="line">else</span><br><span class="line">  echo &quot;第二个参数为空&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">paramsFunction()&#123;</span><br><span class="line">  echo &quot;函数第一个入参：$1&quot;</span><br><span class="line">  echo &quot;函数第二个入参：$2&quot;</span><br><span class="line">&#125;</span><br><span class="line">paramsFunction $&#123;x&#125; $&#123;y&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./function-demo2.sh</span></span><br><span class="line">第一个参数为空</span><br><span class="line">第二个参数为空</span><br><span class="line">函数第一个入参：0</span><br><span class="line">函数第二个入参：0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./function-demo2.sh 10 20</span></span><br><span class="line">第一个参数为：10</span><br><span class="line">第二个参数为：20</span><br><span class="line">函数第一个入参：10</span><br><span class="line">函数第二个入参：20</span><br></pre></td></tr></table></figure>
<p>执行 <code>./variable-demo4.sh hello world</code> ，然后在脚本中通过 <code>$1</code>、<code>$2</code> … 读取第 1 个参数、第 2 个参数。。。</p>
<h3 id="函数处理参数"><a class="markdownIt-Anchor" href="#函数处理参数"></a> 函数处理参数</h3>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>返回参数个数</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>返回所有参数</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>脚本运行的当前进程 ID 号</td>
</tr>
<tr>
<td><code>$!</code></td>
<td>后台运行的最后一个进程的 ID 号</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>返回所有参数</td>
</tr>
<tr>
<td><code>$-</code></td>
<td>返回 Shell 使用的当前选项，与 set 命令功能相同。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>函数返回值</td>
</tr>
</tbody>
</table>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runner() &#123;</span><br><span class="line">  return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name=zp</span><br><span class="line">paramsFunction()&#123;</span><br><span class="line">  echo &quot;函数第一个入参：$1&quot;</span><br><span class="line">  echo &quot;函数第二个入参：$2&quot;</span><br><span class="line">  echo &quot;传递到脚本的参数个数：$#&quot;</span><br><span class="line">  echo &quot;所有参数：&quot;</span><br><span class="line">  printf &quot;+ %s\n&quot; &quot;$*&quot;</span><br><span class="line">  echo &quot;脚本运行的当前进程 ID 号：$$&quot;</span><br><span class="line">  echo &quot;后台运行的最后一个进程的 ID 号：$!&quot;</span><br><span class="line">  echo &quot;所有参数：&quot;</span><br><span class="line">  printf &quot;+ %s\n&quot; &quot;$@&quot;</span><br><span class="line">  echo &quot;Shell 使用的当前选项：$-&quot;</span><br><span class="line">  runner</span><br><span class="line">  echo &quot;runner 函数的返回值：$?&quot;</span><br><span class="line">&#125;</span><br><span class="line">paramsFunction 1 &quot;abc&quot; &quot;hello, \&quot;zp\&quot;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  函数第一个入参：1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  函数第二个入参：abc</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  传递到脚本的参数个数：3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  所有参数：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + 1 abc hello, <span class="string">&quot;zp&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  脚本运行的当前进程 ID 号：26400</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  后台运行的最后一个进程的 ID 号：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  所有参数：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + abc</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + hello, <span class="string">&quot;zp&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  Shell 使用的当前选项：hB</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  runner 函数的返回值：0</span></span><br></pre></td></tr></table></figure>
<h2 id="shell-扩展"><a class="markdownIt-Anchor" href="#shell-扩展"></a> Shell 扩展</h2>
<p><em>扩展</em> 发生在一行命令被分成一个个的 <em>记号（tokens）</em> 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。</p>
<p>感兴趣的话可以阅读<a href="https://www.gnu.org/software/bash/manual/bash.html###Shell-Expansions">关于 shell 扩展的更多细节</a>。</p>
<h4 id="大括号扩展"><a class="markdownIt-Anchor" href="#大括号扩展"></a> 大括号扩展</h4>
<p>大括号扩展让生成任意的字符串成为可能。它跟 <em>文件名扩展</em> 很类似，举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo beg&#123;i,a,u&#125;n ### begin began begun</span><br></pre></td></tr></table></figure>
<p>大括号扩展还可以用来创建一个可被循环迭代的区间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#123;0..5&#125; ### 0 1 2 3 4 5</span><br><span class="line">echo &#123;00..8..2&#125; ### 00 02 04 06 08</span><br></pre></td></tr></table></figure>
<h4 id="命令置换"><a class="markdownIt-Anchor" href="#命令置换"></a> 命令置换</h4>
<p>命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或<code>$()</code>包围时，命令置换将会执行。举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">now=`date +%T`</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## or</span></span></span><br><span class="line">now=$(date +%T)</span><br><span class="line"></span><br><span class="line">echo $now ### 19:08:26</span><br></pre></td></tr></table></figure>
<h4 id="算数扩展"><a class="markdownIt-Anchor" href="#算数扩展"></a> 算数扩展</h4>
<p>在 bash 中，执行算数运算是非常方便的。算数表达式必须包在<code>$(( ))</code>中。算数扩展的格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">result=$(( ((10 + 5*3) - 7) / 2 ))</span><br><span class="line">echo $result ### 9</span><br></pre></td></tr></table></figure>
<p>在算数表达式中，使用变量无需带上<code>$</code>前缀：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=4</span><br><span class="line">y=7</span><br><span class="line">echo $(( x + y ))     ### 11</span><br><span class="line">echo $(( ++x + y++ )) ### 12</span><br><span class="line">echo $(( x + y ))     ### 13</span><br></pre></td></tr></table></figure>
<h4 id="单引号和双引号-2"><a class="markdownIt-Anchor" href="#单引号和双引号-2"></a> 单引号和双引号</h4>
<p>单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;Your home: $HOME&quot; ### Your home: /Users/&lt;username&gt;</span><br><span class="line">echo &#x27;Your home: $HOME&#x27; ### Your home: $HOME</span><br></pre></td></tr></table></figure>
<p>当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用<code>echo</code>来输出用户的输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INPUT=&quot;A string  with   strange    whitespace.&quot;</span><br><span class="line">echo $INPUT   ### A string with strange whitespace.</span><br><span class="line">echo &quot;$INPUT&quot; ### A string  with   strange    whitespace.</span><br></pre></td></tr></table></figure>
<p>调用第一个<code>echo</code>时给了它 5 个单独的参数 —— <code>$INPUT</code> 被分成了单独的词，<code>echo</code>在每个词之间打印了一个空格。第二种情况，调用<code>echo</code>时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。</p>
<p>来看一个更严肃的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FILE=&quot;Favorite Things.txt&quot;</span><br><span class="line">cat $FILE   ### 尝试输出两个文件: `Favorite` 和 `Things.txt`</span><br><span class="line">cat &quot;$FILE&quot; ### 输出一个文件: `Favorite Things.txt`</span><br></pre></td></tr></table></figure>
<p>尽管这个问题可以通过把 FILE 重命名成<code>Favorite-Things.txt</code>来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（<code>find</code>, <code>cat</code>, 等等）呢。因此，如果输入 <em>可能</em> 包含空格，务必要用引号把表达式包起来。</p>
<h2 id="流和重定向"><a class="markdownIt-Anchor" href="#流和重定向"></a> 流和重定向</h2>
<p>Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。</p>
<p>管道给了我们创建传送带的机会，控制程序的执行成为可能。</p>
<p>学习如何使用这些强大的、高级的工具是非常非常重要的。</p>
<h3 id="输入-输出流"><a class="markdownIt-Anchor" href="#输入-输出流"></a> 输入、输出流</h3>
<p>Bash 接收输入，并以字符序列或 <strong>字符流</strong> 的形式产生输出。这些流能被重定向到文件或另一个流中。</p>
<p>有三个文件描述符：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>描述符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>stdin</code></td>
<td>标准输入</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>stdout</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>stderr</code></td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>
<h3 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h3>
<p>重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>重定向输出</td>
</tr>
<tr>
<td><code>&amp;&gt;</code></td>
<td>重定向输出和错误输出</td>
</tr>
<tr>
<td><code>&amp;&gt;&gt;</code></td>
<td>以附加的形式重定向输出和错误输出</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>重定向输入</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td><a href="http://tldp.org/LDP/abs/html/here-docs.html">Here 文档</a> 语法</td>
</tr>
<tr>
<td><code>&lt;&lt;&lt;</code></td>
<td><a href="http://www.tldp.org/LDP/abs/html/x17837.html">Here 字符串</a></td>
</tr>
</tbody>
</table>
<p>以下是一些使用重定向的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## ls的结果将会被写到list.txt中</span></span></span><br><span class="line">ls -l &gt; list.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 将输出附加到list.txt中</span></span></span><br><span class="line">ls -a &gt;&gt; list.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 所有的错误信息会被写到errors.txt中</span></span></span><br><span class="line">grep da * 2&gt; errors.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 从errors.txt中读取输入</span></span></span><br><span class="line">less &lt; errors.txt</span><br></pre></td></tr></table></figure>
<h3 id="devnull-文件"><a class="markdownIt-Anchor" href="#devnull-文件"></a> <code>/dev/null</code> 文件</h3>
<p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; /dev/null</span></span><br></pre></td></tr></table></figure>
<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>
<h2 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> Debug</h2>
<p>shell 提供了用于 debug 脚本的工具。</p>
<p>如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash options</span></span><br></pre></td></tr></table></figure>
<p>options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：</p>
<table>
<thead>
<tr>
<th>Short</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-f</code></td>
<td>noglob</td>
<td>禁止文件名展开（globbing）</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>interactive</td>
<td>让脚本以 <em>交互</em> 模式运行</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>noexec</td>
<td>读取命令，但不执行（语法检查）</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>—</td>
<td>执行完第一条命令后退出</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>verbose</td>
<td>在执行每条命令前，向<code>stderr</code>输出该命令</td>
</tr>
<tr>
<td><code>-x</code></td>
<td>xtrace</td>
<td>在执行每条命令前，向<code>stderr</code>输出该命令以及该命令的扩展参数</td>
</tr>
</tbody>
</table>
<p>举个例子，如果我们在脚本中指定了<code>-x</code>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash -x</span></span><br><span class="line"></span><br><span class="line">for (( i = 0; i &lt; 3; i++ )); do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>这会向<code>stdout</code>打印出变量的值和一些其它有用的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./my_script</span></span><br><span class="line">+ (( i = 0 ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ echo 0</span><br><span class="line">0</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ echo 1</span><br><span class="line">1</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br><span class="line">+ echo 2</span><br><span class="line">2</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; 3 ))</span><br></pre></td></tr></table></figure>
<p>有时我们值需要 debug 脚本的一部分。这种情况下，使用<code>set</code>命令会很方便。这个命令可以启用或禁用选项。使用<code>-</code>启用选项，<code>+</code>禁用选项：</p>
<p><strong>💻 『示例源码』</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启 debug</span></span><br><span class="line">set -x</span><br><span class="line">for (( i = 0; i &lt; 3; i++ )); do</span><br><span class="line">  printf $&#123;i&#125;</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭 debug</span></span><br><span class="line">set +x</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + (( i = 0 ))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + <span class="built_in">printf</span> 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  0+ (( i++  ))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + <span class="built_in">printf</span> 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  1+ (( i++  ))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + <span class="built_in">printf</span> 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  2+ (( i++  ))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  + <span class="built_in">set</span> +x</span></span><br><span class="line"></span><br><span class="line">for i in &#123;1..5&#125;; do printf $&#123;i&#125;; done</span><br><span class="line">printf &quot;\n&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">  Output: 12345</span></span><br></pre></td></tr></table></figure>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li><a href="https://github.com/alebcay/awesome-shell">awesome-shell</a> - shell 资源列表</li>
<li><a href="https://github.com/awesome-lists/awesome-bash">awesome-bash</a> - bash 资源列表</li>
<li><a href="https://github.com/denysdovhan/bash-handbook">bash-handbook</a></li>
<li><a href="https://github.com/vuuihc/bash-guide">bash-guide</a>  - bash 基本用法指南</li>
<li><a href="https://github.com/Bash-it/bash-it">bash-it</a> - 为你日常使用、开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架</li>
<li><a href="http://dotfiles.github.io/">dotfiles.github.io</a> - 上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接</li>
<li><a href="http://www.runoob.com/linux/linux-shell.html">Runoob Shell 教程</a></li>
<li><a href="https://github.com/koalaman/shellcheck">shellcheck</a> - 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
</ul>
<p>最后，Stack Overflow 上 <a href="https://stackoverflow.com/questions/tagged/bash">bash 标签下</a>有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 ICMP</title>
    <url>/network/icmp/</url>
    <content><![CDATA[<h1 id="网络协议之-icmp"><a class="markdownIt-Anchor" href="#网络协议之-icmp"></a> 网络协议之 ICMP</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#icmp-%E7%AE%80%E4%BB%8B">ICMP 简介</a></li>
<li><a href="#icmp-%E7%B1%BB%E5%9E%8B">ICMP 类型</a></li>
<li><a href="#%E7%9B%AE%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%BE%BEdestination-unreachable-message">目的不可达(Destination Unreachable Message)</a></li>
<li><a href="#%E8%B6%85%E6%97%B6time-exceeded-message">超时(Time Exceeded Message)</a></li>
<li><a href="#%E5%8F%82%E6%95%B0%E9%94%99%E8%AF%AF%E6%8A%A5%E6%96%87parameter-problem-message">参数错误报文(Parameter Problem Message)</a></li>
<li><a href="#%E6%BA%90%E5%86%B7%E5%8D%B4source-quench-message">源冷却(Source Quench Message)</a></li>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91redirect-message">重定向(Redirect Message)</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E5%9B%9E%E6%98%BE%E6%88%96%E5%9B%9E%E6%98%BE%E5%BA%94%E7%AD%94echo-or-echo-reply-message">请求回显或回显应答(Echo or Echo Reply Message)</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E6%88%B3%E6%88%96%E6%97%B6%E9%97%B4%E6%88%B3%E8%AF%B7%E6%B1%82timestamp-or-timestamp-reply-message">时间戳或时间戳请求(Timestamp or Timestamp Reply Message)</a></li>
<li><a href="#%E4%BF%A1%E6%81%AF%E8%AF%B7%E6%B1%82%E6%88%96%E4%BF%A1%E6%81%AF%E5%93%8D%E5%BA%94">信息请求或信息响应</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<!-- /TOC -->
<h2 id="icmp-简介"><a class="markdownIt-Anchor" href="#icmp-简介"></a> ICMP 简介</h2>
<p>ICMP 全名为(INTERNET CONTROL MESSAGE PROTOCOL)网络控制消息协议。</p>
<p>ICMP 的协议号为<strong>1</strong>。</p>
<p>ICMP 报文就像是 IP 报文的小弟，总顶着 IP 报文的名头出来混。因为 ICMP 报文是在 IP 报文内部的，如图：</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/318837/201606/318837-20160617091834260-1410966672.png"/></div>
<h2 id="icmp-类型"><a class="markdownIt-Anchor" href="#icmp-类型"></a> ICMP 类型</h2>
<p>ICMP 报文主要有两大功能：查询报文和差错报文。</p>
<h2 id="目的不可达destination-unreachable-message"><a class="markdownIt-Anchor" href="#目的不可达destination-unreachable-message"></a> 目的不可达(Destination Unreachable Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| unused |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>日常生活中，邮寄包裹会经过多个传递环节，任意一环如果无法传下去，都会返回寄件人，并附上无法邮寄的原因。同理，当路由器收到一个无法传递下去的 IP 报文时，会发送 ICMP<strong>目的不可达报文</strong>（Type 为 3）给 IP 报文的源发送方。报文中的 Code 就表示发送失败的原因。</p>
<p>Code</p>
<p>0 = net unreachable;</p>
<p>1 = host unreachable;</p>
<p>2 = protocol unreachable;</p>
<p>3 = port unreachable;</p>
<p>4 = fragmentation needed and DF set;</p>
<p>5 = source route failed.</p>
<h2 id="超时time-exceeded-message"><a class="markdownIt-Anchor" href="#超时time-exceeded-message"></a> 超时(Time Exceeded Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| unused |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>网络传输 IP 数据报的过程中，如果 IP 数据包的 TTL 值逐渐递减为 0 时，需要丢弃数据报。这时，路由器需要向源发送方发送 <strong>ICMP 超时报文</strong>(Type 为 11)，Code 为 0，表示传输过程中超时了。</p>
<p>一个 IP 数据报可能会因为过大而被分片，然后在目的主机侧把所有的分片重组。如果主机迟迟没有等到所有的分片报文，就会向源发送方发送一个 ICMP 超时报文，Code 为 1，表示分片重组超时了。</p>
<h2 id="参数错误报文parameter-problem-message"><a class="markdownIt-Anchor" href="#参数错误报文parameter-problem-message"></a> 参数错误报文(Parameter Problem Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Pointer | unused |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>当路由器或主机处理数据报时，发现因为报文头的参数错误而不得不丢弃报文时，需要向源发送方发送<strong>参数错误报文</strong>(Type 为 12)。当 Code 为 0 时，报文中的 Pointer 表示错误的字节位置。</p>
<h2 id="源冷却source-quench-message"><a class="markdownIt-Anchor" href="#源冷却source-quench-message"></a> 源冷却(Source Quench Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| unused |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>路由器在处理报文时会有一个缓存队列。如果超过最大缓存队列，将无法处理，从而丢弃报文。并向源发送方发一个 <strong>ICMP 源冷却报文</strong>(Type 为 4)，告诉对方：“嘿，我这里客满了，你迟点再来。”</p>
<h2 id="重定向redirect-message"><a class="markdownIt-Anchor" href="#重定向redirect-message"></a> 重定向(Redirect Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Gateway Internet Address |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Internet Header + 64 bits of Original Data Datagram |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>想像一下，在公司中，有人来你的项目组问你某某某在哪儿。你一想，我们组没有这人啊。你肯定就会说，我们组没有这号人，你去其他组看看。当路由收到 IP 数据报，发现数据报的目的地址在路由表上没有，它就会发 <strong>ICMP 重定向报文</strong>(Type 为 5)给源发送方，提醒它想要发送的地址不在，去其他地方找找吧。</p>
<h2 id="请求回显或回显应答echo-or-echo-reply-message"><a class="markdownIt-Anchor" href="#请求回显或回显应答echo-or-echo-reply-message"></a> 请求回显或回显应答(Echo or Echo Reply Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Identifier | Sequence Number |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Data …</p>
<p>±±±±±</p>
<p><strong>Type(8)<strong>是</strong>请求回显报文(Echo)</strong>；Type(0)是<strong>回显应答报文(Echo Reply)</strong>。</p>
<p>请求回显或回显应答报文属于查询报文。Ping 就是用这种报文进行查询和回应。</p>
<h2 id="时间戳或时间戳请求timestamp-or-timestamp-reply-message"><a class="markdownIt-Anchor" href="#时间戳或时间戳请求timestamp-or-timestamp-reply-message"></a> 时间戳或时间戳请求(Timestamp or Timestamp Reply Message)</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Identifier | Sequence Number |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Originate Timestamp |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Receive Timestamp |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Transmit Timestamp |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>时间戳报文是用来记录收发以及传输时间的报文。Originate Timestamp 记录的是发送方发送报文的时刻；<strong>Receive Timestamp</strong>记录的是接收方收到报文的时刻；<strong>Transmit Timestamp</strong>表示回显这最后发送报文的时刻。</p>
<h2 id="信息请求或信息响应"><a class="markdownIt-Anchor" href="#信息请求或信息响应"></a> 信息请求或信息响应</h2>
<p>0 1 2 3</p>
<p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Type | Code | Checksum |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>| Identifier | Sequence Number |</p>
<p>±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±+</p>
<p>这种报文是用来找出一个主机所在的网络个数（一个主机可能会在多个网络中）。报文的 IP 消息头的目的地址会填为全 0，表示 this，源地址会填为源 IP 所在的网络 IP。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p><strong>图：ICMP 知识点思维导图</strong></p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/318837/201606/318837-20160617091835838-1982473379.png"/></div>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li><a href="http://www.rfc-editor.org/info/rfc792">RFC792</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 HTTP</title>
    <url>/network/http/</url>
    <content><![CDATA[<h1 id="网络通信之-http"><a class="markdownIt-Anchor" href="#网络通信之-http"></a> 网络通信之 HTTP</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p>**超文本传输协议（HTTP）**是一个用于传输超媒体文档（例如 HTML）的<a href="https://en.wikipedia.org/wiki/Application_Layer">应用层</a>协议。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#http-%E7%AE%80%E4%BB%8B">HTTP 简介</a>
<ul>
<li><a href="#http-%E6%98%AF%E4%BB%80%E4%B9%88">HTTP 是什么</a></li>
<li><a href="#http-%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9">HTTP 协议特点</a></li>
<li><a href="#http-%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7">HTTP 版本特性</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a>
<ul>
<li><a href="#http-%E4%BC%98%E5%8C%96">HTTP 优化</a></li>
</ul>
</li>
<li><a href="#http-%E6%8A%A5%E6%96%87">HTTP 报文</a>
<ul>
<li><a href="#http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">HTTP 请求报文</a></li>
<li><a href="#http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">HTTP 响应报文</a></li>
</ul>
</li>
<li><a href="#https">HTTPS</a></li>
<li><a href="#cookie-%E5%92%8C-session">Cookie 和 Session</a>
<ul>
<li><a href="#cookie">Cookie</a></li>
<li><a href="#session">Session</a></li>
<li><a href="#cookie-vs-session">Cookie vs. Session</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<!-- TOC depthFrom:2 depthTo:2 -->
<ul>
<li><a href="#http-%E7%AE%80%E4%BB%8B">HTTP 简介</a></li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a></li>
<li><a href="#http-%E6%8A%A5%E6%96%87">HTTP 报文</a></li>
<li><a href="#https">HTTPS</a></li>
<li><a href="#cookie-%E5%92%8C-session">Cookie 和 Session</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="http-简介"><a class="markdownIt-Anchor" href="#http-简介"></a> HTTP 简介</h2>
<h3 id="http-是什么"><a class="markdownIt-Anchor" href="#http-是什么"></a> HTTP 是什么</h3>
<p>**超文本传输协议（HTTP）**是一个用于传输超媒体文档（例如 HTML）的<a href="https://en.wikipedia.org/wiki/Application_Layer">应用层</a>协议。HTTP 是 浏览器与服务器之间的数据传送协议。HTTP 遵循经典的<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">客户端-服务端模型</a>，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是<a href="http://en.wikipedia.org/wiki/Stateless_protocol">无状态协议</a>，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。</p>
<p>HTTP 是由 <strong>IETF</strong>(Internet Engineering Task Force，互联网工程工作小组) 和 <strong>W3C</strong>(World Wide Web Consortium，万维网协会) 共同合作制订的，它们发布了一系列的<strong>RFC</strong>(Request For Comments)，其中最著名的是 RFC 2616，它定义了<strong>HTTP /1.1</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200119131949.png" alt="img" /></p>
<h3 id="http-协议特点"><a class="markdownIt-Anchor" href="#http-协议特点"></a> HTTP 协议特点</h3>
<ul>
<li><strong>无连接的</strong> - 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li><strong>无状态的</strong> - HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
<li><strong>媒体独立的</strong> - 这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。</li>
<li><strong>C/S 模型的</strong> - 基于 Client/Server 模型工作。</li>
</ul>
<h3 id="http-版本特性"><a class="markdownIt-Anchor" href="#http-版本特性"></a> HTTP 版本特性</h3>
<h4 id="http-11"><a class="markdownIt-Anchor" href="#http-11"></a> HTTP 1.1</h4>
<p>HTTP1.0 和 HTTP 1.1 主要区别如下：</p>
<ul>
<li><strong>缓存处理</strong>，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong></li>
<li><strong>错误通知的管理</strong> - HTTP1.1 中新增了 24 个错误状态响应码。</li>
<li><strong>Host 头处理</strong>
<ul>
<li>HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。</li>
<li>随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li>
</ul>
</li>
<li><strong>长连接</strong>，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</li>
</ul>
<h4 id="http-20"><a class="markdownIt-Anchor" href="#http-20"></a> HTTP 2.0</h4>
<p>HTTP/2 在 HTTP/1.1 有几处基本的不同:</p>
<ul>
<li>HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li>
<li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。</li>
<li>压缩了 headers。因为 headers 在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li>
<li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li>
</ul>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<p>HTTP 工作于 <strong>Client/Server</strong> 模型上。</p>
<p>客户端和服务器之间的通信采用 <strong>request/response</strong> 机制。</p>
<p>客户端是终端（可以是浏览器、爬虫程序等），服务器是网站的 Web 服务器。</p>
<p>一次 HTTP 操作称为一个事务，其工作过程大致可分为四步：</p>
<ol>
<li><strong>建立连接</strong> - 首先，客户端和服务器需要建立一个到服务器指定端口（默认端口号为 <strong>80</strong>）的 TCP 连接（注：虽然 HTTP 采用 TCP 连接是最流行的方式，但是 RFC 并没有指定一定要采用这种网络传输方式。）。</li>
<li><strong>发送请求信息</strong> - 客户端向服务器发送请求。请求方式的格式为，统一资源标识符、协议版本号，后边是 MIME 信息包括请求修饰符</li>
<li><strong>发送响应信息</strong> - 服务器监听指定接口是否收到请求，一旦发现请求，处理后，返回响应结果给客户端。其格式为一个状态行包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</li>
<li><strong>关闭连接</strong> - 客户端根据响应，显示结果给用户，最后关闭连接。</li>
</ol>
<h3 id="http-优化"><a class="markdownIt-Anchor" href="#http-优化"></a> HTTP 优化</h3>
<p>影响一个 HTTP 网络请求的因素主要有两个：<strong>带宽和延迟。</strong></p>
<ul>
<li>
<p>**带宽：**如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p>
</li>
<li>
<p><strong>延迟：</strong></p>
</li>
<li>
<ul>
<li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li>
<li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用 DNS 缓存结果来达到减少这个时间的目的。</li>
<li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li>
</ul>
</li>
</ul>
<h2 id="http-报文"><a class="markdownIt-Anchor" href="#http-报文"></a> HTTP 报文</h2>
<p>HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p>
<p>一个 HTTP&quot;客户端&quot;是一个应用程序（Web 浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个 HTTP 的请求的目的。</p>
<p>一个 HTTP&quot;服务器&quot;同样也是一个应用程序（通常是一个 Web 服务，如 Apache Web 服务器或 IIS 服务器等），通过接收客户端的请求并向客户端发送 HTTP 响应数据。</p>
<p>HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<p>一旦建立连接后，数据消息就通过类似 Internet 邮件所使用的格式[RFC5322]和多用途 Internet 邮件扩展（MIME）[RFC2045]来传送。</p>
<div align="center"><img src="https://images2015.cnblogs.com/blog/318837/201601/318837-20160108221141668-2097587842.png"/></div>
以下是使用 wireshark 抓取的一个实际访问百度首页的 HTTP GET 报文：
<div align="center"><img src="http://images2015.cnblogs.com/blog/318837/201601/318837-20160108221137996-786139964.png"/></div>
可以清楚的看到它的层级结构如下图，经过了层层的包装。
<div align="center"><img src="https://images2015.cnblogs.com/blog/318837/201601/318837-20160108221140731-222242798.png"/></div>
### HTTP 请求报文
<p>客户端发送一个 HTTP 请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200119132129.png" alt="img" /></p>
<p>HTTP 请求报文由以下元素组成：</p>
<ul>
<li>一个 HTTP 的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">method</a>，经常是由一个动词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 或者一个名词像<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a>来定义客户端的动作行为。通常客户端的操作都是获取资源（GET 方法）或者发送<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms">HTML form</a>表单值（POST 方法），虽然在一些情况下也会有其他操作。</li>
<li>要获取的资源的路径，通常是上下文中就很明显的元素资源的 URL，它没有<a href="https://developer.mozilla.org/en-US/docs/Glossary/protocol">protocol</a> （<code>http://</code>），<a href="https://developer.mozilla.org/en-US/docs/Glossary/domain">domain</a>（<code>developer.mozilla.org</code>），或是 TCP 的<a href="https://developer.mozilla.org/en-US/docs/Glossary/port">port</a>（HTTP 一般在 80 端口）。</li>
<li>HTTP 协议版本号。</li>
<li>为服务端表达其他信息的可选头部<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">headers</a>。</li>
<li>对于一些像 POST 这样的方法，报文的 body 就包含了发送的资源，这与响应报文的 body 类似。</li>
</ul>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p><strong>HTTP1.0</strong> 定义了三种请求方法： <strong>GET</strong>, <strong>POST</strong> 和 <strong>HEAD</strong>方法。</p>
<p><strong>HTTP1.1</strong> 新增了五种请求方法：<strong>OPTIONS</strong>, <strong>PUT</strong>, <strong>DELETE</strong>, <strong>TRACE</strong> 和 <strong>CONNECT</strong>方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
</tbody>
</table>
<p><strong>HTTP</strong> <strong>请求消息头</strong></p>
<table>
<thead>
<tr>
<th><strong>请求消息头</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>浏览器支持的格式</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>支持的编码格式，如（UTF-8，GBK）</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>支持的语言类型</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器信息</td>
</tr>
<tr>
<td>Cookie</td>
<td>记录的是用户当前的状态</td>
</tr>
<tr>
<td>Referer</td>
<td>指从哪个页面单击链接进入的页面</td>
</tr>
<tr>
<td>HOST</td>
<td>目的地址对应的主机名</td>
</tr>
<tr>
<td>Connection</td>
<td>连接类型。如 Keep-Alive 表示长连接，不会断开</td>
</tr>
<tr>
<td>Content-Length</td>
<td>内容长度</td>
</tr>
<tr>
<td>Content-Type</td>
<td>内容类型</td>
</tr>
</tbody>
</table>
<h3 id="http-响应报文"><a class="markdownIt-Anchor" href="#http-响应报文"></a> HTTP 响应报文</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200119132311.png" alt="img" /></p>
<p>HTTP 响应报文包含了下面的元素：</p>
<ul>
<li>HTTP 协议版本号。</li>
<li>一个状态码（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">status code</a>），来告知对应请求执行成功或失败，以及失败的原因。</li>
<li>一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</li>
<li>HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">headers</a>，与请求头部类似。</li>
<li>可选项，比起请求报文，响应报文中更常见地包含获取的资源 body。</li>
</ul>
<h4 id="响应消息头"><a class="markdownIt-Anchor" href="#响应消息头"></a> 响应消息头</h4>
<table>
<thead>
<tr>
<th><strong>响应消息头</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>服务器支持哪些请求方法（如 GET、POST 等）。</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>文档的编码（Encode）方法。只有在解码之后才可以得到 Content-Type 头指定的内容类型。利用 gzip 压缩文档能够显著地减少 HTML 文档的下载时间。Java 的 GZIPOutputStream 可以很方便地进行 gzip 压缩，但只有 Unix 上的 Netscape 和 Windows 上的 IE 4、IE 5 才支持它。因此，Servlet 应该通过查看 Accept-Encoding 头（即 request.getHeader(“Accept-Encoding”)）检查浏览器是否支持 gzip，为支持 gzip 的浏览器返回经 gzip 压缩的 HTML 页面，为其他浏览器返回普通页面。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>表示内容长度。只有当浏览器使用持久 HTTP 连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入 Content-Length 头，最后通过<code>byteArrayStream.writeTo(response.getOutputStream()</code> 发送内容。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>表示后面的文档属于什么 MIME 类型。Servlet 默认为 <code>text/plain</code>，但通常需要显式地指定为 text/html。由于经常要设置 Content-Type，因此 HttpServletResponse 提供了一个专用的方法 setContentType。</td>
</tr>
<tr>
<td>Date</td>
<td>当前的 GMT 时间。你可以用 setDateHeader 来设置这个头以避免转换时间格式的麻烦。</td>
</tr>
<tr>
<td>Expires</td>
<td>应该在什么时候认为文档已经过期，从而不再缓存它？</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>文档的最后改动时间。客户可以通过 If-Modified-Since 请求头提供一个日期，该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个 304（Not Modified）状态。Last-Modified 也可用 setDateHeader 方法来设置。</td>
</tr>
<tr>
<td>Location</td>
<td>表示客户应当到哪里去提取文档。Location 通常不是直接设置的，而是通过 HttpServletResponse 的 sendRedirect 方法，该方法同时设置状态代码为 302。</td>
</tr>
<tr>
<td>Refresh</td>
<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过 <code>response.setHeader(&quot;Refresh&quot;, &quot;5;URL=http://host/path&quot;)</code>让浏览器读取指定的页面。 注意这种功能通常是通过设置 HTML 页面 HEAD 区的 <code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;</code>实现，这是因为，自动刷新或重定向对于那些不能使用 CGI 或 Servlet 的 HTML 编写者十分重要。但是，对于 Servlet 来说，直接设置 Refresh 头更加方便。 注意 Refresh 的意义是&quot;N 秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔 N 秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个 Refresh 头，而发送 204 状态代码则可以阻止浏览器继续刷新，不管是使用 Refresh 头还是 <code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; ...&gt;</code>。 注意 Refresh 头不属于 HTTP 1.1 正式规范的一部分，而是一个扩展，但 Netscape 和 IE 都支持它。</td>
</tr>
<tr>
<td>Server</td>
<td>服务器名字。Servlet 一般不设置这个值，而是由 Web 服务器自己设置。</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置和页面关联的 Cookie。Servlet 不应使用<code>response.setHeader(&quot;Set-Cookie&quot;, ...)</code>，而是应使用 HttpServletResponse 提供的专用方法 addCookie。参见下文有关 Cookie 设置的讨论。</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>客户应该在 Authorization 头中提供什么类型的授权信息？在包含 401（Unauthorized）状态行的应答中这个头是必需的。例如，<code>response.setHeader(&quot;WWW-Authenticate&quot;, &quot;BASIC realm=＼&quot;executives＼&quot;&quot;)</code>。 注意 Servlet 一般不进行这方面的处理，而是让 Web 服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>
</tr>
</tbody>
</table>
<h4 id="http-响应状态码"><a class="markdownIt-Anchor" href="#http-响应状态码"></a> HTTP 响应状态码</h4>
<p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP 状态码的英文为 <strong><code>HTTP Status Code</code></strong>。</p>
<p>下面是常见的 HTTP 状态码：</p>
<ul>
<li><strong>200</strong> - 请求成功</li>
<li><strong>301</strong> - 资源（网页等）被永久转移到其它 URL</li>
<li><strong>404</strong> - 请求的资源（网页等）不存在</li>
<li><strong>500</strong> - 内部服务器错误</li>
</ul>
<p>HTTP 状态码分类</p>
<p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>分类描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td><strong>信息响应</strong>。服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2xx</td>
<td><strong>成功响应</strong>。操作被成功接收并处理</td>
</tr>
<tr>
<td>3xx</td>
<td><strong>重定向</strong>。需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td><strong>客户端错误</strong>。请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5xx</td>
<td><strong>服务器错误</strong>。服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🔔 更详细的 HTTP 状态码可以参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">MDN HTTP 响应代码</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">Wiki List of HTTP status codes</a></li>
</ul>
</blockquote>
<h2 id="https"><a class="markdownIt-Anchor" href="#https"></a> HTTPS</h2>
<p>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</p>
<p>HTTP 的端口号是 80，HTTPS 是 443</p>
<p>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费</p>
<p>HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p>
<h2 id="cookie-和-session"><a class="markdownIt-Anchor" href="#cookie-和-session"></a> Cookie 和 Session</h2>
<blockquote>
<p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。</p>
<p>会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p>
</blockquote>
<h3 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h3>
<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器，并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless">无状态</a>的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h4 id="cookie-工作步骤"><a class="markdownIt-Anchor" href="#cookie-工作步骤"></a> Cookie 工作步骤</h4>
<ol>
<li>客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。</li>
<li>客户端浏览器会把 Cookie 保存下来。</li>
<li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li>
</ol>
<p><em><strong>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。</strong></em></p>
<p>Java 中把 Cookie 封装成了 <code>javax.servlet.http.Cookie</code> 类。</p>
<h4 id="cookie-和-http-报文"><a class="markdownIt-Anchor" href="#cookie-和-http-报文"></a> Cookie 和 Http 报文</h4>
<p><code>Cookies</code> 通常设置在 HTTP 头信息中（虽然 JavaScript 也可以直接在浏览器上设置一个 Cookie）。</p>
<p>设置 Cookie 的 Servlet 会发送如下的头信息：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Fri, <span class="number">04</span> Feb <span class="number">2000</span> <span class="number">21</span>:<span class="number">03</span>:<span class="number">38</span> GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/<span class="number">1</span>.<span class="number">3</span>.<span class="number">9</span> (UNIX) PHP/<span class="number">4</span>.<span class="number">0</span>b<span class="number">3</span></span><br><span class="line"><span class="attribute">Set</span>-Cookie: name=xyz; expires=Friday, <span class="number">04</span>-Feb-<span class="number">07</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">38</span> GMT;</span><br><span class="line">                 <span class="attribute">path</span>=/; domain=w<span class="number">3</span>cschool.cc</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Content</span>-Type: text/html</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，<code>Set-Cookie</code> 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。<code>expires</code> 字段是一个指令，告诉浏览器在给定的时间和日期之后&quot;忘记&quot;该 Cookie。</p>
<p>如果浏览器被配置为存储 Cookies，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器。浏览器的头信息可能如下所示：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>zink.demon.co.uk:1126</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>image/gif, */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>iso-8859-1,*,utf-8</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>name=xyz</span><br></pre></td></tr></table></figure>
<h3 id="session"><a class="markdownIt-Anchor" href="#session"></a> Session</h3>
<p>不同于 <strong>Cookie 保存在客户端浏览器中</strong>，<strong>Session 保存在服务器上</strong>。</p>
<p>由于 Cookie 以明文的方式存储在本地，而 Cookie 中往往带有用户信息，这样就造成了非常大的安全隐患。</p>
<p>Session 的出现解决了这个问题，<strong>Session 可以理解为服务器端开辟的存储空间，里面保存了用户的状态</strong>，用户信息以 Session 的形式存储在服务端。当用户请求到来时，服务端可以把用户的请求和用户的 Session 对应起来。那么 Session 是怎么和请求对应起来的呢？答案是通过 Cookie，浏览器在 Cookie 中填充了一个 Session ID 之类的字段用来标识请求。</p>
<h4 id="session-工作流程"><a class="markdownIt-Anchor" href="#session-工作流程"></a> Session 工作流程</h4>
<p>Session 工作流程是这样的：</p>
<p>服务器在创建 Session 的同时，会为该 Session 生成唯一的 Session ID，当浏览器再次发送请求的时候，会将这个 Session ID 带上，服务器接受到请求之后就会依据 Session ID 找到相应的 Session，找到 Session 后，就可以在 Session 中获取或者添加内容了。而这些内容只会保存在服务器中，发到客户端的只有 Session ID，这样相对安全，也节省了网络流量，因为不需要在 Cookie 中存储大量用户信息。该 Cookie 为服务器自动生成的，它的 <code>maxAge</code> 属性一般为-1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。</p>
<h4 id="session-创建与存储"><a class="markdownIt-Anchor" href="#session-创建与存储"></a> Session 创建与存储</h4>
<p>那么 Session 在何时何地创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同的创建 Session 的方法。Tomcat 的 Session 管理器提供了多种持久化方案来存储 Session，通常会采用高性能的存储方式，比如 Redis，并且通过集群部署的方式，防止单点故障，从而提升高可用。同时，Session 有过期时间，因此 Tomcat 会开启后台线程定期的轮询，如果 Session 过期了就将 Session 失效。</p>
<h3 id="cookie-vs-session"><a class="markdownIt-Anchor" href="#cookie-vs-session"></a> Cookie vs. Session</h3>
<p>Cookie vs. Session 对比如下：</p>
<ul>
<li><strong>存储位置</strong>
<ul>
<li>Cookie 存储在浏览器。
<ul>
<li>不占用服务器资源。</li>
<li>一些客户端的程序可能会窥探、复制或修改 Cookie 内容，安全风险更大。</li>
</ul>
</li>
<li>Session 存储在服务器。
<ul>
<li>每个用户都会产生一个 Session，如果并发访问的用户非常多，会产生很多的 Session，消耗大量的内存。</li>
<li>对客户端是透明的，不存在敏感信息泄露的危险。</li>
</ul>
</li>
</ul>
</li>
<li><strong>存取方式</strong>
<ul>
<li>Cookie 只能保存 <code>ASCII</code> 字符串，如果需要存取 <code>Unicode</code> 字符或二进制数据，需要进行<code>UTF-8</code>、<code>GBK</code>或<code>BASE64</code>等方式的编码。</li>
<li>Session 可以存取任何类型的数据，甚至是任何 Java 类。可以将 Session 看成是一个 Java 容器类。</li>
</ul>
</li>
<li><strong>有效期</strong>
<ul>
<li>使用 Cookie 可以保证长时间登录有效，只要设置 Cookie 的 <code>maxAge</code> 属性为一个很大的数字。</li>
<li>而 Session 虽然理论上也可以通过设置很大的数值来保持长时间登录有效，但是，由于 Session 依赖于名为 <code>JESSIONID</code> 的 Cookie，而 Cookie <code>JESSIONID</code>的 <code>maxAge</code> 默认为-1，只要关闭了浏览器该 Session 就会失效，因此，Session 不能实现信息永久有效的效果。使用 URL 地址重写也不能实现。</li>
</ul>
</li>
<li><strong>浏览器的支持</strong>
<ul>
<li>浏览器如果禁用 Cookie，则 Cookie 不能使用。</li>
<li>浏览器如果禁用 Cookie，需要使用 Session 以及 URL 地址重写。需要注意的是：所有的用到 Session 程序的 URL 都要使用<code>response.encodeURL(StringURL)</code> 或<code>response.encodeRediretURL(String URL)</code>进行 URL 地址重写，否则导致 Session 会话跟踪失效。</li>
</ul>
</li>
<li><strong>跨域名</strong>
<ul>
<li>Cookie 支持跨域名。</li>
<li>Session 不支持跨域名。</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/25863515/">《图解 HTTP》</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">MDN HTTP 教程</a></li>
<li><a href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
<li><a href="https://juejin.im/entry/5981c5df518825359a2b9476">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li>
<li><a href="http://blog.csdn.net/gueter/article/details/1524447">http://blog.csdn.net/gueter/article/details/1524447</a></li>
<li><a href="http://www.runoob.com/http/http-intro.html">http://www.runoob.com/http/http-intro.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之应用层</title>
    <url>/network/network-application/</url>
    <content><![CDATA[<h1 id="计算机网络之应用层"><a class="markdownIt-Anchor" href="#计算机网络之应用层"></a> 计算机网络之应用层</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#http">HTTP</a></li>
<li><a href="#dns">DNS</a></li>
<li><a href="#ftp">FTP</a></li>
<li><a href="#dhcp">DHCP</a></li>
<li><a href="#telnet">TELNET</a></li>
<li><a href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE">电子邮件协议</a>
<ul>
<li><a href="#1-smtp">1. SMTP</a></li>
<li><a href="#2-pop3">2. POP3</a></li>
<li><a href="#3-imap">3. IMAP</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3">常用端口</a></li>
<li><a href="#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">Web 页面请求过程</a>
<ul>
<li><a href="#1-dhcp-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF">1. DHCP 配置主机信息</a></li>
<li><a href="#2-arp-%E8%A7%A3%E6%9E%90-mac-%E5%9C%B0%E5%9D%80">2. ARP 解析 MAC 地址</a></li>
<li><a href="#3-dns-%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D">3. DNS 解析域名</a></li>
<li><a href="#4-http-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2">4. HTTP 请求页面</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551096916007.png"/></div>
<p>超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p>
<p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>
<p>安全套接字层超文本传输协议 HTTPS 为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<blockquote>
<p>👉 扩展阅读：<a href="HTTP.md">HTTP</a></p>
</blockquote>
<h2 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h2>
<p>域名服务器 DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551094759786.png"/></div>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551094954067.png"/></div>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<blockquote>
<p>👉 扩展阅读：<a href="DNS.md">DNS</a></p>
</blockquote>
<h2 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> FTP</h2>
<p>文件传送协议 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ul>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551095440002.png"/></div>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<p>FTPS 是一种对常用的文件传输协议（FTP）添加传输层安全（TLS）和安全套接层（SSL）加密协议支持的扩展协议。</p>
<h2 id="dhcp"><a class="markdownIt-Anchor" href="#dhcp"></a> DHCP</h2>
<p>动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551095610521.png"/></div>
<h2 id="telnet"><a class="markdownIt-Anchor" href="#telnet"></a> TELNET</h2>
<p>远程登录协议 TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h2 id="电子邮件协议"><a class="markdownIt-Anchor" href="#电子邮件协议"></a> 电子邮件协议</h2>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<h3 id="1-smtp"><a class="markdownIt-Anchor" href="#1-smtp"></a> 1. SMTP</h3>
<p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<h3 id="2-pop3"><a class="markdownIt-Anchor" href="#2-pop3"></a> 2. POP3</h3>
<p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p>
<h3 id="3-imap"><a class="markdownIt-Anchor" href="#3-imap"></a> 3. IMAP</h3>
<p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h2 id="常用端口"><a class="markdownIt-Anchor" href="#常用端口"></a> 常用端口</h2>
<table>
<thead>
<tr>
<th style="text-align:center">应用</th>
<th style="text-align:center">应用层协议</th>
<th style="text-align:center">端口号</th>
<th style="text-align:center">传输层协议</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">域名解析</td>
<td style="text-align:center">DNS</td>
<td style="text-align:center">53</td>
<td style="text-align:center">UDP/TCP</td>
<td style="text-align:center">长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td style="text-align:center">动态主机配置协议</td>
<td style="text-align:center">DHCP</td>
<td style="text-align:center">67/68</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">简单网络管理协议</td>
<td style="text-align:center">SNMP</td>
<td style="text-align:center">161/162</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">文件传送协议</td>
<td style="text-align:center">FTP</td>
<td style="text-align:center">20/21</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center">控制连接 21，数据连接 20</td>
</tr>
<tr>
<td style="text-align:center">远程终端协议</td>
<td style="text-align:center">TELNET</td>
<td style="text-align:center">23</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">超文本传送协议</td>
<td style="text-align:center">HTTP</td>
<td style="text-align:center">80</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">简单邮件传送协议</td>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">25</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">邮件读取协议</td>
<td style="text-align:center">POP3</td>
<td style="text-align:center">110</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">网际报文存取协议</td>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">143</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="web-页面请求过程"><a class="markdownIt-Anchor" href="#web-页面请求过程"></a> Web 页面请求过程</h2>
<h3 id="1-dhcp-配置主机信息"><a class="markdownIt-Anchor" href="#1-dhcp-配置主机信息"></a> 1. DHCP 配置主机信息</h3>
<ul>
<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li>
<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>
<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>
<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li>
<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>
<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>
<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>
</ul>
<h3 id="2-arp-解析-mac-地址"><a class="markdownIt-Anchor" href="#2-arp-解析-mac-地址"></a> 2. ARP 解析 MAC 地址</h3>
<ul>
<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>
<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>
<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>
<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>
<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>
<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>
<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>
</ul>
<h3 id="3-dns-解析域名"><a class="markdownIt-Anchor" href="#3-dns-解析域名"></a> 3. DNS 解析域名</h3>
<ul>
<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>
<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>
<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>
<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>
<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>
</ul>
<h3 id="4-http-请求页面"><a class="markdownIt-Anchor" href="#4-http-请求页面"></a> 4. HTTP 请求页面</h3>
<ul>
<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之数据链路层</title>
    <url>/network/network-data-link/</url>
    <content><![CDATA[<h1 id="计算机网络之数据链路层"><a class="markdownIt-Anchor" href="#计算机网络之数据链路层"></a> 计算机网络之数据链路层</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p><strong>数据链路层（Data Link Layer）</strong> - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<ul>
<li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li>
<li>数据单元：帧（frame）。</li>
<li>典型设备：二层交换机、网桥、网卡。</li>
</ul>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">基本问题</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">封装成帧</a></li>
<li><a href="#%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">透明传输</a></li>
<li><a href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">差错检测</a></li>
</ul>
</li>
<li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">点对点信道</a>
<ul>
<li><a href="#ppp-%E5%8D%8F%E8%AE%AE">PPP 协议</a></li>
</ul>
</li>
<li><a href="#%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">广播信道</a>
<ul>
<li><a href="#csmacd-%E5%8D%8F%E8%AE%AE">CSMA/CD 协议</a></li>
</ul>
</li>
<li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a></li>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a></li>
<li><a href="#mac-%E5%9C%B0%E5%9D%80">MAC 地址</a></li>
<li><a href="#%E8%AE%BE%E5%A4%87">设备</a>
<ul>
<li><a href="#%E9%80%82%E9%85%8D%E5%99%A8">适配器</a></li>
<li><a href="#%E9%9B%86%E7%BA%BF%E5%99%A8">集线器</a></li>
<li><a href="#%E7%BD%91%E6%A1%A5">网桥</a></li>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA">以太网交换机</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<ul>
<li>链路是从一个节点到相邻节点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（网络适配器）和软件（协议）。</li>
<li>数据链路层三个基本问题：封装成帧、透明传输、差错检测。</li>
<li>数据链路层有两种信道类型：点对点信道（主要使用 <code>PPP</code>）和广播信道（主要使用 <code>CSMA/CD</code>）。</li>
<li>以太网 MAC 层的地址。</li>
<li>适配器、转发器、集线器、网桥、以太网交换机的作用及使用场合。</li>
</ul>
<h2 id="基本问题"><a class="markdownIt-Anchor" href="#基本问题"></a> 基本问题</h2>
<h3 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h3>
<p>为网络层传下来的 IP 数据报添加首部和尾部，用于标记帧的开始和结束。</p>
<p>为了提高传输效率，应该让数据部分长度尽可能大于首部和尾部。但是，每种链路层协议都限制了帧的数据部分长度上线——最大传送单元 MTU（Maximum Transfer Unit）</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/数据链路帧.png"/></div>
<h3 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h3>
<p><strong>透明</strong>表示：某一个实际存在的事物看起来好像不存在一样。</p>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/经过字节填充后发送的数据.png"/></div>
<h3 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h3>
<p>目前数据链路层广泛使用了<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C"><strong>循环冗余检验 CRC（Cyclic redundancy check）</strong></a>来检查比特差错。</p>
<h2 id="点对点信道"><a class="markdownIt-Anchor" href="#点对点信道"></a> 点对点信道</h2>
<p>点对点信道使用一对一的点对点通信方式。</p>
<p>对于点对点的链路，点对点协议 PPP（Point-to-Point Protocol）是使用最广泛的数据链路层协议。</p>
<h3 id="ppp-协议"><a class="markdownIt-Anchor" href="#ppp-协议"></a> PPP 协议</h3>
<p>互联网用户通常都要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/PPP协议.png"/></div>
<p>PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/PPP帧.png"/></div>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<h2 id="广播信道"><a class="markdownIt-Anchor" href="#广播信道"></a> 广播信道</h2>
<p>广播信道(broadcast channel)是通过广播的方式传输信息的信息通道。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>
<h3 id="csmacd-协议"><a class="markdownIt-Anchor" href="#csmacd-协议"></a> CSMA/CD 协议</h3>
<p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）即带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</li>
<li><strong>碰撞检测</strong> ：即边发送边检测。若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。计算退避等待时间采用的是<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95">二进制指数退避算法</a>。</li>
</ul>
<h2 id="局域网"><a class="markdownIt-Anchor" href="#局域网"></a> 局域网</h2>
<p>局域网 LAN（Local Area Network）是指在某一区域内由多台计算机互联成的计算机组。</p>
<p>局域网的拓扑结构通常为总线型和环型。</p>
<p>局域网技术主要有：以太网、令牌环网、FDDI 网和无线局域网等。</p>
<h2 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h2>
<p>以太网（Ethernet）是一种星型拓扑结构局域网。</p>
<p>以太网是目前应用最广泛的局域网。</p>
<p>以太网使用 CSMA/CD 协议。</p>
<h2 id="mac-地址"><a class="markdownIt-Anchor" href="#mac-地址"></a> MAC 地址</h2>
<p>MAC 地址（Media Access Control Address），也称为以太网地址或物理地址，它是一个用来确认网上设备位置的地址。</p>
<p>MAC 地址长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/MAC帧.png"/></div>
<h2 id="设备"><a class="markdownIt-Anchor" href="#设备"></a> 设备</h2>
<h3 id="适配器"><a class="markdownIt-Anchor" href="#适配器"></a> 适配器</h3>
<p>网络适配器一般指网卡。</p>
<p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p>
<p>网卡和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而网卡和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行。</p>
<h3 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器</h3>
<p>集线器（Hub）的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</p>
<p>使用集线器可以在物理层扩展以太网。</p>
<h3 id="网桥"><a class="markdownIt-Anchor" href="#网桥"></a> 网桥</h3>
<p>网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。</p>
<h3 id="以太网交换机"><a class="markdownIt-Anchor" href="#以太网交换机"></a> 以太网交换机</h3>
<p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p>
<ul>
<li>以太网交换机的每个端口都直接与主机相连，并且一般都工作在全双工方式。</li>
<li>交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</li>
<li>用户独占传输媒体的带宽，若一个接口到主机的带宽是 10Mbit 每秒，那么有 10 个接口的交换机的总容量是 100Mbit 每秒。这是交换机的最大优点。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络指南</title>
    <url>/network/network-guide/</url>
    <content><![CDATA[<h1 id="计算机网络指南"><a class="markdownIt-Anchor" href="#计算机网络指南"></a> 计算机网络指南</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
</blockquote>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network.jpg"/></div>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%F0%9F%92%A1-%E6%8C%87%E5%8D%97">💡 指南</a>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">核心概念</a></li>
<li><a href="#%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84">拓扑结构</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4">作用范围</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">性能指标</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82">网络分层</a>
<ul>
<li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a></li>
<li>[~<sub>会话层~</sub>](#\会话层)</li>
<li>[~<sub>表示层~</sub>](#\表示层)</li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a></li>
</ul>
</li>
<li><a href="#%E8%B5%84%E6%BA%90">资源</a></li>
<li><a href="#door-%E4%BC%A0%E9%80%81%E9%97%A8">🚪 传送门</a></li>
</ul>
<!-- /TOC -->
<h2 id="指南"><a class="markdownIt-Anchor" href="#指南"></a> 💡 指南</h2>
<p>学习之前，先看一下入门三问：</p>
<blockquote>
<p><strong>一、什么是计算机网络？</strong></p>
<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<p>——摘自百度百科</p>
</blockquote>
<blockquote>
<p><strong>二、为什么学习计算机网络？</strong></p>
<p>计算机网络是计算机科学的基础课程，也是计算机专业考研必考科目，可见其重要性。作为一名程序员，了解计算机网络，对于 Web 领域，通信领域的开发有莫大的帮助。</p>
<p>在浏览器中访问网页的原理是什么？Wifi 是如何工作的？防火墙是如何保障网络安全的？什么是安全证书？Cookie 和 Session 是什么东西？。。。</p>
<p>如果你接触过这些技术，如果你想了解这些技术的原理，那么你就有必要学习一下计算机网络了。</p>
</blockquote>
<blockquote>
<p><strong>三、如何学习计算机网络？</strong></p>
<p>本人有 2 年通信领域开发经验，从事通信设备上的协议开发。就我个人的学习经验来看，学习计算机网络可以分为以下阶段：</p>
<ul>
<li><strong>基础阶段——一般性的了解网络协议分层及各层功能</strong>
<ul>
<li>了解计算机网络协议分层（OSI）有哪些层，分层的依据是什么（即每层的功能是什么）</li>
<li>了解每层的主要通信设备有哪些；</li>
<li>了解每层有哪些重要网络协议，这些协议有什么作用，基本原理是什么？</li>
<li>了解每层的传输数据形式（如：报文、帧等）</li>
</ul>
</li>
<li><strong>进阶阶段——系统学习计算机网络知识，将各层主要协议功能串联起来</strong>
<ul>
<li>学习 TCP/IP 详解 卷 1、卷 2、卷 3（内容详实，但文字较为晦涩，不适合初学者）</li>
</ul>
</li>
<li><strong>专业阶段——根据业务领域，有针对性的学习</strong>
<ul>
<li>网络协议很多，而且专业性非常强。精通所有协议，几乎是不可能的，所以有必要根据自己的业务领域，有针对性的深入学习协议。如果你是做 web 开发，那么你很有必要认真学习一下 HTTP、DNS 协议；如果你是做路由器、交换机领域通信开发，那么你应该更深入学习一下 IP/TCP/UDP 协议。。。</li>
<li>如何深入学习协议，最好的学习方式，就是深入学习 RFC，并结合实际的协议报文去了解。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h3>
<ul>
<li><strong>计算机网络</strong> - 计算机网络（computer network），通常也简称网络，是利用通信设备和线路将地理位置不同的、功能独立的多个<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E8%A8%88%E7%AE%97%E6%A9%9F">计算机</a>系统连接起来，以功能完善的网络<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>实现网络的<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6">硬件</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6">软件</a>及资源<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB">共享</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF">信息</a>传递的系统。简单的说即连接两台或多台计算机进行<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1">通信</a>的系统。</li>
<li><strong>互联网</strong> - 互联网（Internet），即网络的网络。</li>
</ul>
<h3 id="拓扑结构"><a class="markdownIt-Anchor" href="#拓扑结构"></a> 拓扑结构</h3>
<p>计算机网络的拓扑结构可分为：</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/network-topological-structure.gif!zp"/></div>
<ul>
<li>网型拓扑网型网（Mesh network）</li>
<li>环型拓扑环型网（Ring network）</li>
<li>星型拓扑星型网（Star network）</li>
<li>树状拓扑树型网（Tree network）</li>
<li>总线拓扑总线网（Bus network）</li>
</ul>
<h3 id="作用范围"><a class="markdownIt-Anchor" href="#作用范围"></a> 作用范围</h3>
<ul>
<li>广域网 WAN（Wide Area Network）</li>
<li>城域网 MAN（Metropolitan Area Network）</li>
<li>局域网 LAN（Local Area Network）</li>
<li>个人区域网 PAN（Personal Area Network）</li>
</ul>
<h3 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h3>
<ul>
<li><strong>速率</strong> - 速率的单位是 bit/s（比特每秒）。</li>
<li><strong>带宽（bandwidth）</strong> - 带宽有以下两种不同的意义。
<ul>
<li>信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫 （或千赫，兆赫，吉赫等）。</li>
<li>网络的带宽表示在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>。这种意义的带宽的单位是 bit/s（比特每秒）。</li>
</ul>
</li>
<li><strong>吞吐量（throughput）</strong> - 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。例如，对于一个 100 Mbit/s 的以太网，其额定速率是 100 Mbit/s。</li>
<li><strong>时延（delay）</strong>
<ul>
<li>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</li>
</ul>
</li>
</ul>
<h2 id="网络分层"><a class="markdownIt-Anchor" href="#网络分层"></a> 网络分层</h2>
<blockquote>
<p>计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p>
<p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p>
</blockquote>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/network-layers.png"/></div>
<p>计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。</p>
<ul>
<li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li>
<li>五层协议分层是一种折中方案，在现实中更为流行。</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/网络分层架构图.png"/></div>
<h3 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h3>
<blockquote>
<p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p>
<p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p>
</blockquote>
<ul>
<li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li>
<li>数据单元：比特流。</li>
<li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li>
</ul>
<h3 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h3>
<blockquote>
<p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p>
</blockquote>
<ul>
<li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li>
<li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li>
<li>数据单元：帧（frame）。</li>
<li>典型设备：二层交换机、网桥、网卡。</li>
</ul>
<h3 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h3>
<blockquote>
<p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li>
<li>主要协议：<code>IP</code>。</li>
<li>数据单元：IP 数据报（packet）。</li>
<li>典型设备：网关、路由器。</li>
</ul>
<h3 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h3>
<blockquote>
<p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li>
<li>主要协议：<code>TCP</code>、<code>UDP</code>。</li>
<li>数据单元：报文段（segment）或用户数据报。</li>
</ul>
<h3 id="~会话层~"><a class="markdownIt-Anchor" href="#~会话层~"></a> ~<sub>会话层~</sub></h3>
<blockquote>
<p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p>
</blockquote>
<h3 id="~表示层~"><a class="markdownIt-Anchor" href="#~表示层~"></a> ~<sub>表示层~</sub></h3>
<blockquote>
<p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p>
</blockquote>
<h3 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h3>
<blockquote>
<p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p>
<p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p>
</blockquote>
<ul>
<li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li>
<li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li>
<li>数据单元：报文（message）。</li>
</ul>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li>书
<ul>
<li><a href="https://book.douban.com/subject/10746113/">HTTP 权威指南</a></li>
<li><a href="https://book.douban.com/subject/1088054/">TCP/IP 详解 卷 1：协议</a></li>
<li><a href="https://book.douban.com/subject/1087767/">TCP/IP 详解 卷 2：实现</a></li>
<li><a href="https://book.douban.com/subject/1058634/">TCP/IP 详解 卷 3：TCP 事务协议、HTTP、NNTP 和 UNIX 域协议</a></li>
<li><a href="https://book.douban.com/subject/25856314/">Web 性能权威指南</a></li>
<li><a href="https://book.douban.com/subject/25863515/">图解 HTTP</a></li>
<li><a href="https://book.douban.com/subject/24737674/">图解 TCP/IP</a></li>
<li><a href="https://book.douban.com/subject/26960678/">计算机网络（第 7 版）</a> - 谢希仁</li>
</ul>
</li>
<li>站点
<ul>
<li><a href="https://www.rfc-editor.org/">https://www.rfc-editor.org/</a> - 在线查阅、下载 RFC 文档</li>
</ul>
</li>
<li>工具
<ul>
<li><a href="https://www.wireshark.org/">WireShark</a></li>
<li><a href="https://www.getpostman.com/">Postman</a></li>
</ul>
</li>
</ul>
<h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2>
<p>| <a href="https://github.com/dunwu/blog">回首頁</a> |</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>网络通信知识点面经</title>
    <url>/network/network-interview/</url>
    <content><![CDATA[<h1 id="网络通信知识点面经"><a class="markdownIt-Anchor" href="#网络通信知识点面经"></a> 网络通信知识点面经</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p>如果你不是从事于通信领域，面试时问及计算机网络的知识，一般也就限定在：HTTP（含 HTTPS、Cookie、Session）、TCP、UDP、Socket 这些</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E7%BB%BC%E5%90%88">1. 综合</a>
<ul>
<li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82">1.1. 计算机网络如何分层？</a></li>
</ul>
</li>
<li><a href="#2-http">2. HTTP</a></li>
<li><a href="#3-dns">3. DNS</a></li>
<li><a href="#4-tcpudp">4. TCP/UDP</a>
<ul>
<li><a href="#41-%E4%BB%80%E4%B9%88%E6%98%AF-tcp">4.1. 什么是 TCP？</a></li>
<li><a href="#42-tcp-%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88">4.2. TCP 的特性是什么？</a></li>
<li><a href="#43-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">4.3. TCP 三次握手</a></li>
<li><a href="#44-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4.4. TCP 四次挥手</a></li>
<li><a href="#45-tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.5. TCP 滑动窗口</a></li>
<li><a href="#46-tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4.6. TCP 重传机制</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-综合"><a class="markdownIt-Anchor" href="#1-综合"></a> 1. 综合</h2>
<h3 id="11-计算机网络如何分层"><a class="markdownIt-Anchor" href="#11-计算机网络如何分层"></a> 1.1. 计算机网络如何分层？</h3>
<blockquote>
<p>❓ 问题：计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p>
<p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p>
</blockquote>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/network-layers.png"/></div>
计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。
<ul>
<li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li>
<li>五层协议分层是一种折中方案，在现实中更为流行。</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/网络分层架构图.png"/></div>
**物理层**
<blockquote>
<p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p>
<p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p>
</blockquote>
<ul>
<li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li>
<li>数据单元：比特流。</li>
<li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li>
</ul>
<p><strong>数据链路层</strong></p>
<blockquote>
<p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
<p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p>
</blockquote>
<ul>
<li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li>
<li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li>
<li>数据单元：帧（frame）。</li>
<li>典型设备：二层交换机、网桥、网卡。</li>
</ul>
<p><strong>网络层</strong></p>
<blockquote>
<p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li>
<li>主要协议：<code>IP</code>。</li>
<li>数据单元：IP 数据报（packet）。</li>
<li>典型设备：网关、路由器。</li>
</ul>
<p><strong>传输层</strong></p>
<blockquote>
<p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p>
<p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p>
</blockquote>
<ul>
<li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li>
<li>主要协议：<code>TCP</code>、<code>UDP</code>。</li>
<li>数据单元：报文段（segment）或用户数据报。</li>
</ul>
<p><sub>~**会话层**~</sub></p>
<blockquote>
<p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p>
</blockquote>
<p><sub>~**表示层**~</sub></p>
<blockquote>
<p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p>
</blockquote>
<p><strong>应用层</strong></p>
<blockquote>
<p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p>
<p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p>
</blockquote>
<ul>
<li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li>
<li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li>
<li>数据单元：报文（message）。</li>
</ul>
<h2 id="2-http"><a class="markdownIt-Anchor" href="#2-http"></a> 2. HTTP</h2>
<blockquote>
<p>扩展阅读：<a href="http.md">超文本传输协议 HTTP</a></p>
</blockquote>
<h2 id="3-dns"><a class="markdownIt-Anchor" href="#3-dns"></a> 3. DNS</h2>
<blockquote>
<p>扩展阅读：<a href="dns.md">域名系统 DNS</a></p>
</blockquote>
<h2 id="4-tcpudp"><a class="markdownIt-Anchor" href="#4-tcpudp"></a> 4. TCP/UDP</h2>
<blockquote>
<p>扩展阅读：<a href="tcp.md">传输控制协议 TCP</a>，<a href="udp.md">用户数据报协议 UDP</a></p>
</blockquote>
<h3 id="41-什么是-tcp"><a class="markdownIt-Anchor" href="#41-什么是-tcp"></a> 4.1. 什么是 TCP？</h3>
<p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。</p>
<h3 id="42-tcp-的特性是什么"><a class="markdownIt-Anchor" href="#42-tcp-的特性是什么"></a> 4.2. TCP 的特性是什么？</h3>
<ul>
<li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li>
<li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：
<ul>
<li>数据包的序列号和校验码</li>
<li>确认包和自动重传
<ul>
<li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li>
<li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li>
</ul>
</li>
</ul>
</li>
<li><code>基于字节流的</code>
<ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li>
</ul>
</li>
</ul>
<h3 id="43-tcp-三次握手"><a class="markdownIt-Anchor" href="#43-tcp-三次握手"></a> 4.3. TCP 三次握手</h3>
<blockquote>
<p>❓ 问题：三次握手有什么用？什么是三次握手？为什么需要三次握手？</p>
</blockquote>
<p>（1）三次握手有什么用？</p>
<ul>
<li>三次握手负责建立 TCP 双向连接。</li>
</ul>
<p>（2）什么是三次握手？</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/三次握手.gif!zp"/></div>
如上图所示，三次握手流程如下：
<ol>
<li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li>
<li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li>
<li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li>
</ol>
<p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p>
<blockquote>
<p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p>
</blockquote>
<p>（3）为什么需要三次握手？</p>
<p>为了便于说明，假设客户端为 A, 服务端为 B。</p>
<ol>
<li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li>
<li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li>
<li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li>
</ol>
<h3 id="44-tcp-四次挥手"><a class="markdownIt-Anchor" href="#44-tcp-四次挥手"></a> 4.4. TCP 四次挥手</h3>
<blockquote>
<p>❓ 问题：四次挥手有什么用？什么是四次挥手？为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
</blockquote>
<p>（1）四次挥手有什么用？</p>
<ul>
<li>四次挥手负责断开 TCP 连接。</li>
</ul>
<p>（2）什么是四次挥手？</p>
<p>如上图所示，四次挥手流程如下：</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/四次挥手.gif!zp"/></div>
1. 第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。
2. 第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。
3. 第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。
4. 第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。
<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ul>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ul>
<h3 id="45-tcp-滑动窗口"><a class="markdownIt-Anchor" href="#45-tcp-滑动窗口"></a> 4.5. TCP 滑动窗口</h3>
<blockquote>
<p>❓ 问题：什么是滑动窗口？滑动窗口原理是什么？</p>
</blockquote>
<p>什么是滑动窗口？</p>
<p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p>
<p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p>
<p>滑动窗口原理是什么？</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265819762.png"/></div>
1. 已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。
2. 已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 \~ 45 字节为第 2 类。
3. 未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 \~ 51 字节为第 3 类。
4. 未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265927658.png"/></div>
这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。
<h3 id="46-tcp-重传机制"><a class="markdownIt-Anchor" href="#46-tcp-重传机制"></a> 4.6. TCP 重传机制</h3>
<blockquote>
<p>❓ 问题：为什么需要重传机制？TCP 有哪些重传机制，原理是什么？</p>
</blockquote>
<p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>TCP 重传机制主要有两种：</p>
<ul>
<li>超时重传机制</li>
<li>快速重传机制</li>
</ul>
<p>（1）超时重传机制</p>
<p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p>
<p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p>
<p>这种机制的重点是 RTO 的设置：</p>
<ul>
<li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li>
</ul>
<p>（2）快速重传机制</p>
<p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p>
<p>当接收方收到乱序片段时，需要重复发送 ACK。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之网络层</title>
    <url>/network/network-network/</url>
    <content><![CDATA[<h1 id="计算机网络之网络层"><a class="markdownIt-Anchor" href="#计算机网络之网络层"></a> 计算机网络之网络层</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p><strong>网络层（network layer）</strong> - 为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p>
<ul>
<li>主要协议：<code>IP</code>、<code>ICMP</code>。</li>
<li>数据单元：IP 数据报（packet）。</li>
<li>典型设备：网关、路由器。</li>
</ul>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#ip-%E5%8D%8F%E8%AE%AE">IP 协议</a>
<ul>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE">相关协议</a></li>
<li><a href="#%E5%88%86%E7%B1%BB%E7%9A%84-ip-%E5%9C%B0%E5%9D%80">分类的 IP 地址</a></li>
<li><a href="#ip-%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">IP 地址与物理地址</a></li>
<li><a href="#ip-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">IP 数据报格式</a></li>
</ul>
</li>
<li><a href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-arp">地址解析协议 ARP</a></li>
<li><a href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-icmp">网际控制报文协议 ICMP</a>
<ul>
<li><a href="#1-ping">1. Ping</a></li>
<li><a href="#2-traceroute">2. Traceroute</a></li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91-vpn">虚拟专用网 VPN</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-nat">网络地址转换 NAT</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">路由器的结构</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B">路由器分组转发流程</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">路由选择协议</a>
<ul>
<li><a href="#1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-rip">1. 内部网关协议 RIP</a></li>
<li><a href="#2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-ospf">2. 内部网关协议 OSPF</a></li>
<li><a href="#3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-bgp">3. 外部网关协议 BGP</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程间通信的可靠性由运输层负责。</p>
<h2 id="ip-协议"><a class="markdownIt-Anchor" href="#ip-协议"></a> IP 协议</h2>
<p>网际协议 IP (Internet Protocol) 定义了三种功能：</p>
<ol>
<li>IP 定义了在 TCP/IP 互联网上数据传送的基本单元和数据格式。</li>
<li>IP 软件完成路由选择功能，选择数据传送的路径。</li>
<li>IP 包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。</li>
</ol>
<h3 id="相关协议"><a class="markdownIt-Anchor" href="#相关协议"></a> 相关协议</h3>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1550912617336.png"/></div>
<h3 id="分类的-ip-地址"><a class="markdownIt-Anchor" href="#分类的-ip-地址"></a> 分类的 IP 地址</h3>
<p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h4 id="1-分类"><a class="markdownIt-Anchor" href="#1-分类"></a> 1. 分类</h4>
<p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086738403.png"/></div>
<h4 id="2-子网划分"><a class="markdownIt-Anchor" href="#2-子网划分"></a> 2. 子网划分</h4>
<p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h4 id="3-无分类"><a class="markdownIt-Anchor" href="#3-无分类"></a> 3. 无分类</h4>
<p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h3 id="ip-地址与物理地址"><a class="markdownIt-Anchor" href="#ip-地址与物理地址"></a> IP 地址与物理地址</h3>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551088476626.png"/></div>
<ul>
<li>物理地址是数据链路层和物理层使用的地址。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551088631948.png"/></div>
<h3 id="ip-数据报格式"><a class="markdownIt-Anchor" href="#ip-数据报格式"></a> IP 数据报格式</h3>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1550913213250.png"/></div>
<ul>
<li><strong>版本</strong> - 有 4（IPv4）和 6（IPv6）两个值。</li>
<li><strong>首部长度</strong> - 占 4 位，因此最大十进制数值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> - 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> - 包括首部长度和数据部分长度。占 16 位，因此数据报的最大长度为 2 <sup>16</sup> - 1 = 65535 字节。</li>
<li><strong>生存时间</strong> - TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> - 指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> - 因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> - 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> - 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1550913364479.png"/></div>
<h2 id="地址解析协议-arp"><a class="markdownIt-Anchor" href="#地址解析协议-arp"></a> 地址解析协议 ARP</h2>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086787261.png"/></div>
<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086769846.png"/></div>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086833117.png"/></div>
<h2 id="网际控制报文协议-icmp"><a class="markdownIt-Anchor" href="#网际控制报文协议-icmp"></a> 网际控制报文协议 ICMP</h2>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086857345.png"/></div>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086870897.png"/></div>
<h3 id="1-ping"><a class="markdownIt-Anchor" href="#1-ping"></a> 1. Ping</h3>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h3 id="2-traceroute"><a class="markdownIt-Anchor" href="#2-traceroute"></a> 2. Traceroute</h3>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h2 id="虚拟专用网-vpn"><a class="markdownIt-Anchor" href="#虚拟专用网-vpn"></a> 虚拟专用网 VPN</h2>
<p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086901339.png"/></div>
<h2 id="网络地址转换-nat"><a class="markdownIt-Anchor" href="#网络地址转换-nat"></a> 网络地址转换 NAT</h2>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<h2 id="路由器的结构"><a class="markdownIt-Anchor" href="#路由器的结构"></a> 路由器的结构</h2>
<p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086930371.png"/></div>
<h2 id="路由器分组转发流程"><a class="markdownIt-Anchor" href="#路由器分组转发流程"></a> 路由器分组转发流程</h2>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086952828.png"/></div>
<h2 id="路由选择协议"><a class="markdownIt-Anchor" href="#路由选择协议"></a> 路由选择协议</h2>
<p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h3 id="1-内部网关协议-rip"><a class="markdownIt-Anchor" href="#1-内部网关协议-rip"></a> 1. 内部网关协议 RIP</h3>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h3 id="2-内部网关协议-ospf"><a class="markdownIt-Anchor" href="#2-内部网关协议-ospf"></a> 2. 内部网关协议 OSPF</h3>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<h3 id="3-外部网关协议-bgp"><a class="markdownIt-Anchor" href="#3-外部网关协议-bgp"></a> 3. 外部网关协议 BGP</h3>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086977310.png"/></div>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之物理层</title>
    <url>/network/network-physical/</url>
    <content><![CDATA[<h1 id="计算机网络之物理层"><a class="markdownIt-Anchor" href="#计算机网络之物理层"></a> 计算机网络之物理层</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p><strong>摘要</strong></p>
<p><strong>物理层（Physical Layer）</strong> - 物理层只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p>
<ul>
<li>数据单元：比特流。</li>
<li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li>
</ul>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B">通信系统模型</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">通信方式</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1%E4%BF%A1%E5%8F%B7">通信信号</a></li>
<li><a href="#%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83">调制解调</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95">基本带通调制方法</a></li>
</ul>
</li>
<li><a href="#%E9%80%9A%E4%BF%A1%E5%AA%92%E4%BB%8B">通信媒介</a></li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8">信道复用</a></li>
</ul>
<!-- /TOC -->
<h2 id="通信系统模型"><a class="markdownIt-Anchor" href="#通信系统模型"></a> 通信系统模型</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/physical/数据通信系统的模型.png"/></div>
<p>通信系统模型分为三大部分：源系统（包括信源和发送器）、传输系统、目的系统（包括信宿接收器）。</p>
<p>重要概念：</p>
<ul>
<li><strong>信源</strong> - 也叫源点。产生各类信息的实体。</li>
<li><strong>信道</strong> - 通信的通道，是信号传输的媒介。</li>
<li><strong>信宿</strong> - 传输信息的归宿。</li>
<li><strong>码元</strong> - 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。</li>
</ul>
<h2 id="通信方式"><a class="markdownIt-Anchor" href="#通信方式"></a> 通信方式</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/physical/通信方式.jpg"/></div>
<p>有三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h2 id="通信信号"><a class="markdownIt-Anchor" href="#通信信号"></a> 通信信号</h2>
<p>通信的目的是传送消息。如语音、文字、图像、视频都是消息。数据时传送消息的实体。信号是数据的电气或电磁的表现。</p>
<p>模拟信号和数字信号</p>
<ul>
<li><strong>模拟信号</strong> - 模拟信号是连续的信号。</li>
<li><strong>数字信号</strong> - 数字信号是离散的信号。</li>
</ul>
<h2 id="调制解调"><a class="markdownIt-Anchor" href="#调制解调"></a> 调制解调</h2>
<p>重要概念：</p>
<ul>
<li><strong>基带信号</strong> - 来自信源的信号叫做基带信号。</li>
<li><strong>调制</strong> - 将各种数字基带信号转换成适于信道传输的数字调制信号(已调信号或频带信号)。简单来说：调制即，数字 -&gt; 模拟。</li>
<li><strong>解调</strong> - 在接收端将收到的数字频带信号还原成数字基带信号。简单来说：解调即，模拟 -&gt; 数字。</li>
</ul>
<blockquote>
<p>📌 提示：我们上网时所用到的调制解调器（俗称“猫”），指的就是转换数字和模拟信号的机器。</p>
</blockquote>
<p>信号要在信道上传输就要经过调制。</p>
<p>调制分为：基带调制和带通调制</p>
<h3 id="基本带通调制方法"><a class="markdownIt-Anchor" href="#基本带通调制方法"></a> 基本带通调制方法</h3>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/physical/基本调制方法.png"/></div>
<p>如果你收听过广播，一定经常听到 AM、FM 这两个关键词，这是什么意思呢？答案如下：</p>
<ul>
<li><strong>调幅（AM）</strong> - 即载波的<strong>振幅</strong>随基带数字信号而变化。</li>
<li><strong>调频（FM）</strong> - 即载波的<strong>频率</strong>随基带数字信号而变化。</li>
<li><strong>调相（PM）</strong> - 即载波的<strong>初始相位</strong>随基带数字信号而变化。</li>
</ul>
<blockquote>
<p>📌 提示：我们收听广播时，为了接收不同广播台的信号，就要调整 AM 或 FM，指的就是这里的调制方法。</p>
</blockquote>
<h2 id="通信媒介"><a class="markdownIt-Anchor" href="#通信媒介"></a> 通信媒介</h2>
<p>通信媒介分为两大类：</p>
<ul>
<li>导引型 - 双绞线、电缆、光纤</li>
<li>非导引型 - 无线、红外线、大气、激光</li>
</ul>
<h2 id="信道复用"><a class="markdownIt-Anchor" href="#信道复用"></a> 信道复用</h2>
<p>信道复用就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输一路信号。</p>
<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之传输层</title>
    <url>/network/network-transport/</url>
    <content><![CDATA[<h1 id="计算机网络之传输层"><a class="markdownIt-Anchor" href="#计算机网络之传输层"></a> 计算机网络之传输层</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#udp-%E5%92%8C-tcp-%E7%9A%84%E7%89%B9%E7%82%B9">UDP 和 TCP 的特点</a></li>
<li><a href="#udp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">UDP 首部格式</a></li>
<li><a href="#tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">TCP 首部格式</a></li>
<li><a href="#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP 的三次握手</a></li>
<li><a href="#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP 的四次挥手</a></li>
<li><a href="#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP 可靠传输</a></li>
<li><a href="#tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 滑动窗口</a></li>
<li><a href="#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 流量控制</a></li>
<li><a href="#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 拥塞控制</a>
<ul>
<li><a href="#1-%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">1. 慢开始与拥塞避免</a></li>
<li><a href="#2-%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">2. 快重传与快恢复</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="udp-和-tcp-的特点"><a class="markdownIt-Anchor" href="#udp-和-tcp-的特点"></a> UDP 和 TCP 的特点</h2>
<ul>
<li>
<p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li>
<p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
</li>
</ul>
<h2 id="udp-首部格式"><a class="markdownIt-Anchor" href="#udp-首部格式"></a> UDP 首部格式</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092392065.png"/></div>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<h2 id="tcp-首部格式"><a class="markdownIt-Anchor" href="#tcp-首部格式"></a> TCP 首部格式</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092419042.png"/></div>
<ul>
<li>
<p><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li>
<p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li>
<p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li>
<p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li>
<p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h2 id="tcp-的三次握手"><a class="markdownIt-Anchor" href="#tcp-的三次握手"></a> TCP 的三次握手</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092794258.png"/></div>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
</li>
<li>
<p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
</li>
<li>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
</li>
<li>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
</li>
<li>
<p>B 收到 A 的确认后，连接建立。</p>
</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h2 id="tcp-的四次挥手"><a class="markdownIt-Anchor" href="#tcp-的四次挥手"></a> TCP 的四次挥手</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092825974.png"/></div>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>
<p>A 发送连接释放报文，FIN=1。</p>
</li>
<li>
<p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p>
</li>
<li>
<p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
</li>
<li>
<p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p>
</li>
<li>
<p>B 收到 A 的确认后释放连接。</p>
</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>
<p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li>
<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</li>
</ul>
<h2 id="tcp-可靠传输"><a class="markdownIt-Anchor" href="#tcp-可靠传输"></a> TCP 可靠传输</h2>
<p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT"/></div> <br>
<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>
<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d"/></div> <br>
<p>其中 RTT<sub>d</sub> 为偏差的加权平均值。</p>
<h2 id="tcp-滑动窗口"><a class="markdownIt-Anchor" href="#tcp-滑动窗口"></a> TCP 滑动窗口</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092841802.png"/></div>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<h2 id="tcp-流量控制"><a class="markdownIt-Anchor" href="#tcp-流量控制"></a> TCP 流量控制</h2>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="tcp-拥塞控制"><a class="markdownIt-Anchor" href="#tcp-拥塞控制"></a> TCP 拥塞控制</h2>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092981695.png"/></div>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551093119265.png"/></div>
<h3 id="1-慢开始与拥塞避免"><a class="markdownIt-Anchor" href="#1-慢开始与拥塞避免"></a> 1. 慢开始与拥塞避免</h3>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<h3 id="2-快重传与快恢复"><a class="markdownIt-Anchor" href="#2-快重传与快恢复"></a> 2. 快重传与快恢复</h3>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551093167163.png"/></div>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 TCP</title>
    <url>/network/tcp/</url>
    <content><![CDATA[<h1 id="网络协议之-tcp"><a class="markdownIt-Anchor" href="#网络协议之-tcp"></a> 网络协议之 TCP</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-tcp">什么是 TCP</a></li>
<li><a href="#tcp-%E7%9A%84%E7%89%B9%E6%80%A7">TCP 的特性</a></li>
<li><a href="#tcp-%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">TCP 的适用场景</a></li>
<li><a href="#tcp-%E6%8A%A5%E6%96%87">TCP 报文</a></li>
</ul>
</li>
<li><a href="#tcp-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B">TCP 通信流程</a>
<ul>
<li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">三次握手</a></li>
<li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a></li>
</ul>
</li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li>
<li><a href="#tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">TCP 重传机制</a>
<ul>
<li><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">超时重传机制</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">快速重传机制</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP</h3>
<p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。TCP 由 RFC 793 定义。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559263786555.png"/></div>
<h3 id="tcp-的特性"><a class="markdownIt-Anchor" href="#tcp-的特性"></a> TCP 的特性</h3>
<ul>
<li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li>
<li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：
<ul>
<li>数据包的序列号和校验码</li>
<li>确认包和自动重传
<ul>
<li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li>
<li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li>
</ul>
</li>
</ul>
</li>
<li><code>基于字节流的</code>
<ul>
<li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li>
</ul>
</li>
</ul>
<h3 id="tcp-的适用场景"><a class="markdownIt-Anchor" href="#tcp-的适用场景"></a> TCP 的适用场景</h3>
<p>基于以上特性，为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。但要注意的是，在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，这时可以考虑在适用情况下切换到 UDP。</p>
<p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p>
<p>以下情况使用 TCP 代替 UDP：</p>
<ul>
<li>你需要数据完好无损。</li>
<li>你想对网络吞吐量自动进行最佳评估。</li>
</ul>
<h3 id="tcp-报文"><a class="markdownIt-Anchor" href="#tcp-报文"></a> TCP 报文</h3>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264511812.png"/></div>
<p>报文字段不一一阐述，重点关注以下几点：</p>
<ul>
<li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li>
<li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：
<ul>
<li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li>
<li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li>
</ul>
</li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264593860.png"/></div>
<h2 id="tcp-通信流程"><a class="markdownIt-Anchor" href="#tcp-通信流程"></a> TCP 通信流程</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264679371.png"/></div>
<p>TCP 完整的通信分为三块：</p>
<ol>
<li>三次握手建立连接</li>
<li>数据传输</li>
<li>四次挥手端口连接</li>
</ol>
<h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3>
<p>（1）三次握手有什么用？</p>
<ul>
<li>三次握手负责建立 TCP 双向连接。</li>
</ul>
<p>（2）什么是三次握手？</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/三次握手.gif!zp"/></div>
<p>如上图所示，三次握手流程如下：</p>
<ol>
<li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li>
<li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li>
<li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li>
</ol>
<p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p>
<blockquote>
<p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p>
</blockquote>
<p>（3）为什么需要三次握手？</p>
<p>为了便于说明，假设客户端为 A, 服务端为 B。</p>
<ol>
<li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li>
<li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li>
<li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li>
</ol>
<h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3>
<p>（1）四次挥手有什么用？</p>
<ul>
<li>四次挥手负责断开 TCP 连接。</li>
</ul>
<p>（2）什么是四次挥手？</p>
<p>如上图所示，四次挥手流程如下：</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/四次挥手.gif!zp"/></div>
<ol>
<li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li>
<li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li>
<li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li>
<li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li>
</ol>
<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ul>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ul>
<h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2>
<p>什么是滑动窗口？</p>
<p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p>
<p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p>
<p>滑动窗口原理是什么？</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265819762.png"/></div>
<ol>
<li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li>
<li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li>
<li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li>
<li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li>
</ol>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265927658.png"/></div>
<p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p>
<h2 id="tcp-重传机制"><a class="markdownIt-Anchor" href="#tcp-重传机制"></a> TCP 重传机制</h2>
<p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>TCP 重传机制主要有两种：</p>
<ul>
<li>超时重传机制</li>
<li>快速重传机制</li>
</ul>
<h3 id="超时重传机制"><a class="markdownIt-Anchor" href="#超时重传机制"></a> 超时重传机制</h3>
<p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p>
<p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p>
<p>这种机制的重点是 RTO 的设置：</p>
<ul>
<li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li>
</ul>
<h3 id="快速重传机制"><a class="markdownIt-Anchor" href="#快速重传机制"></a> 快速重传机制</h3>
<p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p>
<p>当接收方收到乱序片段时，需要重复发送 ACK。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a></li>
<li><a href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）</a></li>
<li><a href="https://juejin.im/post/5a7835a46fb9a063606eb801">图解 TCP 三次握手与四次分手</a></li>
<li><a href="https://blog.csdn.net/qzcsu/article/details/72861891">TCP 的三次握手与四次挥手（详解+动图）</a></li>
<li><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678">TCP 详解</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 UDP</title>
    <url>/network/udp/</url>
    <content><![CDATA[<h1 id="网络协议之-udp"><a class="markdownIt-Anchor" href="#网络协议之-udp"></a> 网络协议之 UDP</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#udp-%E7%89%B9%E7%82%B9">UDP 特点</a></li>
<li><a href="#udp-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">UDP 应用场景</a></li>
</ul>
</li>
<li><a href="#udp-%E6%8A%A5%E6%96%87">UDP 报文</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559263939493.png"/></div>
<p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p>
<p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p>
<p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p>
<p>以下情况使用 UDP 代替 TCP：</p>
<ul>
<li>你需要低延迟</li>
<li>相对于数据丢失更糟的是数据延迟</li>
<li>你想实现自己的错误校正方法</li>
</ul>
<h3 id="udp-特点"><a class="markdownIt-Anchor" href="#udp-特点"></a> UDP 特点</h3>
<ol>
<li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li>
<li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li>
<li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li>
<li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li>
<li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li>
</ol>
<h3 id="udp-应用场景"><a class="markdownIt-Anchor" href="#udp-应用场景"></a> UDP 应用场景</h3>
<ol>
<li>名字转换（DNS）</li>
<li>文件传送（TFTP）</li>
<li>路由选择协议（RIP）</li>
<li>IP 地址配置（BOOTP，DHTP）</li>
<li>网络管理（SNMP）</li>
<li>远程文件服务（NFS）</li>
<li>IP 电话</li>
<li>流式多媒体通信</li>
</ol>
<h2 id="udp-报文"><a class="markdownIt-Anchor" href="#udp-报文"></a> UDP 报文</h2>
<p>UDP 数据报分为数据字段和首部字段。<br />
首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。</p>
<p><strong>首部各字段意义</strong>：</p>
<ol>
<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li>
<li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>
<li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络通信之 VPN</title>
    <url>/network/vpn/</url>
    <content><![CDATA[<h1 id="网络通信之-vpn"><a class="markdownIt-Anchor" href="#网络通信之-vpn"></a> 网络通信之 VPN</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203095528.png" alt="img" /></p>
<!-- TOC depthFrom:2 depthTo:3 -->
<span id="more"></span>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#vpn-%E7%9A%84%E4%BD%9C%E7%94%A8">VPN 的作用</a>
<ul>
<li><a href="#%E9%9A%90%E8%97%8F-ip-%E5%92%8C%E4%BD%8D%E7%BD%AE">隐藏 IP 和位置</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1%E5%8A%A0%E5%AF%86">通信加密</a></li>
<li><a href="#%E7%BF%BB%E5%A2%99">翻墙</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E8%A2%AB%E7%9B%91%E5%90%AC">避免被监听</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a></li>
<li><a href="#vpn-%E5%8D%8F%E8%AE%AE">VPN 协议</a></li>
<li><a href="#vpn-%E6%9C%8D%E5%8A%A1">VPN 服务</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>虚拟专用网络(VPN)的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN 网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN 可通过服务器、硬件、软件等多种方式实现。</p>
<p>VPN 属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。<br />
在传统的企业网络配置中，要进行远程访问，传统的方法是租用 DDN（数字数据网）专线或帧中继，这样的通讯方案必然导致高昂的网络通讯和维护费用。对于移动用户（移动办公人员）与远端个人用户而言，一般会通过拨号线路（Internet）进入企业的局域网，但这样必然带来安全上的隐患。<br />
让外地员工访问到内网资源，利用 VPN 的解决方法就是在内网中架设一台 VPN 服务器。外地员工在当地连上互联网后，通过互联网连接 VPN 服务器，然后通过 VPN 服务器进入企业内网。为了保证数据安全，VPN 服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上 VPN 使用的是互联网上的公用链路，因此 VPN 称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了 VPN 技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用 VPN 访问内网资源，这就是 VPN 在企业中应用得如此广泛的原因。</p>
<h2 id="vpn-的作用"><a class="markdownIt-Anchor" href="#vpn-的作用"></a> VPN 的作用</h2>
<h3 id="隐藏-ip-和位置"><a class="markdownIt-Anchor" href="#隐藏-ip-和位置"></a> 隐藏 IP 和位置</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100404.png" alt="img" /></p>
<p>VPN 可以隐藏使用者的 IP 地址和位置。</p>
<p>使用 VPN 的最常见原因之一是屏蔽您的真实 IP 地址。</p>
<p>您的 IP 地址是由 ISP 分配的唯一数字地址。 您在线上所做的所有事情都链接到您的 IP 地址，因此可以用来将您与在线活动进行匹配。 大多数网站记录其访问者的 IP 地址。</p>
<p>广告商还可以使用您的 IP 地址，根据您的身份和浏览历史为您提供有针对性的广告。</p>
<p>连接到 VPN 服务器时，您将使用该 VPN 服务器的 IP 地址。 您访问的任何网站都会看到 VPN 服务器的 IP 地址，而不是您自己的。</p>
<p>您将能够绕过 IP 地址阻止并浏览网站，而不会将您的活动作为一个个人追溯到您。</p>
<h3 id="通信加密"><a class="markdownIt-Anchor" href="#通信加密"></a> 通信加密</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100543.png" alt="img" /></p>
<p>使用 VPN 时，可以对信息进行加密，使得密码，电子邮件，照片，银行数据和其他敏感信息不会被拦截。</p>
<p>如果在公共场所使用公共 WiFi 连接网络时，敏感数据有被盗的风险。黑客可以利用开放和未加密的网络来窃取重要数据，例如您的密码，电子邮件，照片，银行数据和其他敏感信息。</p>
<p>VPN 可以加密信息，使黑客更难以拦截和窃取数据。</p>
<h3 id="翻墙"><a class="markdownIt-Anchor" href="#翻墙"></a> 翻墙</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100706.png" alt="img" /></p>
<p>轻松解除对 Facebook 和 Twitter，Skype，YouTube 和 Gmail 等网站和服务的阻止。 即使您被告知您所在的国家/地区不可用它，或者您所在的学校或办公室网络限制访问，也可以获取所需的东西。</p>
<p>某些服务（例如 Netflix 或 BBC iPlayer）会根据您访问的国家/地区限制访问内容。使用 VPN 可以绕过这些地理限制并解锁“隐藏”内容的唯一可靠方法。</p>
<h3 id="避免被监听"><a class="markdownIt-Anchor" href="#避免被监听"></a> 避免被监听</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100933.png" alt="img" /></p>
<p>使用 VPN 可以向政府、ISP、黑客隐藏通信信息。</p>
<p>您的 Internet 服务提供商（ISP）可以看到您访问的所有网站，并且几乎可以肯定会记录该信息。</p>
<p>在某些国家/地区，ISP 需要长时间收集和存储用户数据，并且政府能够访问，存储和搜索该信息。</p>
<p>在美国，英国，澳大利亚和欧洲大部分地区就是这种情况，仅举几例。</p>
<p>由于 VPN 会加密从设备到 VPN 服务器的互联网流量，因此您的 ISP 或任何其他第三方将无法监视您的在线活动。</p>
<p>要了解有关监视技术和全球大规模监视问题的更多信息，请访问 EFF 和 Privacy International。 您还可以在此处找到全球监视披露的更新列表。</p>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<p>VPN 会在您的设备和私人服务器之间建立私人和加密的互联网连接。 这意味着您的数据无法被 ISP 或任何其他第三方读取或理解。 然后，私有服务器将您的流量发送到您要访问的网站或服务上。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203102422.png" alt="img" /></p>
<p>VPN 的基本处理过程如下：</p>
<ol>
<li>要保护主机发送明文信息到其他 VPN 设备。</li>
<li>VPN 设备根据网络管理员设置的规则，确定是对数据进行加密还是直接传输。</li>
<li>对需要加密的数据，VPN 设备将其整个数据包（包括要传输的数据、源 IP 地址和目的 lP 地址）进行加密并附上数据签名，加上新的数据报头（包括目的地 VPN 设备需要的安全信息和一些初始化参数）重新封装。</li>
<li>将封装后的数据包通过隧道在公共网络上传输。</li>
<li>数据包到达目的 VPN 设备后，将其解封，核对数字签名无误后，对数据包解密。</li>
</ol>
<h2 id="vpn-协议"><a class="markdownIt-Anchor" href="#vpn-协议"></a> VPN 协议</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203102656.png" alt="img" /></p>
<ul>
<li>
<p>OpenVPN</p>
</li>
<li>
<p>IKEv2 / IPSec</p>
</li>
<li>
<p>SSTP</p>
</li>
<li>
<p>PPTP</p>
</li>
<li>
<p>Wireguard</p>
</li>
</ul>
<h2 id="vpn-服务"><a class="markdownIt-Anchor" href="#vpn-服务"></a> VPN 服务</h2>
<p>你可以选择付费 VPN 或自行搭建 VPN。</p>
<p>VPN 服务商：</p>
<ul>
<li><a href="https://go.nordvpn.net/aff_c?offer_id=15&amp;aff_id=22023&amp;url_id=902">NordVPN</a></li>
<li><a href="https://www.linkev.com/?a_fid=techacro">ExpressVPN</a></li>
<li><a href="https://cybertool.co/tchacrobat_fs_izci9mc6y">CyberGhostVPN</a></li>
<li><a href="https://click.tunnelbear.com/aff_c?offer_id=36&amp;aff_id=7306">TunnelBear</a></li>
<li><a href="https://www.ipvanish.com/">IPVanish</a></li>
</ul>
<p>开源 VPN：</p>
<ul>
<li><a href="https://openvpn.net/">OpenVPN</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C">百度百科 - VPN</a></li>
<li><a href="https://www.expressvpn.com/what-is-vpn">What is a VPN</a></li>
<li><a href="https://www.youtube.com/watch?v=_wQTRMBAvzg">What is a VPN and How Does it Work</a></li>
<li><a href="https://www.top10vpn.com/guides/what-is-a-vpn/">What Is a VPN (Virtual Private Network) and How Does It Work?</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之 Websocket</title>
    <url>/network/websocket/</url>
    <content><![CDATA[<h1 id="socket-和-websocket"><a class="markdownIt-Anchor" href="#socket-和-websocket"></a> Socket 和 WebSocket</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#socket">Socket</a>
<ul>
<li><a href="#socket-%E7%94%A8%E6%B3%95">Socket 用法</a></li>
<li><a href="#socket-%E9%95%BF%E8%BF%9E%E6%8E%A5">Socket 长连接</a></li>
</ul>
</li>
<li><a href="#websocket">WebSocket</a>
<ul>
<li><a href="#websocket-%E7%AE%80%E4%BB%8B">WebSocket 简介</a></li>
<li><a href="#websocket-%E4%BD%BF%E7%94%A8">WebSocket 使用</a></li>
</ul>
</li>
<li><a href="#faq">FAQ</a>
<ul>
<li><a href="#http-vs-socket">Http vs. Socket</a></li>
<li><a href="#http-%E5%92%8C-websocket-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">HTTP 和 WebSocket 有什么关系？</a></li>
<li><a href="#html-%E5%92%8C-http-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">Html 和 HTTP 有什么关系？</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> Socket</h2>
<p>Socket 作为一种抽象层，应用程序通过它来发送和接收数据，使用 Socket 可以将应用程序与处于同一网络中的其他应用程序进行通信交互。简而言之，Socket 提供了应用程序内部与外界通信的端口以及为通信双方提供了数据传输的通道。</p>
<h3 id="socket-用法"><a class="markdownIt-Anchor" href="#socket-用法"></a> Socket 用法</h3>
<p>很多编程语言都支持 Socket。这里以 Java 的 Socket 用法为例。</p>
<p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。使用 socket 的步骤如下：</p>
<ul>
<li>创建 <code>ServerSocket</code> 并监听客户连接</li>
<li>使用 <code>Socket</code> 连接服务端</li>
<li>通过 <code>Socket</code> 获取输入输出流进行通信</li>
</ul>
<h3 id="socket-长连接"><a class="markdownIt-Anchor" href="#socket-长连接"></a> Socket 长连接</h3>
<p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">socket.set<span class="constructor">KeepAlive(<span class="params">true</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h2>
<h3 id="websocket-简介"><a class="markdownIt-Anchor" href="#websocket-简介"></a> WebSocket 简介</h3>
<h4 id="websocket-是什么"><a class="markdownIt-Anchor" href="#websocket-是什么"></a> WebSocket 是什么</h4>
<p><a href="http://websocket.org/">WebSocket</a> 是一种网络通信协议。<a href="https://tools.ietf.org/html/rfc6455">RFC6455</a> 定义了它的通信标准。</p>
<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>
<h4 id="为什么需要-websocket"><a class="markdownIt-Anchor" href="#为什么需要-websocket"></a> 为什么需要 WebSocket</h4>
<p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p>
<p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p>
<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/spring/web/ajax-long-polling.png"/></div>
因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/spring/web/websockets-flow.png"/></div>
#### WebSocket 如何工作
<p>Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p>
<p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p>
<h3 id="websocket-使用"><a class="markdownIt-Anchor" href="#websocket-使用"></a> WebSocket 使用</h3>
<h4 id="websocket-客户端"><a class="markdownIt-Anchor" href="#websocket-客户端"></a> WebSocket 客户端</h4>
<p>在客户端，没有必要为 WebSockets 使用 JavaScript 库。实现 WebSockets 的 Web 浏览器将通过 WebSockets 对象公开所有必需的客户端功能（主要指支持 Html5 的浏览器）。</p>
<p>以下 API 用于创建 WebSocket 对象。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var Socket = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure>
<p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p>
<h5 id="websocket-属性"><a class="markdownIt-Anchor" href="#websocket-属性"></a> WebSocket 属性</h5>
<p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Socket.readyState</td>
<td>只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td>
</tr>
<tr>
<td>Socket.bufferedAmount</td>
<td>只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td>
</tr>
</tbody>
</table>
<h5 id="websocket-事件"><a class="markdownIt-Anchor" href="#websocket-事件"></a> WebSocket 事件</h5>
<p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>事件处理程序</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>Socket.onopen</td>
<td>连接建立时触发</td>
</tr>
<tr>
<td>message</td>
<td>Socket.onmessage</td>
<td>客户端接收服务端数据时触发</td>
</tr>
<tr>
<td>error</td>
<td>Socket.onerror</td>
<td>通信发生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>Socket.onclose</td>
<td>连接关闭时触发</td>
</tr>
</tbody>
</table>
<h5 id="websocket-方法"><a class="markdownIt-Anchor" href="#websocket-方法"></a> WebSocket 方法</h5>
<p>以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Socket.send()</td>
<td>使用连接发送数据</td>
</tr>
<tr>
<td>Socket.close()</td>
<td>关闭连接</td>
</tr>
</tbody>
</table>
<p>WebSocket 客户端代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个 WebSocket 对象</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:9998/echo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 web socket 连接成功触发事件</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 send() 方法发送数据</span></span><br><span class="line">  ws.send(<span class="string">&#x27;发送数据&#x27;</span>)</span><br><span class="line">  alert(<span class="string">&#x27;数据发送中...&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端数据时触发事件</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> received_msg = evt.data</span><br><span class="line">  alert(<span class="string">&#x27;数据已接收...&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 web socket 连接成功触发事件</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;连接已关闭...&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="websocket-服务端"><a class="markdownIt-Anchor" href="#websocket-服务端"></a> WebSocket 服务端</h4>
<p>WebSocket 在服务端的实现非常丰富。Node.js、Java、C++、Python 等多种语言都有自己的解决方案。</p>
<p>以下，介绍我在学习 WebSocket 过程中接触过的 WebSocket 服务端解决方案。</p>
<h5 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h5>
<p>常用的 Node 实现有以下三种。</p>
<ul>
<li><a href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li>
<li><a href="http://socket.io/">Socket.IO</a></li>
<li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li>
</ul>
<h5 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h5>
<p>Java 的 web 一般都依托于 servlet 容器。</p>
<p>我使用过的 servlet 容器有：Tomcat、Jetty、Resin。其中 Tomcat7、Jetty7 及以上版本均开始支持 WebSocket（推荐较新的版本，因为随着版本的更迭，对 WebSocket 的支持可能有变更）。</p>
<p>此外，Spring 框架对 WebSocket 也提供了支持。</p>
<p>虽然，以上应用对于 WebSocket 都有各自的实现。但是，它们都遵循<a href="https://tools.ietf.org/html/rfc6455">RFC6455</a> 的通信标准，并且 Java API 统一遵循 <a href="http://www.jcp.org/en/jsr/detail?id=356">JSR 356 - JavaTM API for WebSocket </a> 规范。所以，在实际编码中，API 差异不大。</p>
<h5 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h5>
<p>Spring 对于 WebSocket 的支持基于下面的 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 Spring 实现 WebSocket 服务器大概分为以下几步：</p>
<p><strong>创建 WebSocket 处理器</strong></p>
<p>扩展 <code>TextWebSocketHandler</code> 或 <code>BinaryWebSocketHandler</code> ，你可以覆写指定的方法。Spring 在收到 WebSocket 事件时，会自动调用事件对应的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WebSocketHandler</code> 源码如下，这意味着你的处理器大概可以处理哪些 WebSocket 事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 建立连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 收到消息时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传输消息出错时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 断开连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否处理分片消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置 WebSocket</strong></p>
<p>配置有两种方式：注解和 xml 。其作用就是将 WebSocket 处理器添加到注册中心。</p>
<ol>
<li>实现 <code>WebSocketConfigurer</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">&quot;/myHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>xml 方式</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">&quot;http://www.springframework.org/schema/websocket&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/myHandler&quot;</span> <span class="attr">handler</span>=<span class="string">&quot;myHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.MyHandler&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多配置细节可以参考：<a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket">Spring WebSocket 文档</a></p>
</blockquote>
<p>javax.websocket</p>
<p>如果不想使用 Spring 框架的 WebSocket API，你也可以选择基本的 javax.websocket。</p>
<p>首先，需要引入 API jar 包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To write basic javax.websocket against --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用嵌入式 jetty，你还需要引入它的实现包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To run javax.websocket in embedded server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-server-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- To run javax.websocket client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-client-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@ServerEndpoint</strong></p>
<p>这个注解用来标记一个类是 WebSocket 的处理器。</p>
<p>然后，你可以在这个类中使用下面的注解来表明所修饰的方法是触发事件的回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到消息触发事件</span></span><br><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接触发事件</span></span><br><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, EndpointConfig config, <span class="meta">@PathParam(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接触发事件</span></span><br><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输消息错误触发事件</span></span><br><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ServerEndpointConfig.Configurator</strong></p>
<p>编写完处理器，你需要扩展 ServerEndpointConfig.Configurator 类完成配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerConfigurator</span> <span class="keyword">extends</span> <span class="title">ServerEndpointConfig</span>.<span class="title">Configurator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> </span>&#123;</span><br><span class="line">        HttpSession httpSession = (HttpSession) request.getHttpSession();</span><br><span class="line">        sec.getUserProperties().put(HttpSession.class.getName(), httpSession);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就没有然后了，就是这么简单。</p>
<h4 id="websocket-代理"><a class="markdownIt-Anchor" href="#websocket-代理"></a> WebSocket 代理</h4>
<p>如果把 WebSocket 的通信看成是电话连接，Nginx 的角色则像是电话接线员，负责将发起电话连接的电话转接到指定的客服。</p>
<p>Nginx 从 <a href="http://nginx.com/blog/websocket-nginx/">1.3 版</a>开始正式支持 WebSocket 代理。如果你的 web 应用使用了代理服务器 Nginx，那么你还需要为 Nginx 做一些配置，使得它开启 WebSocket 代理功能。</p>
<p>以下为参考配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="comment"># this section is specific to the WebSockets proxying</span></span><br><span class="line">  <span class="attribute">location</span> /socket.io &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app_server_wsgiapp/socket.io;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade $http_upgrade;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多配置细节可以参考：<a href="http://nginx.org/en/docs/http/websocket.html">Nginx 官方的 websocket 文档</a></p>
</blockquote>
<h4 id="websocket-应用示例"><a class="markdownIt-Anchor" href="#websocket-应用示例"></a> WebSocket 应用示例</h4>
<p>如果需要完整示例代码，可以参考我的 Github 代码：</p>
<ul>
<li><a href="https://github.com/dunwu/spring-notes/tree/master/codes/web/websocket">Spring 对 WebSocket 支持的示例</a></li>
<li><a href="https://github.com/dunwu/javaee-notes/tree/master/codes/websocket">嵌入式 Jetty 服务器的 WebSocket 示例</a></li>
</ul>
<p>spring-websocket 和 jetty 9.3 版本似乎存在兼容性问题，Tomcat 则木有问题。</p>
<p>我尝试了好几次，没有找到解决方案，只好使用 Jetty 官方的嵌入式示例在 Jetty 中使用 WebSocket 。</p>
<h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2>
<h3 id="http-vs-socket"><a class="markdownIt-Anchor" href="#http-vs-socket"></a> Http vs. Socket</h3>
<p>Http 通信与 Socket 通信方式有何差异？</p>
<ul>
<li>Http
<ul>
<li>基于请求/响应模式，采取一问一答方式（客户端请求，服务端才会响应）</li>
</ul>
</li>
<li>Socket
<ul>
<li>客户端和服务端建立双向连接。连接成功后，任意一方都可主动发送消息。</li>
<li>数据丢失率低，使用简单，易于移植。</li>
</ul>
</li>
</ul>
<h3 id="http-和-websocket-有什么关系"><a class="markdownIt-Anchor" href="#http-和-websocket-有什么关系"></a> HTTP 和 WebSocket 有什么关系？</h3>
<p>Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。</p>
<h3 id="html-和-http-有什么关系"><a class="markdownIt-Anchor" href="#html-和-http-有什么关系"></a> Html 和 HTTP 有什么关系？</h3>
<p>Html 是超文本标记语言，是一种用于创建网页的标准标记语言。它是一种技术标准。Html5 是它的最新版本。</p>
<p>Http 是一种网络通信协议。其本身和 Html 没有直接关系。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.zhihu.com/question/20215561">知乎高票答案——WebSocket 是什么原理</a> - 对 WebSocket 原理的阐述简单易懂。</li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a> - 阮一峰大神的科普一如既往的浅显易懂。</li>
<li><a href="https://www.fullstackpython.com/websockets.html">WebSockets</a> - by <em>fullstackpython</em></li>
<li><a href="http://nginx.org/en/docs/http/websocket.html">Nginx 官方的 websocket 文档</a></li>
<li><a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket">Spring WebSocket 文档</a></li>
<li><a href="http://tomcat.apache.org/tomcat-7.0-doc/web-socket-howto.html">Tomcat7 WebSocket 文档</a></li>
<li><a href="https://www.eclipse.org/jetty/documentation/9.4.7.v20170914/websocket-intro.html">Jetty WebSocket 文档</a></li>
<li><a href="https://juejin.im/post/57f885370bd1d00058b37d74">Socket，你需要知道的事儿</a></li>
<li><a href="https://juejin.im/post/5b3649d751882552f052703b">手把手教你写 Socket 长连接</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>通信</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>效率提升方法论</title>
    <url>/efficiency/methodology/</url>
    <content><![CDATA[<h1 id="效率提升方法论"><a class="markdownIt-Anchor" href="#效率提升方法论"></a> 效率提升方法论</h1>
<p>在智力水平相当的前提下，常常会发现：有些人做事，事倍功半；有些人做事，事半功倍。</p>
<p>做任何事，如果有了清晰的思路，正确的指导方针，肯定是比毫无头绪要高效很多。所以，现实中，常常会看到这样一种现象，优秀的人，往往全面优秀，干什么都出彩；而平庸的人，做什么都出不了成绩。</p>
<p>大多数人不是天才，想要变得优秀，唯一的途径就是：按照正确的习惯（方式方法），坚持不懈的努力进步（自律）。</p>
<blockquote>
<p>我们日复一日做的事情，决定了我们是怎样的人。因此<strong>所谓卓越，并非指行为，而是习惯</strong>。</p>
<p>We are what we repeatedly do. Excellence, then, is not an act, but a habit.</p>
<p>——莎士比亚</p>
</blockquote>
<h2 id="5w2h"><a class="markdownIt-Anchor" href="#5w2h"></a> 5W2H</h2>
<p><strong>5W2H 分析法是一种思考问题的启发式思维方式</strong>。5W2H 分析法用五个以 <code>W</code> 开头的英语单词和两个以 <code>H</code> 开头的英语单词进行设问，得到关键性问题的答案，最后总结归纳出问题的目标、解决思路、处理方法等，这就叫做 5W2H 法。</p>
<p>5W2H 分析法又叫七问分析法，是二战中美国陆军兵器修理部首创。这种分析法广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p>
<p>5W2H 分析法的意义在于：避免遇到一个问题后，不知从何入手。通过设问方式，由点成线，由线成面，把问题的关键点串联起来，整理出问题的解决思路。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210161837.png" alt="5W2H" /></p>
<ul>
<li>
<p><strong>why</strong> - 为什么？为什么要这么做？理由何在？原因是什么？</p>
</li>
<li>
<p><strong>what</strong> - 是什么？目的是什么？作什么工作？</p>
</li>
<li>
<p><strong>where</strong> - 何处？在哪里做？从哪里入手？</p>
</li>
<li>
<p><strong>when</strong> - 何时？什么时间完成？什么时机最适宜？</p>
</li>
<li>
<p><strong>who</strong> - 谁？有谁来承担？谁来完成？谁负责？</p>
</li>
<li>
<p><strong>how</strong> - 怎么做？如何提高效率？如何实施？方法怎么样？</p>
</li>
<li>
<p><strong>how much</strong> - 多少？做到什么程度？数量如何？质量水平如何？费用产出如何？</p>
</li>
</ul>
<h2 id="四象限原则"><a class="markdownIt-Anchor" href="#四象限原则"></a> 四象限原则</h2>
<p><strong>四象限原则是一种时间管理方式</strong>。</p>
<p>有首歌唱出了大多数职场人的心声：时间都去哪儿了？</p>
<p>事情、任务太多，时间太少，分身乏术。</p>
<p>时间管理四象限法则是美国的管理学家科维提出的一个时间管理的理论，按处理顺序划分为：紧急又重要、重要不紧急、紧急不重要、不紧急不重要。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210173335.png" alt="img" /></p>
<ul>
<li>
<p><strong>第一象限（重要而紧急</strong>）</p>
<ul>
<li>案例：应付难缠的客户、准时完成工作、住院开刀等等。</li>
<li>这是考验我们的经验、判断力的时刻，也是可以用心耕耘的园地。如果荒废了，我们很会可能变成行尸走肉。但我们也不能忘记，很多重要的事都是因为一拖再拖或事前准备不足，而变成迫在眉睫。</li>
<li>该象限的本质是缺乏有效的工作计划导致本处于“重要但不紧急”第二象限的事情转变过来的，这也是传统思维状态下的管理者的通常状况，就是“忙”。</li>
</ul>
</li>
<li>
<p><strong>第二象限（重要但不紧急）</strong></p>
<ul>
<li>案例：学习新技能、建立人际关系、保持身体健康、长期的规划、问题的发掘与预防、参加培训、向上级提出问题处理的建议等等事项。</li>
<li>荒废这个领域将使第一象限日益扩大，使我们陷入更大的压力，在危机中疲于应付。反之，多投入一些时间在这个领域有利于提高实践能力，缩小第一象限的范围。做好事先的规划、准备与预防措施，很多急事将无从产生。这个领域的事情不会对我们造成催促力量，所以必须主动去做，这是发挥个人领导力的领域。</li>
<li>这更是传统低效管理者与高效卓越管理者的重要区别标志，建议管理者要把 80%的精力投入到该象限的工作，以使第一象限的“急”事无限变少，不再瞎“忙”。</li>
</ul>
</li>
<li>
<p><strong>第三象限（紧急但不重要）</strong></p>
<ul>
<li>案例：电话、会议、突发的访客都属于这一类。</li>
<li>表面看似第一象限，因为迫切的呼声会让我们产生“这件事很重要”的错觉——实际上就算重要也是对别人而言。我们花很多时间在这个里面打转，自以为是在第一象限，其实不过是在满足别人的期望与标准。</li>
</ul>
</li>
<li>
<p><strong>第四象限（不紧急也不重要）</strong></p>
<ul>
<li>案例：阅读无聊小说、看毫无内容的电视节目、办公室聊天、刷微博、刷朋友圈等。</li>
<li>简而言之就是浪费生命，所以根本不值得花半点时间在这个象限。但我们往往在一、三象限来回奔走，忙得焦头烂额，不得不到第四象限去疗养一番再出发。这部分范围倒不见得都是休闲活动，因为真正有创造意义的休闲活动是很有价值的。然而像阅读令人上瘾的无聊小说、毫无内容的电视节目、办公室聊天等。这样的休息不但不是为了走更长的路，反而是对身心的毁损，刚开始时也许有滋有味，到后来你就会发现其实是很空虚的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>效率提升</category>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>效率提升</tag>
        <tag>方法论</tag>
        <tag>5W2H</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始学微服务学习笔记</title>
    <url>/note/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1">1. 到底什么是微服务？</a></li>
<li><a href="#2-%E4%BB%8E%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E8%B5%B0%E5%90%91%E6%9C%8D%E5%8A%A1%E5%8C%96">2. 从单体应用走向服务化</a>
<ul>
<li><a href="#21-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86">2.1. 什么时候进行服务化拆分？</a></li>
<li><a href="#22-%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A7%BF%E5%8A%BF">2.2. 服务化拆分的两种姿势</a></li>
<li><a href="#23-%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86%E7%9A%84%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6">2.3. 服务化拆分的前置条件</a></li>
</ul>
</li>
<li><a href="#3-%E5%88%9D%E6%8E%A2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84">3. 初探微服务架构</a></li>
<li><a href="#4-%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%92%8C%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1">4. 如何发布和引用服务？</a></li>
<li><a href="#5-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1">5. 如何注册和发现服务？</a>
<ul>
<li><a href="#51-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">5.1. 注册中心实现方式</a></li>
<li><a href="#52-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2">5.2. 集群部署</a></li>
<li><a href="#53-%E7%9B%AE%E5%BD%95%E5%AD%98%E5%82%A8">5.3. 目录存储</a></li>
<li><a href="#54-%E6%9C%8D%E5%8A%A1%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E6%A3%80%E6%B5%8B">5.4. 服务健康状态检测</a></li>
<li><a href="#55-%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4%E9%80%9A%E7%9F%A5">5.5. 服务状态变更通知</a></li>
<li><a href="#56-%E7%99%BD%E5%90%8D%E5%8D%95%E6%9C%BA%E5%88%B6">5.6. 白名单机制</a></li>
</ul>
</li>
<li><a href="#6-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-rpc-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">6. 如何实现 RPC 远程服务调用？</a></li>
<li><a href="#7-%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">7. 如何监控微服务调用？</a></li>
<li><a href="#8-%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">8. 如何追踪微服务调用？</a>
<ul>
<li><a href="#81-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%9A%84%E4%BD%9C%E7%94%A8">8.1. 服务追踪的作用</a></li>
<li><a href="#82-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86">8.2. 服务追踪系统原理</a></li>
<li><a href="#83-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">8.3. 服务追踪系统实现</a></li>
</ul>
</li>
<li><a href="#9-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B">9. 微服务治理的手段有哪些？</a>
<ul>
<li><a href="#91-%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86">9.1. 节点管理</a></li>
<li><a href="#92-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">9.2. 负载均衡</a></li>
<li><a href="#93-%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1">9.3. 服务路由</a></li>
<li><a href="#94-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99">9.4. 服务容错</a></li>
</ul>
</li>
<li><a href="#10-dubbo-%E6%A1%86%E6%9E%B6%E9%87%8C%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6">10. Dubbo 框架里的微服务组件</a></li>
<li><a href="#11-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9E%E8%B7%B5">11. 服务发布和引用的实践</a></li>
<li><a href="#12-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0">12. 如何将注册中心落地？</a>
<ul>
<li><a href="#121-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">12.1. 注册中心工作流程</a></li>
<li><a href="#122-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%8A%82%E7%82%B9">12.2. 如何注册节点</a></li>
<li><a href="#123-%E5%A6%82%E4%BD%95%E5%8F%8D%E6%B3%A8%E5%86%8C">12.3. 如何反注册</a></li>
<li><a href="#124-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF">12.4. 如何查询节点信息</a></li>
<li><a href="#125-%E5%A6%82%E4%BD%95%E8%AE%A2%E9%98%85%E6%9C%8D%E5%8A%A1%E5%8F%98%E6%9B%B4">12.5. 如何订阅服务变更</a></li>
<li><a href="#126-%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98">12.6. 注册与发现的几个问题</a></li>
</ul>
</li>
<li><a href="#13-%E5%BC%80%E6%BA%90%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B">13. 开源服务注册中心如何选型？</a></li>
<li><a href="#14-%E5%BC%80%E6%BA%90-rpc-%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B">14. 开源 RPC 框架如何选型？</a></li>
<li><a href="#15-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%9D%A0%E7%9A%84%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F">15. 如何搭建一个可靠的监控系统？</a></li>
<li><a href="#16-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F">16. 如何搭建一套适合你的服务追踪系统？</a></li>
<li><a href="#17-%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB">17. 如何识别服务节点是否存活？</a>
<ul>
<li><a href="#171-%E5%BF%83%E8%B7%B3%E5%BC%80%E5%85%B3%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">17.1. 心跳开关保护机制</a></li>
<li><a href="#172-%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E6%91%98%E9%99%A4%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">17.2. 服务节点摘除保护机制</a></li>
</ul>
</li>
<li><a href="#18-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">18. 如何使用负载均衡算法？</a>
<ul>
<li><a href="#181-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">18.1. 负载均衡算法</a></li>
</ul>
</li>
<li><a href="#19-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1">19. 如何使用服务路由？</a></li>
<li><a href="#20-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E6%97%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9">20. 服务端出现故障时该如何应对？</a></li>
<li><a href="#21-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E6%89%8B%E6%AE%B5">21. 服务调用失败时有哪些处理手段？</a></li>
<li><a href="#22-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE">22. 如何管理服务配置？</a></li>
<li><a href="#23-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0">23. 如何搭建微服务治理平台？</a></li>
<li><a href="#24-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AF%A5%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0">24. 微服务架构该如何落地？</a></li>
<li><a href="#25-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%B9%E5%99%A8%E5%8C%96">25. 微服务为什么要容器化？</a></li>
<li><a href="#26-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%92%8C%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6">26. 微服务容器化运维：镜像仓库和资源调度</a></li>
<li><a href="#27-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AE%B9%E5%99%A8%E8%B0%83%E5%BA%A6%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92">27. 微服务容器化运维：容器调度和服务编排</a></li>
<li><a href="#28-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%BE%AE%E5%8D%9A%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0-dcp">28. 微服务容器化运维：微博容器运维平台 DCP</a></li>
<li><a href="#29-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-devops">29. 微服务如何实现 DevOps？</a></li>
<li><a href="#30-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92">30. 如何做好微服务容量规划？</a></li>
<li><a href="#31-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%9A%E6%9C%BA%E6%88%BF%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5">31. 微服务多机房部署实践</a></li>
<li><a href="#32-%E5%A4%9A%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5">32. 多机房数据同步</a></li>
<li><a href="#33-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B7%B7%E5%90%88%E4%BA%91%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5">33. 微服务混合云部署实践</a>
<ul>
<li><a href="#331-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">33.1. 跨云服务的负载均衡</a></li>
<li><a href="#332-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5">33.2. 跨云服务的数据同步</a></li>
<li><a href="#333-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4">33.3. 跨云服务的容器运维</a></li>
</ul>
</li>
<li><a href="#34-%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-service-mesh">34. 下一代微服务架构 Service Mesh</a></li>
<li><a href="#35-service-mesh-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">35. Service Mesh 的实现原理</a></li>
<li><a href="#36-istioservice-mesh%E7%9A%84%E4%BB%A3%E8%A1%A8%E4%BA%A7%E5%93%81">36. Istio：Service Mesh 的代表产品</a>
<ul>
<li><a href="#361-istio-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">36.1. Istio 整体架构</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-到底什么是微服务"><a class="markdownIt-Anchor" href="#1-到底什么是微服务"></a> 1. 到底什么是微服务？</h2>
<blockquote>
<p>微服务定义</p>
<p>微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。</p>
<p>——Martin Fowler 和 James Lewis</p>
</blockquote>
<p>单体应用的问题</p>
<ul>
<li>部署效率低</li>
<li>团队协作开发成本高</li>
<li>单点故障问题</li>
<li>线上发布变慢</li>
</ul>
<p>服务化：本地方法调用 转为 远程方法调用（RPC）</p>
<p>微服务和服务化的差异：</p>
<ul>
<li>服务拆分粒度更细</li>
<li>服务独立部署、维护</li>
<li>服务治理要求高</li>
</ul>
<h2 id="2-从单体应用走向服务化"><a class="markdownIt-Anchor" href="#2-从单体应用走向服务化"></a> 2. 从单体应用走向服务化</h2>
<h3 id="21-什么时候进行服务化拆分"><a class="markdownIt-Anchor" href="#21-什么时候进行服务化拆分"></a> 2.1. 什么时候进行服务化拆分？</h3>
<p>经验：开发人员超过 10 人（沟通成本变高），就可以考虑服务化拆分</p>
<h3 id="22-服务化拆分的两种姿势"><a class="markdownIt-Anchor" href="#22-服务化拆分的两种姿势"></a> 2.2. 服务化拆分的两种姿势</h3>
<p><strong>纵向拆分</strong>，从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</p>
<p><strong>横向拆分</strong>，从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p>
<h3 id="23-服务化拆分的前置条件"><a class="markdownIt-Anchor" href="#23-服务化拆分的前置条件"></a> 2.3. 服务化拆分的前置条件</h3>
<ul>
<li><strong>服务如何定义</strong>。通过接口来约定。</li>
<li><strong>服务如何发布和订阅</strong>。通过服务注册和发现。</li>
<li><strong>服务如何监控</strong>。<strong>故障如何定位</strong>。服务化需要链路监控。</li>
<li><strong>服务如何治理</strong>。超时和重试、流量控制。</li>
</ul>
<h2 id="3-初探微服务架构"><a class="markdownIt-Anchor" href="#3-初探微服务架构"></a> 3. 初探微服务架构</h2>
<p>微服务通过注册中心，实现发布订阅模式。</p>
<p>服务调用主要依赖几个基本组件：</p>
<ul>
<li>服务描述：常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。
<ul>
<li>RESTful API 代表：Swagger</li>
<li>XML 代表：Dubbo</li>
<li>IDL 代表：Thrift、gRPC</li>
</ul>
</li>
<li>注册中心
<ul>
<li>服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。</li>
<li>服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。</li>
<li>注册中心返回服务提供者地址列表给服务消费者。</li>
<li>当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。</li>
</ul>
</li>
<li>服务框架
<ul>
<li>通信协议：选择 TCP、UDP、HTTP，还是其他？</li>
<li>数据传输方式：同步、异步、多路复用？</li>
<li>序列化方式：JDK 序列化、Json、二进制（Protobuf、Thrift）？</li>
</ul>
</li>
<li>服务监控
<ul>
<li>数据采集</li>
<li>数据处理</li>
<li>数据展示</li>
</ul>
</li>
<li>服务追踪</li>
<li>工作原理：通过 requestId、spanId 分别表示一次请求、请求中的某一环节</li>
<li>服务治理：
<ul>
<li>超时、重试</li>
<li>负载均衡</li>
<li>故障转移</li>
<li>流量控制</li>
</ul>
</li>
</ul>
<h2 id="4-如何发布和引用服务"><a class="markdownIt-Anchor" href="#4-如何发布和引用服务"></a> 4. 如何发布和引用服务？</h2>
<p><strong>RESTful API</strong>：主要被<strong>用作 HTTP 或者 HTTPS 协议的接口定义</strong>。代表：Eureka</p>
<p><strong>XML 配置</strong>：代表：Dubbo。工作步骤：</p>
<ul>
<li>服务提供者定义接口，并实现接口。</li>
<li>服务提供者进程启动时，通过加载 server.xml 配置文件将接口暴露出去。</li>
<li>服务消费者进程启动时，通过加载 client.xml 配置文件来引入要调用的接口。</li>
</ul>
<p>IDL 文件：IDL 就是接口描述语言（interface description language）的缩写。主要<strong>用作跨语言平台的服务之间的调用</strong>。有两种最常用的 IDL：Thrift、gRPC。</p>
<h2 id="5-如何注册和发现服务"><a class="markdownIt-Anchor" href="#5-如何注册和发现服务"></a> 5. 如何注册和发现服务？</h2>
<p>微服务架构下，主要有三种角色：</p>
<ul>
<li>服务提供者（RPC Server）</li>
<li>服务消费者（RPC Client）</li>
<li>服务注册中心（Registry）</li>
</ul>
<h3 id="51-注册中心实现方式"><a class="markdownIt-Anchor" href="#51-注册中心实现方式"></a> 5.1. 注册中心实现方式</h3>
<p>注册中心必须提供以下最基本的 API，例如：</p>
<ul>
<li>
<p>服务注册接口</p>
</li>
<li>
<p>服务注销接口</p>
</li>
<li>
<p>心跳汇报接口</p>
</li>
<li>
<p>服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</p>
</li>
<li>
<p>服务变更查询接口</p>
</li>
<li>
<p>服务查询接口</p>
</li>
<li>
<p>服务修改接口</p>
</li>
</ul>
<h3 id="52-集群部署"><a class="markdownIt-Anchor" href="#52-集群部署"></a> 5.2. 集群部署</h3>
<p>注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。</p>
<p>以 ZooKeeper 的工作原理为例：</p>
<ul>
<li>每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。</li>
<li>ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。</li>
<li>Leader 负责处理数据更新等操作（ZAB 协议）。</li>
<li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。</li>
</ul>
<h3 id="53-目录存储"><a class="markdownIt-Anchor" href="#53-目录存储"></a> 5.3. 目录存储</h3>
<p>注册中心存储服务信息一般采用层次化的目录结构：</p>
<ul>
<li>每个目录在 ZooKeeper 中叫作 znode，并且其有一个唯一的路径标识。</li>
<li>znode 可以包含数据和子 znode。</li>
<li>znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li>
</ul>
<h3 id="54-服务健康状态检测"><a class="markdownIt-Anchor" href="#54-服务健康状态检测"></a> 5.4. 服务健康状态检测</h3>
<p>ZooKeeper 客户端和服务端维持的是一个长连接。连接成功后，会生成一个全局唯一的 Session ID，客户端定期发送心跳消息，服务端收到后重置会话超时时间。如果超时，则认为连接结束。</p>
<p>如果一个服务将 ZooKeeper 作为服务注册中心，一旦连接超时，ZooKeeper 会认为这个服务节点已经不可用，就会将其信息删除。</p>
<h3 id="55-服务状态变更通知"><a class="markdownIt-Anchor" href="#55-服务状态变更通知"></a> 5.5. 服务状态变更通知</h3>
<p>ZooKeeper 支持 Watch 机制。服务消费者可以监听服务提供者的节点信息。一旦服务提供者的节点信息哟变化，就可以获取到变更状态。</p>
<h3 id="56-白名单机制"><a class="markdownIt-Anchor" href="#56-白名单机制"></a> 5.6. 白名单机制</h3>
<p>通常注册中心会有多套环境，区分开发、测试、线上等环境。如果弄错了，会出现意想不到的后果，为此需要引入白名单保护机制。只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p>
<h2 id="6-如何实现-rpc-远程服务调用"><a class="markdownIt-Anchor" href="#6-如何实现-rpc-远程服务调用"></a> 6. 如何实现 RPC 远程服务调用？</h2>
<p>客户端和服务端如何建立网络连接？</p>
<ul>
<li><strong>HTTP 通信</strong>：三次握手建立连接；四次挥手断开连接</li>
<li><strong>Socket 通信</strong>
<ul>
<li>服务器监听</li>
<li>客户端请求</li>
<li>连接确认</li>
<li>数据传输</li>
</ul>
</li>
</ul>
<p>服务端如何处理请求？</p>
<ul>
<li>BIO</li>
<li>NIO</li>
<li>AIO</li>
</ul>
<p>数据传输采用什么协议？</p>
<ul>
<li>Http</li>
<li>Dubbo</li>
</ul>
<p>数据该如何序列化和反序列化？</p>
<ul>
<li>JDK</li>
<li>JSON</li>
<li>二进制（PB、Thrift 等）</li>
</ul>
<h2 id="7-如何监控微服务调用"><a class="markdownIt-Anchor" href="#7-如何监控微服务调用"></a> 7. 如何监控微服务调用？</h2>
<p>监控对象</p>
<ul>
<li>客户端监控</li>
<li>接口监控</li>
<li>资源监控</li>
<li>基础监控</li>
</ul>
<p>监控指标</p>
<ul>
<li>请求量</li>
<li>响应时间</li>
<li>错误率</li>
</ul>
<p>监控维度</p>
<ul>
<li>全局维度</li>
<li>机房维度</li>
<li>单机维度</li>
<li>时间维度</li>
<li>重要性维度</li>
</ul>
<p>监控关键点</p>
<ul>
<li>数据采集
<ul>
<li>主动上报</li>
<li>代理收集</li>
</ul>
</li>
<li>数据传输
<ul>
<li>UDP</li>
<li>Kafka</li>
</ul>
</li>
<li>数据处理
<ul>
<li>全文检索：如 Elasticsearch</li>
<li>时序数据库：如 InfluxDB、OpenTSDB</li>
<li>流计算：如 Spark、Storm、Flink</li>
</ul>
</li>
<li>数据展示</li>
</ul>
<h2 id="8-如何追踪微服务调用"><a class="markdownIt-Anchor" href="#8-如何追踪微服务调用"></a> 8. 如何追踪微服务调用？</h2>
<h3 id="81-服务追踪的作用"><a class="markdownIt-Anchor" href="#81-服务追踪的作用"></a> 8.1. 服务追踪的作用</h3>
<ul>
<li>定位整个系统的瓶颈点</li>
<li>优化链路调用</li>
<li>生成网络拓扑</li>
<li>透明传输数据</li>
</ul>
<h3 id="82-服务追踪系统原理"><a class="markdownIt-Anchor" href="#82-服务追踪系统原理"></a> 8.2. 服务追踪系统原理</h3>
<p>经典论文：<a href="http://bigbully.github.io/Dapper-translation/"><code>Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</code></a></p>
<ul>
<li><strong>traceId</strong>，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。</li>
<li><strong>spanId</strong>，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li>
<li><strong>annotation</strong>，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。</li>
</ul>
<h3 id="83-服务追踪系统实现"><a class="markdownIt-Anchor" href="#83-服务追踪系统实现"></a> 8.3. 服务追踪系统实现</h3>
<p>服务追踪系统可以分为三层。</p>
<ul>
<li>数据采集层，负责数据埋点并上报。</li>
<li>数据处理层，负责数据的存储与计算。</li>
<li>数据展示层，负责数据的图形化展示。</li>
</ul>
<h2 id="9-微服务治理的手段有哪些"><a class="markdownIt-Anchor" href="#9-微服务治理的手段有哪些"></a> 9. 微服务治理的手段有哪些？</h2>
<p>服务调用失败原因：</p>
<ul>
<li>服务提供者自身问题，如宕机、进程退出等；</li>
<li>网络问题</li>
</ul>
<h3 id="91-节点管理"><a class="markdownIt-Anchor" href="#91-节点管理"></a> 9.1. 节点管理</h3>
<ul>
<li><strong>注册中心主动摘除机制</strong>：服务提供者定时发送心跳，如果超时，注册中心把节点从服务列表中删除</li>
<li><strong>服务消费者摘除机制</strong>：如果服务消费者调用服务提供者节点失败，就将这个节点从内存中保存的可用服务提供者节点列表中移除。</li>
</ul>
<h3 id="92-负载均衡"><a class="markdownIt-Anchor" href="#92-负载均衡"></a> 9.2. 负载均衡</h3>
<ul>
<li>随机算法</li>
<li>轮询算法</li>
<li>最少活跃调用算法</li>
<li>一致性 Hash 算法</li>
</ul>
<h3 id="93-服务路由"><a class="markdownIt-Anchor" href="#93-服务路由"></a> 9.3. 服务路由</h3>
<p>为什么要制定路由规则呢？</p>
<ul>
<li>业务存在灰度发布的需求</li>
<li>多机房就近访问的需求</li>
</ul>
<p>如何配置路由规则</p>
<ul>
<li>静态配置：修改服务消费者本地配置，上线后生效</li>
<li>动态配置：修改注册中心的配置，服务消费者在下一个同步周期之后，就会动态更新</li>
</ul>
<h3 id="94-服务容错"><a class="markdownIt-Anchor" href="#94-服务容错"></a> 9.4. 服务容错</h3>
<ul>
<li>FailOver：失败自动切换。</li>
<li>FailBack：失败通知。</li>
<li>FailCache：失败缓存。</li>
<li>FailFast：快速失败。</li>
</ul>
<p>一般情况下对于幂等的调用，可以选择 FailOver 或者 FailCache，非幂等的调用可以选择 FailBack 或者 FailFast。</p>
<h2 id="10-dubbo-框架里的微服务组件"><a class="markdownIt-Anchor" href="#10-dubbo-框架里的微服务组件"></a> 10. Dubbo 框架里的微服务组件</h2>
<h2 id="11-服务发布和引用的实践"><a class="markdownIt-Anchor" href="#11-服务发布和引用的实践"></a> 11. 服务发布和引用的实践</h2>
<p>XML 配置方式的服务发布和引用流程</p>
<ul>
<li>服务提供者定义接口</li>
<li>服务提供者发布接口</li>
<li>服务消费者引用接口</li>
</ul>
<p>服务发布和引用的那些坑</p>
<h2 id="12-如何将注册中心落地"><a class="markdownIt-Anchor" href="#12-如何将注册中心落地"></a> 12. 如何将注册中心落地？</h2>
<p>注册中心如何存储服务信息</p>
<p>服务一般会分成多个不同的分组</p>
<ul>
<li>核心与非核心，从业务的核心程度来分。</li>
<li>机房，从机房的维度来分。</li>
<li>线上环境与测试环境，从业务场景维度来区分。</li>
</ul>
<p>所以注册中心存储的服务信息一般包含三部分内容：<strong>分组</strong>、<strong>服务名</strong>以及<strong>节点信息</strong>，节点信息又包括节点地址和节点其他信息。</p>
<h3 id="121-注册中心工作流程"><a class="markdownIt-Anchor" href="#121-注册中心工作流程"></a> 12.1. 注册中心工作流程</h3>
<ul>
<li>服务提供者注册流程。</li>
<li>服务提供者反注册流程。</li>
<li>服务消费者查询流程。</li>
<li>服务消费者订阅变更流程。</li>
</ul>
<h3 id="122-如何注册节点"><a class="markdownIt-Anchor" href="#122-如何注册节点"></a> 12.2. 如何注册节点</h3>
<ul>
<li>首先查看要注册的节点是否在白名单内？如果不在就抛出异常，在的话继续下一步。</li>
<li>其次要查看注册的 Cluster（服务的接口名）是否存在？如果不存在就抛出异常，存在的话继续下一步。</li>
<li>然后要检查 Service（服务的分组）是否存在？如果不存在则抛出异常，存在的话继续下一步。</li>
<li>最后将节点信息添加到对应的 Service 和 Cluster 下面的存储中。</li>
</ul>
<h3 id="123-如何反注册"><a class="markdownIt-Anchor" href="#123-如何反注册"></a> 12.3. 如何反注册</h3>
<ul>
<li>查看 Service（服务的分组）是否存在，不存在就抛出异常，存在就继续下一步。</li>
<li>查看 Cluster（服务的接口名）是否存在，不存在就抛出异常，存在就继续下一步。</li>
<li>删除存储中 Service 和 Cluster 下对应的节点信息。</li>
<li>更新 Cluster 的 sign 值。</li>
</ul>
<h3 id="124-如何查询节点信息"><a class="markdownIt-Anchor" href="#124-如何查询节点信息"></a> 12.4. 如何查询节点信息</h3>
<p>首先从 localcache（本机内存）中查找，如果没有就继续下一步。</p>
<p>接着从 snapshot（本地快照）中查找，如果没有就继续下一步。</p>
<h3 id="125-如何订阅服务变更"><a class="markdownIt-Anchor" href="#125-如何订阅服务变更"></a> 12.5. 如何订阅服务变更</h3>
<ul>
<li>服务消费者从注册中心获取了服务的信息后，就订阅了服务的变化，会在本地保留 Cluster 的 sign 值。</li>
<li>服务消费者每隔一段时间，调用 getSign() 函数，从注册中心获取服务端该 Cluster 的 sign 值，并与本地保留的 sign 值做对比，如果不一致，就从服务端拉取新的节点信息，并更新 localcache 和 snapshot。</li>
</ul>
<h3 id="126-注册与发现的几个问题"><a class="markdownIt-Anchor" href="#126-注册与发现的几个问题"></a> 12.6. 注册与发现的几个问题</h3>
<ul>
<li>
<p>多注册中心</p>
</li>
<li>
<p>并行订阅服务</p>
</li>
<li>
<p>批量反注册服务</p>
</li>
<li>
<p>服务变更信息增量更新</p>
</li>
</ul>
<h2 id="13-开源服务注册中心如何选型"><a class="markdownIt-Anchor" href="#13-开源服务注册中心如何选型"></a> 13. 开源服务注册中心如何选型？</h2>
<ul>
<li><strong>应用内注册与发现</strong>：注册中心提供服务端和客户端的 SDK，业务应用通过引入注册中心提供的 SDK，通过 SDK 与注册中心交互，来实现服务的注册和发现。典型代表：Eureka</li>
<li><strong>应用外注册与发现</strong>：业务应用本身不需要通过 SDK 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。典型代表：Consul</li>
</ul>
<p>二者对比：</p>
<ul>
<li>用内的解决方案一般适用于服务提供者和服务消费者同属于一个技术体系；</li>
<li>应用外的解决方案一般适合服务提供者和服务消费者采用了不同技术体系的业务场景</li>
</ul>
<p>注册中心选型要考虑的两个问题</p>
<ul>
<li>高可用性</li>
<li>数据一致性
<ul>
<li>CP 型：牺牲可用性来保证数据强一致性。代表：ZooKeeper、Etcd、Consul</li>
<li>AP 型：代表：Eureka、Nacos</li>
</ul>
</li>
</ul>
<p>而对于注册中心来说，最主要的功能是服务的注册和发现，在网络出现问题的时候，可用性的需求要远远高于数据一致性。即使因为数据不一致，注册中心内引入了不可用的服务节点，也可以通过其他措施来避免，比如客户端的快速失败机制等，只要实现最终一致性，对于注册中心来说就足够了。因此，选择 AP 型注册中心，一般更加合适。</p>
<h2 id="14-开源-rpc-框架如何选型"><a class="markdownIt-Anchor" href="#14-开源-rpc-框架如何选型"></a> 14. 开源 RPC 框架如何选型？</h2>
<p>限定语言 RPC</p>
<ul>
<li>Dubbo：仅支持 Java</li>
<li>Motan：仅支持 Java</li>
<li>Tars：仅支持 C++</li>
<li>Spring Cloud：仅支持 Java</li>
</ul>
<p>跨语言 RPC</p>
<ul>
<li>gRPC：支持 C++、Java、Python、Go、Ruby、PHP、Android Java、Objective-C 等多种语言</li>
<li>Thrift：支持 C++、Java、PHP、Python、Ruby、Erlang 等多种语言</li>
</ul>
<h2 id="15-如何搭建一个可靠的监控系统"><a class="markdownIt-Anchor" href="#15-如何搭建一个可靠的监控系统"></a> 15. 如何搭建一个可靠的监控系统？</h2>
<p>日志解决方案：<a href="https://www.elastic.co/cn/">ELK</a></p>
<p>时序数据库解决方案：<a href="http://graphite.readthedocs.io/en/latest/index.html">Graphite</a>、<a href="https://www.influxdata.com/time-series-platform/">TICK</a>和<a href="https://prometheus.io/">Prometheus</a></p>
<h2 id="16-如何搭建一套适合你的服务追踪系统"><a class="markdownIt-Anchor" href="#16-如何搭建一套适合你的服务追踪系统"></a> 16. 如何搭建一套适合你的服务追踪系统？</h2>
<p>代表：Zipkin、PinPoint</p>
<h2 id="17-如何识别服务节点是否存活"><a class="markdownIt-Anchor" href="#17-如何识别服务节点是否存活"></a> 17. 如何识别服务节点是否存活？</h2>
<h3 id="171-心跳开关保护机制"><a class="markdownIt-Anchor" href="#171-心跳开关保护机制"></a> 17.1. 心跳开关保护机制</h3>
<p>问题：服务消费者同时并发访问注册中心获取最新服务信息导致注册中心带宽被打满</p>
<p>方案：需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。</p>
<h3 id="172-服务节点摘除保护机制"><a class="markdownIt-Anchor" href="#172-服务节点摘除保护机制"></a> 17.2. 服务节点摘除保护机制</h3>
<p>问题：服务提供者节点被大量摘除导致服务消费者没有足够的节点可以调用</p>
<p>方案：需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。</p>
<p>静态注册中心</p>
<h2 id="18-如何使用负载均衡算法"><a class="markdownIt-Anchor" href="#18-如何使用负载均衡算法"></a> 18. 如何使用负载均衡算法？</h2>
<h3 id="181-负载均衡算法"><a class="markdownIt-Anchor" href="#181-负载均衡算法"></a> 18.1. 负载均衡算法</h3>
<ul>
<li>
<p><strong>随机算法</strong></p>
</li>
<li>
<p><strong>轮询算法</strong></p>
</li>
<li>
<p><strong>加权轮询算法</strong></p>
</li>
<li>
<p><strong>最少活跃连接算法</strong></p>
</li>
<li>
<p><strong>一致性 hash 算法</strong></p>
</li>
</ul>
<h2 id="19-如何使用服务路由"><a class="markdownIt-Anchor" href="#19-如何使用服务路由"></a> 19. 如何使用服务路由？</h2>
<p><strong>服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求</strong>。</p>
<p>服务路由的应用场景</p>
<ul>
<li><strong>分组调用</strong></li>
<li><strong>灰度发布</strong></li>
<li><strong>流量切换</strong></li>
<li><strong>读写分离</strong></li>
</ul>
<p>服务路由的规则</p>
<ul>
<li>条件路由
<ul>
<li>排除某个服务节点</li>
<li>白名单和黑名单功能</li>
<li>机房隔离</li>
<li>读写分离</li>
</ul>
</li>
<li>脚本路由</li>
</ul>
<p>服务路由的获取方式</p>
<ul>
<li>本地配置</li>
<li>配置中心管理</li>
<li>动态下发</li>
</ul>
<h2 id="20-服务端出现故障时该如何应对"><a class="markdownIt-Anchor" href="#20-服务端出现故障时该如何应对"></a> 20. 服务端出现故障时该如何应对？</h2>
<p>微服务故障种类</p>
<ul>
<li>集群故障。解决：流量控制
<ul>
<li>限流</li>
<li>降级</li>
</ul>
</li>
<li>单 IDC 故障。解决：多 IDC 部署、流量切换
<ul>
<li>多 IDC 部署
<ul>
<li>同城多活</li>
<li>异地多活</li>
</ul>
</li>
<li>流量切换
<ul>
<li>DNS 解析流量切换</li>
<li>RPC 流量切换</li>
</ul>
</li>
</ul>
</li>
<li>单机故障</li>
</ul>
<h2 id="21-服务调用失败时有哪些处理手段"><a class="markdownIt-Anchor" href="#21-服务调用失败时有哪些处理手段"></a> 21. 服务调用失败时有哪些处理手段？</h2>
<p>超时</p>
<p>重试</p>
<p>流量控制</p>
<h2 id="22-如何管理服务配置"><a class="markdownIt-Anchor" href="#22-如何管理服务配置"></a> 22. 如何管理服务配置？</h2>
<p>配置类型：</p>
<ul>
<li>本地配置</li>
<li>配置中心</li>
</ul>
<p>配置中心代表：</p>
<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-config">Spring Cloud Config</a></li>
<li><a href="https://github.com/ctripcorp/apollo">Apollo</a></li>
</ul>
<h2 id="23-如何搭建微服务治理平台"><a class="markdownIt-Anchor" href="#23-如何搭建微服务治理平台"></a> 23. 如何搭建微服务治理平台？</h2>
<p>服务管理</p>
<ul>
<li>服务上下线</li>
<li>节点添加 / 删除</li>
<li>服务查询</li>
<li>服务节点查询。这个操作会调用注册中心的节点查询接口，来查询某个服务下一共有多少个节点。</li>
</ul>
<p>服务治理</p>
<ul>
<li>限流</li>
<li>降级</li>
<li>切流量</li>
</ul>
<p>服务监控</p>
<p>问题定位</p>
<p>日志查询</p>
<p>服务运维</p>
<ul>
<li>发布部署</li>
<li>弹性伸缩</li>
</ul>
<h2 id="24-微服务架构该如何落地"><a class="markdownIt-Anchor" href="#24-微服务架构该如何落地"></a> 24. 微服务架构该如何落地？</h2>
<p>（略）</p>
<h2 id="25-微服务为什么要容器化"><a class="markdownIt-Anchor" href="#25-微服务为什么要容器化"></a> 25. 微服务为什么要容器化？</h2>
<p>微服务引入的问题</p>
<p>设计复杂</p>
<p>测试复杂</p>
<p>运维困难</p>
<h2 id="26-微服务容器化运维镜像仓库和资源调度"><a class="markdownIt-Anchor" href="#26-微服务容器化运维镜像仓库和资源调度"></a> 26. 微服务容器化运维：镜像仓库和资源调度</h2>
<p>容器运维平台的组成部分</p>
<ul>
<li>镜像仓库</li>
<li>资源调度</li>
<li>容器调度</li>
<li>服务编排</li>
</ul>
<h2 id="27-微服务容器化运维容器调度和服务编排"><a class="markdownIt-Anchor" href="#27-微服务容器化运维容器调度和服务编排"></a> 27. 微服务容器化运维：容器调度和服务编排</h2>
<p>容器调度系统代表：<a href="https://docs.docker.com/engine/swarm/">Swarm</a>、<a href="http://mesos.apache.org/">Mesos</a>，<a href="https://kubernetes.io/">Kubernetes</a></p>
<p>容器调度要解决的问题</p>
<ul>
<li><strong>主机过滤</strong>
<ul>
<li>存活过滤</li>
<li>硬件过滤</li>
</ul>
</li>
<li><strong>调度策略</strong></li>
<li><strong>服务编排</strong></li>
<li><strong>服务依赖</strong>：代表方案：<a href="https://github.com/docker/compose">Docker Compose</a></li>
<li><strong>服务发现</strong>
<ul>
<li>基于 Nginx 的服务发现</li>
<li>基于注册中心的服务发现</li>
<li>弹性伸缩</li>
</ul>
</li>
</ul>
<h2 id="28-微服务容器化运维微博容器运维平台-dcp"><a class="markdownIt-Anchor" href="#28-微服务容器化运维微博容器运维平台-dcp"></a> 28. 微服务容器化运维：微博容器运维平台 DCP</h2>
<h2 id="29-微服务如何实现-devops"><a class="markdownIt-Anchor" href="#29-微服务如何实现-devops"></a> 29. 微服务如何实现 DevOps？</h2>
<ul>
<li><strong>CI（Continuous Integration）</strong>，持续集成。开发完成代码开发后，能自动地进行代码检查、单元测试、打包部署到测试环境，进行集成测试，跑自动化测试用例。
<ul>
<li>代码检查</li>
<li>单元测试</li>
<li>集成测试</li>
</ul>
</li>
<li><strong>CD（Continuous Deploy）</strong>，持续部署。代码测试通过后，能自动部署到类生产环境中进行集成测试，测试通过后再进行小流量的灰度验证，验证通过后代码就达到线上发布的要求了，就可以把代码自动部署到线上。</li>
</ul>
<h2 id="30-如何做好微服务容量规划"><a class="markdownIt-Anchor" href="#30-如何做好微服务容量规划"></a> 30. 如何做好微服务容量规划？</h2>
<p>微服务容量规划的问题</p>
<ul>
<li>服务数量众多</li>
<li>服务的接口表现差异巨大</li>
<li>服务部署的集群规模大小不同</li>
<li>服务之间还存在依赖关系</li>
</ul>
<p>容量规划系统的作用是<strong>根据各个微服务部署集群的最大容量和线上实际运行的负荷，来决定各个微服务是否需要弹性扩缩容，以及需要扩缩容多少台机器</strong>。</p>
<p>容量规划系统实施的关键在于两点：</p>
<ul>
<li>容量评估
<ul>
<li>选择合适的压测指标
<ul>
<li>系统类指标：CPU、内存、I/O、带宽等</li>
<li>服务类指标：响应时间、P999 耗时、错误率等</li>
</ul>
</li>
<li>压测获取单机的最大容量
<ul>
<li>单机压测
<ul>
<li>通过日志回放等手段，模拟线上流量来对单机进行压测；</li>
<li>通过 TCP-Copy 的方式，把线上机器的流量拷贝过来对单机进行压测。</li>
</ul>
</li>
<li>集群压测</li>
</ul>
</li>
<li>实时和获取集群的运行负荷</li>
</ul>
</li>
<li>调度决策
<ul>
<li>可以使用<strong>水位线</strong>来进行调度决策：当集群的水位线位于致命线以下时，就需要立即扩容，在扩容一定数量的机器后，水位线回到安全线以上并保持一段时间后，就可以进行缩容了。</li>
<li>扩容
<ul>
<li>按数量</li>
<li>按比例</li>
</ul>
</li>
<li>缩容</li>
<li>逐步缩容</li>
<li>为了避免因扩容、缩容导致的水位线抖动，可以多次采集水位线数据，超过 60% 数据满足库哦哦让条件，才真正触发扩容。</li>
</ul>
</li>
</ul>
<h2 id="31-微服务多机房部署实践"><a class="markdownIt-Anchor" href="#31-微服务多机房部署实践"></a> 31. 微服务多机房部署实践</h2>
<p>多机房负载均衡：利用七层负载均衡和四层负载均衡，将流量根据用户就近访问的原则切分流量。</p>
<h2 id="32-多机房数据同步"><a class="markdownIt-Anchor" href="#32-多机房数据同步"></a> 32. 多机房数据同步</h2>
<h4 id="主从机房架构"><a class="markdownIt-Anchor" href="#主从机房架构"></a> 主从机房架构</h4>
<ul>
<li>由主机房的处理机来更新本机房的缓存和数据库</li>
<li>其他机房的缓存也通过主机房的处理机来更新</li>
<li>从机房的数据库则通过 MySQL 的 binlog 同步主机房的数据。</li>
</ul>
<h4 id="独立机房架构"><a class="markdownIt-Anchor" href="#独立机房架构"></a> 独立机房架构</h4>
<ul>
<li>每个机房的处理机接收到写请求后更新各自机房的缓存</li>
<li>只有主机房会更新数据库</li>
<li>从机房的数据库则通过 MySQL 的 binlog 同步主机房的数据。</li>
</ul>
<p>WMB 消息同步组件的功能就是把一个机房的写请求发给另外一个机房</p>
<ul>
<li>reship，负责把本机房的写请求分发一份给别的机房。</li>
<li>collector，负责从别的机房读取写请求，然后再把请求转发给本机房的处理机。</li>
</ul>
<p>实现 WMB 的消息同步功能有两种方案：</p>
<ul>
<li>MQ：两个机房的 MQ 通过维护状态机来读写请求</li>
<li>RPC</li>
</ul>
<h4 id="多机房数据一致性"><a class="markdownIt-Anchor" href="#多机房数据一致性"></a> 多机房数据一致性</h4>
<h2 id="33-微服务混合云部署实践"><a class="markdownIt-Anchor" href="#33-微服务混合云部署实践"></a> 33. 微服务混合云部署实践</h2>
<h3 id="331-跨云服务的负载均衡"><a class="markdownIt-Anchor" href="#331-跨云服务的负载均衡"></a> 33.1. 跨云服务的负载均衡</h3>
<p>当服务上云后还需要考虑把一定比例的用户请求路由到云上部署的服务</p>
<h3 id="332-跨云服务的数据同步"><a class="markdownIt-Anchor" href="#332-跨云服务的数据同步"></a> 33.2. 跨云服务的数据同步</h3>
<p>私有云与公有云之间的网络隔离</p>
<p>一般来讲，出于安全的需要，企业内部机房同公有云机房之间的网络是隔离的，为了实现互通，需要架设专门的 VPN 网络或者专线。</p>
<p>数据库能否上云</p>
<p>数据库能否上云的关键取决于数据的隐私性。</p>
<h3 id="333-跨云服务的容器运维"><a class="markdownIt-Anchor" href="#333-跨云服务的容器运维"></a> 33.3. 跨云服务的容器运维</h3>
<p>跨云的主机管理：跨云主机管理的关键点在于，如何对内部私有云的机器和公有云的 ECS 进行管理，</p>
<p>跨云服务发现</p>
<p>跨云弹性扩容</p>
<p>跨云服务编排</p>
<h2 id="34-下一代微服务架构-service-mesh"><a class="markdownIt-Anchor" href="#34-下一代微服务架构-service-mesh"></a> 34. 下一代微服务架构 Service Mesh</h2>
<p>为什么需要 Service Mesh</p>
<ul>
<li>
<p>跨语言服务调用的需要</p>
</li>
<li>
<p>云原生应用服务治理的需要</p>
</li>
</ul>
<h2 id="35-service-mesh-的实现原理"><a class="markdownIt-Anchor" href="#35-service-mesh-的实现原理"></a> 35. Service Mesh 的实现原理</h2>
<p>Service Mesh 实现的关键点：</p>
<ul>
<li>轻量级网络代理 SideCar，它的作用就是转发服务之间的调用；</li>
<li>基于 SideCar 的服务治理也被叫作 Control Plane，它的作用是向 SideCar 发送各种指令，以完成各种服务治理功能。</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>请求路由</li>
<li>故障处理</li>
<li>安全认证</li>
<li>监控上报</li>
<li>日志记录</li>
<li>配额控制</li>
</ul>
<h2 id="36-istioservice-mesh-的代表产品"><a class="markdownIt-Anchor" href="#36-istioservice-mesh-的代表产品"></a> 36. Istio：Service Mesh 的代表产品</h2>
<h3 id="361-istio-整体架构"><a class="markdownIt-Anchor" href="#361-istio-整体架构"></a> 36.1. Istio 整体架构</h3>
<p>Istio 的架构可以说由两部分组成，分别是 Proxy 和 Control Plane。</p>
<ul>
<li>Proxy，就是前面提到的 SideCar，与应用程序部署在同一个主机上，应用程序之间的调用都通过 Proxy 来转发，目前支持 HTTP/1.1、HTTP/2、gRPC 以及 TCP 请求。</li>
<li>Control Plane，与 Proxy 通信，来实现各种服务治理功能，包括三个基本组件：Pilot、Mixer 以及 Citadel。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>左耳听风学习笔记</title>
    <url>/note/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="左耳听风学习笔记"><a class="markdownIt-Anchor" href="#左耳听风学习笔记"></a> 左耳听风学习笔记</h1>
<h2 id="洞悉技术的本质"><a class="markdownIt-Anchor" href="#洞悉技术的本质"></a> 洞悉技术的本质</h2>
<h2 id="分布式系统架构的本质"><a class="markdownIt-Anchor" href="#分布式系统架构的本质"></a> 分布式系统架构的本质</h2>
<p>分布式系统架构的优点：</p>
<ul>
<li>高性能</li>
<li>高可用</li>
</ul>
<p>分布式系统架构的缺点：</p>
<ul>
<li>设计复杂</li>
<li>运维复杂</li>
</ul>
<p>分布式系统的技术栈</p>
<p>提高性能的技术</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>异步</li>
<li>分片</li>
</ul>
<p>提供可用性的技术</p>
<ul>
<li>服务拆分</li>
<li>服务冗余</li>
<li>流量控制</li>
<li>高可用架构：多租户、多活架构、灾备</li>
<li>高可用运维：监控、DevOps</li>
</ul>
<p>分布式系统的关键技术</p>
<ul>
<li>服务治理</li>
<li>服务、资源调度</li>
<li>DevOps</li>
<li>监控</li>
</ul>
<h2 id="编程范式游记"><a class="markdownIt-Anchor" href="#编程范式游记"></a> 编程范式游记</h2>
<h2 id="分布式系统设计模式"><a class="markdownIt-Anchor" href="#分布式系统设计模式"></a> 分布式系统设计模式</h2>
<h2 id="区块链"><a class="markdownIt-Anchor" href="#区块链"></a> 区块链</h2>
<h2 id="程序员练级攻略"><a class="markdownIt-Anchor" href="#程序员练级攻略"></a> 程序员练级攻略</h2>
<h2 id="面试攻略"><a class="markdownIt-Anchor" href="#面试攻略"></a> 面试攻略</h2>
<h2 id="高效学习"><a class="markdownIt-Anchor" href="#高效学习"></a> 高效学习</h2>
<p>浅度学习和深度学习</p>
<ul>
<li><strong>高质量的信息源和第一手的知识</strong>。</li>
<li><strong>把知识连成地图，将自己的理解反述出来</strong>。</li>
<li><strong>不断地反思和思辨，与不同年龄段的人讨论</strong>。</li>
<li><strong>举一反三，并践行之，把知识转换成技能</strong>。</li>
</ul>
<p>深度，归纳和坚持实践</p>
<ol>
<li><strong>这个技术出现的背景、初衷和目标</strong>。</li>
<li><strong>这个技术的优势和劣势分别是什么</strong></li>
<li><strong>这个技术适用的场景</strong></li>
<li><strong>技术的组成部分和关键点</strong>。</li>
<li><strong>技术的底层原理和关键实现</strong>。</li>
<li><strong>已有的实现和它之间的对比</strong>。</li>
</ol>
<h2 id="高效沟通"><a class="markdownIt-Anchor" href="#高效沟通"></a> 高效沟通</h2>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据密集型应用系统设计</title>
    <url>/note/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="数据复制"><a class="markdownIt-Anchor" href="#数据复制"></a> 数据复制</h2>
<p>复制主要指通过互联网络在多台机器上保存相同数据的副本。</p>
<p>数据复制的作用：</p>
<ul>
<li>使数据在地理位置上更接近用户，从而<strong>降低访问延迟</strong>。</li>
<li>当部分组件出现位障，系统依然可以继续工作，从而<strong>提高可用性</strong>。</li>
<li>扩展至多台机器以同时提供数据访问服务，从而<strong>提高读吞吐量</strong>。</li>
</ul>
<span id="more"></span>
<p>复制方式：</p>
<ul>
<li>主从复制</li>
<li>多主节点复制</li>
<li>无主节点复制</li>
</ul>
<p>复制需要考虑的问题：</p>
<ul>
<li>同步还是异步</li>
<li>如何处理失败的副本</li>
<li>如何保证数据一致</li>
</ul>
<h3 id="主节点与从节点"><a class="markdownIt-Anchor" href="#主节点与从节点"></a> 主节点与从节点</h3>
<p>每个保存数据库完整数据集的节点称之为副本。</p>
<p>主从复制的工作原理如下：</p>
<ol>
<li>指定某一个副本为主副本（或称为主节点） 。当客户写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储。</li>
<li>其他副本则全部称为从副本（或称为从节点）。主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。</li>
<li>客户端从数据库中读数据时，可以在主副本或者从副本上执行查询。再次强调，只有主副本才可以接受写请求：从客户端的角度来看，从副本都是只读的。</li>
</ol>
<p>许多关系型数据库都内置支持主从复制，例如 PostgreSQL (9.0 版本以后）、MySQL 、Oracle Data Guard 和 SQL Server 的 AlwaysOn Availabilitiy Groups 。而一些非关系数据库如 MongoDB 、RethinkDB 和 Espresso 也支持主从复制。另外， 主从复制技术也不仅限于数据库，还广泛用于分布式悄息队列如 Kafka 和 RabbitMQ。</p>
<h3 id="同步复制与异步复制"><a class="markdownIt-Anchor" href="#同步复制与异步复制"></a> 同步复制与异步复制</h3>
<ul>
<li><strong>同步复制的优点</strong>： 一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。</li>
<li><strong>同步复制的缺点</strong>：如果同步的从节点无法完成确认（例如由于从节点发生崩愤，或者网络故障，或任何其他原因）， 写入就不能视为成功。主节点会阻塞其后所有的写操作，直到同步副本确认完成。</li>
</ul>
<p>因此，把所有从节点都配置为同步复制有些不切实际。因为这样的话，任何一个同步节点的中断都会导致整个系统更新停滞不前。</p>
<ul>
<li><strong>异步复制的优点</strong>：不管从节点上数据多么滞后， 主节点总是可以继续响应写请求，系统的吞吐性能更好。</li>
<li><strong>异步复制的缺点</strong>：如果主节点发生失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。</li>
</ul>
<h3 id="配置新的从节点"><a class="markdownIt-Anchor" href="#配置新的从节点"></a> 配置新的从节点</h3>
<ol>
<li>在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。目前大多数数据库都支持此功能，快照也是系统备份所必需的。而在某些情况下，可能需要第三方工具， 如 MySQL 的 innobackupex。</li>
<li>将此快照拷贝到新的从节点。</li>
<li>从节点连接到主节点并请求快照点之后所发生的数据更改日志。因为在第一步创建快照时，快照与系统复制日志的某个确定位置相关联，这个位置信息在不同的系统有不同的称呼，如 PostgreSQL 将其称为“ log sequence number” （日志序列号），而 MySQL 将其称为“ binlog coordinates ” 。</li>
<li>获得日志之后，从节点来应用这些快照点之后所有数据变更，这个过程称之为追赶。接下来，它可以继续处理主节点上新的数据变化。井重复步骤 1 ～步骤 4 。</li>
</ol>
<p>建立新的从副本具体操作步骤可能因数据库系统而异。</p>
<h3 id="处理节点失效"><a class="markdownIt-Anchor" href="#处理节点失效"></a> 处理节点失效</h3>
<p>如何通过主从复制技术来实现系统高可用呢？</p>
<h4 id="从节点失效-追赶式恢复"><a class="markdownIt-Anchor" href="#从节点失效-追赶式恢复"></a> 从节点失效： 追赶式恢复</h4>
<p>从节点的本地磁盘上都保存了副本收到的数据变更日志。如果从节点发生崩溃，然后顺利重启，或者主从节点之间的网络发生暂时中断（闪断），则恢复比较容易，根据副本的复制日志，从节点可以知道在发生故障之前所处理的最后一笔事务，然后连接到主节点，并请求自那笔事务之后中断期间内所有的数据变更。在收到这些数据变更日志之后，将其应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点数据流的变化。</p>
<h4 id="主节点失效节点切换"><a class="markdownIt-Anchor" href="#主节点失效节点切换"></a> 主节点失效：节点切换</h4>
<p>选择某个从节点将其提升为主节点；客户端也需要更新，这样之后的写请求会发送给新的主节点，然后其他从节点要接受来自新的主节点上的变更数据，这一过程称之为切换。</p>
<p>步骤通常如下：</p>
<ol>
<li><strong>确认主节点失效</strong>。有很多种出错可能性，所以大多数系统都采用了基于超时的机制：节点间频繁地互相发生发送心跳悄息，如果发现某一个节点在一段比较长时间内（例如 30s ）没有响应，即认为该节点发生失效。</li>
<li><strong>选举新的主节点</strong>。可以通过选举的方式（超过多数的节点达成共识）来选举新的主节点，或者由之前选定的某控制节点来指定新的主节点。候选节点最好与原主节点的数据差异最小，这样可以最小化数据丢失的风险。让所有节点同意新的主节点是个典型的共识问题。</li>
<li><strong>重新配置系统使新主节点生效</strong>。客户端现在需要将写请求发送给新的主节点。如果原主节点之后重新上线，可能仍然自认为是主节点，而没有意识到其他节点已经达成共识迫使其下台。这时系统要确保原主节点降级为从节点，并认可新的主节点。</li>
</ol>
<p>上述切换过程依然充满了很多变数：</p>
<ul>
<li>如果使用了异步复制，且失效之前，新的主节点并未收到原主节点的所有数据；在选举之后，原主节点很快又重新上线并加入到集群，接下来的写操作会发生什么？新的主节点很可能会收到冲突的写请求，这是因为原主节点未意识的角色变化，还会尝试同步其他从节点，但其中的一个现在已经接管成为现任主节点。常见的解决方案是，原主节点上未完成复制的写请求就此丢弃，但这可能会违背数据更新持久化的承诺。</li>
<li>如果在数据库之外有其他系统依赖于数据库的内容并在一起协同使用，丢弃数据的方案就特别危险。例如，在 GitHub 的一个事故中，某个数据并非完全同步的 MySQL 从节点被提升为主副本，数据库使用了自增计数器将主键分配给新创建的行，但是因为新的主节点计数器落后于原主节点（ 即二者并非完全同步），它重新使用了已被原主节点分配出去的某些主键，而恰好这些主键已被外部 Redis 所引用，结果出现 MySQL 和 Redis 之间的不一致，最后导致了某些私有数据被错误地泄露给了其他用户。</li>
<li>在某些故障情况下，可能会发生两个节点同时－都自认为是主节点。这种情况被称为<strong>脑裂</strong>，它非常危险：两个主节点都可能接受写请求，并且没有很好解决冲突的办法（参阅本章后面的“多主节点复制技术”），最后数据可<br />
能会丢失或者破坏。作为一种安全应急方案，有些系统会采取措施来强制关闭其中一个节点。然而，如果设计或者实现考虑不周，可能会出现两个节点都被关闭的情况。</li>
<li>如何设置合适的超时来检测主节点失效呢？ 主节点失效后，超时时间设置得越长也意味着总体恢复时间就越长。但如果超时设置太短，可能会导致很多不必要的切换。例如，突发的负载峰值会导致节点的响应时间变长甚至超肘，或者由于网络故障导致延迟增加。如果系统此时已经处于高负载压力或网络已经出现严重拥塞，不必要的切换操作只会使总体情况变得更糟。</li>
</ul>
<h4 id="复制日志的实现"><a class="markdownIt-Anchor" href="#复制日志的实现"></a> 复制日志的实现</h4>
<h5 id="基于语句的复制"><a class="markdownIt-Anchor" href="#基于语句的复制"></a> 基于语句的复制</h5>
<p>最简单的情况，主节点记录所执行的每个写请求（操作语句）井将该操作语句作为日志发送给从节点。对于关系数据库，这意味着每个 INSERT 、UPDATE 或 DELETE 语句都会转发给从节点，并且每个从节点都会分析井执行这些 SQU 吾句，如同它们是来自客户端那样。</p>
<p>听起来很合理也不复杂，但这种复制方式有一些不适用的场景：</p>
<ul>
<li>任何调用非确定性函数的语句，如 <code>NOW()</code> 获取当前时间，或 <code>RAND()</code> 获取一个随机数等，可能会在不同的副本上产生不同的值。</li>
<li>如果语句中使用了自增列，或者依赖于数据库的现有数据（例如， <code>UPDATE ... WHERE &lt;某些条件&gt;</code>），则所有副本必须按照完全相同的顺序执行，否则可能会带来不同的结果。进而，如果有多个同时并发执行的事务时， 会有很大的限制。</li>
<li>有副作用的语句（例如，触发器、存储过程、用户定义的函数等），可能会在每个副本上产生不同的副作用。</li>
</ul>
<p>有可能采取一些特殊措施来解决这些问题，例如，主节点可以在记录操作语句时将非确定性函数替换为执行之后的确定的结果，这样所有节点直接使用相同的结果值。但是，这里面存在太多边界条件需要考虑，因此目前通常首选的是其他复制实现方案。</p>
<p>MySQL 5.1 版本之前采用基于操作语句的复制。现在由于逻辑紧凑，依然在用，但是默认情况下，如果语句中存在一些不确定性操作，则 MySQL 会切换到基于行的复制（稍后讨论）。VoltDB 使用基于语句的复制，它通过事务级别的确定性来保证复制的安全。</p>
<h5 id="基于预写日志wal传输"><a class="markdownIt-Anchor" href="#基于预写日志wal传输"></a> 基于预写日志（WAL）传输</h5>
<p>通常每个写操作都是以追加写的方式写入到日志中：</p>
<ul>
<li>对于日志结构存储引擎，日志是主要的存储方式。日志段在后台压缩井支持垃圾回收。</li>
<li>对于采用覆写磁盘的 BTree 结构，每次修改会预先写入日志，如系统发生崩愤，通过索引更新的方式迅速恢复到此前－致状态。</li>
</ul>
<p>不管哪种情况，所有对数据库写入的字节序列都被记入日志。因此可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘之外， 主节点还可以通过网络将其发送给从节点。</p>
<p>PostgreSQL 、Oracle 以及其他系统等支持这种复制方式。其主要缺点是日志描述的数据结果非常底层： 一个 WAL 包含了哪些磁盘块的哪些字节发生改变，诸如此类的细节。这使得复制方案和存储引擎紧密搞合。如果数据库的存储格式从一个版本改为另一个版本，那么系统通常无能支持主从节点上运行不同版本的软件。</p>
<h5 id="基于行的逻辑日志复制"><a class="markdownIt-Anchor" href="#基于行的逻辑日志复制"></a> 基于行的逻辑日志复制</h5>
<p>关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求：</p>
<ul>
<li>对于行插入，日志包含所有相关列的新值。</li>
<li>对于行删除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如果表上没有定义主键，就需要记录所有列的旧值。</li>
<li>对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少包含所有已更新列的新值）。</li>
</ul>
<p>如果一条事务涉及多行的修改，贝 lj 会产生多个这样的日志记录，并在后面跟着一条记录，指出该事务已经提交。MySQL 的二进制日志 binl og （当配置为基于行的复制时）使用该方式。</p>
<p>由于逻辑日志与存储引擎逻辑解锢，因此可以更容易地保持向后兼容，从而使主从节点能够运行不同版本的软件甚至是不同的存储引擎。<br />
对于外部应用程序来说，逻辑日志格式也更容易解析。</p>
<h5 id="基于触发器的复制"><a class="markdownIt-Anchor" href="#基于触发器的复制"></a> 基于触发器的复制</h5>
<p>触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行上述自定义代码。通过触发器技术，可以将数据更改记录到一个单独的表中，然后外部处理逻辑访问该表，实施必要的自定义应用层逻辑，例如将数据更改复制到另一个系统。Oracle 的 Databus 和 Postgres 的 Bucardo 就是这种技术的典型代表。基于触发器的复制通常比其他复制方式开销更高， 也比数据库内置复制更容易出错，或者暴露一些限制。然而，其高度灵活性仍有用武之地。</p>
<h3 id="复制滞后问题"><a class="markdownIt-Anchor" href="#复制滞后问题"></a> 复制滞后问题</h3>
<p>主从复制要求所有写请求都经由主节点，而任何副本只能接受只读查询。对于读操作密集的负载（如Web ），这是一个不错的选择：创建多个从副本，将读请求分发给这些从副本，从而减轻主节点负载井允许读取请求就近满足。</p>
<p>在这种扩展体系下，只需添加更多的从副本，就可以提高读请求的服务吞吐量。但是，这种方怯实际上只能用于异步复制，如果试图同步复制所有的从副本，则单个节点故障或网络中断将使整个系统无能写入。而且节点越多，发生故障的概率越高，所以完全同步的配置现实中反而非常不可靠。</p>
<p>不幸的是，如果一个应用正好从一个异步的从节点读取数据，而该副本落后于主节点， 贝lj应用可能会读到过期的信息。这会导致数据库中出现明显的不一致：由于并非所有的写入都反映在从副本上，如果同时对主节点和从节点发起相同的查询，可能会得到不同的结果。这种效应也破称为最终一致性。</p>
<h3 id="读自己的写"><a class="markdownIt-Anchor" href="#读自己的写"></a> 读自己的写</h3>
<p>许多应用让用户提交一些数据，接下来查看他们自己所提交的内容。例如客户数据库<br />
中的记录，亦或者是讨论主题的评论等。提交新数据须发送到主节点，但是当用户读<br />
取数据时，数据可能来自从节点。这对于读密集和偶尔写入的负载是个非常合适的方<br />
案。<br />
然而对于异步复制存在这样一个问题，如图5-3 所示，用户在写人不久即查看数据，<br />
则新数据可能尚未到达从节点。对用户来讲， 看起来似乎是刚刚提交的数据丢失了，<br />
显然用户不会高兴。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构实战案例解析</title>
    <url>/note/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="架构的本质如何打造一个有序的系统"><a class="markdownIt-Anchor" href="#架构的本质如何打造一个有序的系统"></a> 架构的本质：如何打造一个有序的系统？</h2>
<p><strong>架构的本质</strong>：通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化。</p>
<p>首先，架构的出发点是业务和技术在不断复杂化，引起系统混乱，需要通过架构来保证有序。</p>
<p>其次，架构实现从无序到有序，是通过合理的内部编排实现的，基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。</p>
<p><strong>架构的分类</strong></p>
<ul>
<li>业务架构</li>
<li>应用架构</li>
<li>技术架构</li>
</ul>
<p><strong>架构师的自我修养</strong></p>
<ul>
<li>优秀的程序员</li>
<li>沟通交流</li>
<li>权衡取舍</li>
<li>多领域知识</li>
<li>技术前瞻性</li>
<li>看透问题本质</li>
<li>抽象思维</li>
</ul>
<h2 id="业务架构作为开发你真的了解业务吗"><a class="markdownIt-Anchor" href="#业务架构作为开发你真的了解业务吗"></a> 业务架构：作为开发，你真的了解业务吗？</h2>
<p>产品经理的职责是定义产品的外观。</p>
<p>架构师的职责是将业务抽象为结构化的模块体系。</p>
<h2 id="可扩展架构如何打造一个善变的柔性系统"><a class="markdownIt-Anchor" href="#可扩展架构如何打造一个善变的柔性系统"></a> 可扩展架构：如何打造一个善变的柔性系统？</h2>
<p>系统 = 模块 + 关系</p>
<p>模块的要求：</p>
<ul>
<li>定位明确，概念完整</li>
<li>自成体系，粒度适中</li>
</ul>
<p>依赖关系的要求：</p>
<ul>
<li>最好是单向的</li>
<li>最好是层次化结构</li>
</ul>
<p>通过拆分，实现模块划分；通过整合，优化模块依赖关系。</p>
<h2 id="可扩展架构案例一电商平台架构是如何演变的"><a class="markdownIt-Anchor" href="#可扩展架构案例一电商平台架构是如何演变的"></a> 可扩展架构案例（一）：电商平台架构是如何演变的？</h2>
<p>电商平台的大致发展：</p>
<p>单体 -&gt; 分布式 -&gt; SOA -&gt; 微服务 -&gt; 中台</p>
<p>SOA vs. 微服务</p>
<ul>
<li>SOA 中的 ESB 采用集中式管理</li>
<li>微服务采用去中心化管理</li>
</ul>
<h2 id="可扩展架构案例二app-服务端架构是如何升级的"><a class="markdownIt-Anchor" href="#可扩展架构案例二app-服务端架构是如何升级的"></a> 可扩展架构案例（二）：App 服务端架构是如何升级的？</h2>
<h2 id="可扩展架构案例三你真的需要一个中台吗"><a class="markdownIt-Anchor" href="#可扩展架构案例三你真的需要一个中台吗"></a> 可扩展架构案例（三）：你真的需要一个中台吗？</h2>
<p>前台：面向 C 端的应用</p>
<p>后台：企业内部系统</p>
<p>中台：通过实现基础业务的平台化，实现了企业级业务能力的快速复用</p>
<h2 id="可复用架构如何实现高层次的复用"><a class="markdownIt-Anchor" href="#可复用架构如何实现高层次的复用"></a> 可复用架构：如何实现高层次的复用？</h2>
<p>技术复用</p>
<ul>
<li>代码复用</li>
<li>组件复用</li>
</ul>
<p>业务复用</p>
<h2 id="可复用架构案例一如何设计一个基础服务"><a class="markdownIt-Anchor" href="#可复用架构案例一如何设计一个基础服务"></a> 可复用架构案例（一）：如何设计一个基础服务？</h2>
<h2 id="可复用架构案例二如何对现有系统做微服务改造"><a class="markdownIt-Anchor" href="#可复用架构案例二如何对现有系统做微服务改造"></a> 可复用架构案例（二）：如何对现有系统做微服务改造？</h2>
<h2 id="可复用架构案例三中台是如何炼成的"><a class="markdownIt-Anchor" href="#可复用架构案例三中台是如何炼成的"></a> 可复用架构案例（三）：中台是如何炼成的？</h2>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p><a href="https://time.geekbang.org/column/intro/100046301">架构实战案例解析</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发系统设计40问学习笔记</title>
    <url>/note/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/</url>
    <content><![CDATA[<h1 id="高并发系统设计-40-问学习笔记"><a class="markdownIt-Anchor" href="#高并发系统设计-40-问学习笔记"></a> 高并发系统设计 40 问学习笔记</h1>
<h2 id="基础篇"><a class="markdownIt-Anchor" href="#基础篇"></a> 基础篇</h2>
<h3 id="高并发系统它的通用设计方法是什么"><a class="markdownIt-Anchor" href="#高并发系统它的通用设计方法是什么"></a> 高并发系统：它的通用设计方法是什么？</h3>
<p>并发、异步、缓存</p>
<h3 id="架构分层我们为什么一定要这么做"><a class="markdownIt-Anchor" href="#架构分层我们为什么一定要这么做"></a> 架构分层：我们为什么一定要这么做？</h3>
<p>分层架构典型代表：</p>
<ul>
<li>MVC（Model-View-Controller）</li>
<li>表现层、逻辑层和数据访问层</li>
<li>OSI 七层网络模型</li>
</ul>
<p>分层的好处</p>
<ul>
<li><strong>分层的设计可以简化系统设计，让不同的人专注做某一层次的事情。</strong></li>
<li><strong>再有，分层之后可以做到很高的复用。</strong></li>
<li><strong>分层架构可以让我们更容易做横向扩展。</strong></li>
</ul>
<p>分层架构的不足</p>
<ul>
<li>增加了代码的复杂度</li>
</ul>
<h3 id="系统设计目标一如何提升系统性能"><a class="markdownIt-Anchor" href="#系统设计目标一如何提升系统性能"></a> 系统设计目标（一）：如何提升系统性能？</h3>
<p>讲述了性能指标和性能量化方式。</p>
<h3 id="系统设计目标二系统怎样做到高可用"><a class="markdownIt-Anchor" href="#系统设计目标二系统怎样做到高可用"></a> 系统设计目标（二）：系统怎样做到高可用？</h3>
<p>故障转移</p>
<ul>
<li>健康检查：心跳检测</li>
<li>选举：Paxos、Raft</li>
<li>负载均衡</li>
</ul>
<p>流量控制：</p>
<ul>
<li>超时与重试</li>
<li>限流</li>
<li>降级</li>
</ul>
<p>系统运维</p>
<ul>
<li>灰度发布</li>
<li>故障演练</li>
<li>CI/CD</li>
</ul>
<p>多活架构</p>
<h3 id="系统设计目标三如何让系统易于扩展"><a class="markdownIt-Anchor" href="#系统设计目标三如何让系统易于扩展"></a> 系统设计目标（三）：如何让系统易于扩展？</h3>
<p><strong>拆分首先考虑的维度是业务维度</strong></p>
<p>其次，当吞吐量达到单机瓶颈，针对存储做水平差费</p>
<h2 id="数据库篇"><a class="markdownIt-Anchor" href="#数据库篇"></a> 数据库篇</h2>
<h4 id="池化技术如何减少频繁创建数据库连接的性能损耗"><a class="markdownIt-Anchor" href="#池化技术如何减少频繁创建数据库连接的性能损耗"></a> 池化技术：如何减少频繁创建数据库连接的性能损耗？</h4>
<p>池化技术解决频繁创建连接、创建对象的成本</p>
<h3 id="数据库优化方案一查询请求增加时如何做主从分离"><a class="markdownIt-Anchor" href="#数据库优化方案一查询请求增加时如何做主从分离"></a> 数据库优化方案（一）：查询请求增加时，如何做主从分离？</h3>
<p>读写分离：写入时只写主库，在读数据时只读从库。通常采用一主多从架构。</p>
<p>读写分离的问题：<strong>主从同步的延迟</strong></p>
<p>读写分离的关键：</p>
<ul>
<li>主从复制</li>
<li>读写流量分发</li>
<li>代理：Cobar、Mycat</li>
<li>客户端：sharding-jdbc、TDDL</li>
</ul>
<h3 id="数据库优化方案二写入数据量增加时如何实现分库分表"><a class="markdownIt-Anchor" href="#数据库优化方案二写入数据量增加时如何实现分库分表"></a> 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？</h3>
<p>垂直拆分：从业务维度，将表分为不同的库</p>
<p>水平拆分：分区 key 是关键。应使用合理策略，分库分表。如：hash 取 mod 法、范围划分</p>
<h3 id="发号器如何保证分库分表后-id-的全局唯一性"><a class="markdownIt-Anchor" href="#发号器如何保证分库分表后-id-的全局唯一性"></a> 发号器：如何保证分库分表后 ID 的全局唯一性？</h3>
<p>分布式 ID：UUID、Snowflake 算法</p>
<h3 id="nosql在高并发场景下数据库和-nosql-如何做到互补"><a class="markdownIt-Anchor" href="#nosql在高并发场景下数据库和-nosql-如何做到互补"></a> NoSQL：在高并发场景下，数据库和 NoSQL 如何做到互补？</h3>
<p>LSM 树：牺牲了一定的读性能来换取写入数据的高性能，Hbase、Cassandra、LevelDB 都是用这种算法作为存储的引擎。</p>
<p>数据首先会写入到一个叫做 MemTable 的内存结构中，在 MemTable 中数据是按照写入的 Key 来排序的。为了防止 MemTable 里面的数据因为机器掉电或者重启而丢失，一般会通过写 Write Ahead Log 的方式将数据备份在磁盘上。</p>
<p>MemTable 在累积到一定规模时，它会被刷新生成一个新的文件，我们把这个文件叫做 SSTable（Sorted String Table）。当 SSTable 达到一定数量时，我们会将这些 SSTable 合并，减少文件的数量，因为 SSTable 都是有序的，所以合并的速度也很快。</p>
<p>当从 LSM 树里面读数据时，我们首先从 MemTable 中查找数据，如果数据没有找到，再从 SSTable 中查找数据。因为存储的数据都是有序的，所以查找的效率是很高的，只是因为数据被拆分成多个 SSTable，所以读取的效率会低于 B+ 树索引。</p>
<h2 id="缓存篇"><a class="markdownIt-Anchor" href="#缓存篇"></a> 缓存篇</h2>
<h3 id="缓存数据库成为瓶颈后动态数据的查询要如何加速"><a class="markdownIt-Anchor" href="#缓存数据库成为瓶颈后动态数据的查询要如何加速"></a> 缓存：数据库成为瓶颈后，动态数据的查询要如何加速？</h3>
<p>缓存分类：静态缓存、进程内缓存、分布式缓存</p>
<h3 id="缓存的使用姿势一如何选择缓存的读写策略"><a class="markdownIt-Anchor" href="#缓存的使用姿势一如何选择缓存的读写策略"></a> 缓存的使用姿势（一）：如何选择缓存的读写策略？</h3>
<h3 id="cache-aside旁路缓存策略"><a class="markdownIt-Anchor" href="#cache-aside旁路缓存策略"></a> Cache Aside（旁路缓存）策略</h3>
<p>先写表，再写缓存，可能会导致缓存和数据库数据不一致</p>
<p>更新表，删除缓存 key；读数据时，从表中读取。</p>
<p><strong>读策略的步骤</strong></p>
<ul>
<li>从缓存中读取数据；</li>
<li>如果缓存命中，则直接返回数据；</li>
<li>如果缓存不命中，则从数据库中查询数据；</li>
<li>查询到数据后，将数据写入到缓存中，并且返回给用户。</li>
</ul>
<p><strong>写策略的步骤</strong></p>
<ul>
<li>更新数据库中的记录；</li>
<li>删除缓存记录。</li>
</ul>
<p>Cache Aside 理论上还是有较小概率导致数据不一致。</p>
<p>Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。</p>
<p><strong>如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</strong></p>
<ol>
<li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li>
<li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。</li>
</ol>
<h4 id="readwrite-through读穿-写穿策略"><a class="markdownIt-Anchor" href="#readwrite-through读穿-写穿策略"></a> Read/Write Through（读穿 / 写穿）策略</h4>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210155.jpg" alt="" /></p>
<h3 id="write-back写回策略"><a class="markdownIt-Anchor" href="#write-back写回策略"></a> Write Back（写回）策略</h3>
<p>核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210420.jpg" alt="" /></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210511.jpg" alt="" /></p>
<p>这种策略不能被应用到我们常用的数据库和缓存的场景中，它是计算机体系结构中的设计，比如我们在向磁盘中写数据时采用的就是这种策略。</p>
<p>但因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏块儿数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p>
<h3 id="缓存的使用姿势二缓存如何做到高可用"><a class="markdownIt-Anchor" href="#缓存的使用姿势二缓存如何做到高可用"></a> 缓存的使用姿势（二）：缓存如何做到高可用？</h3>
<p><strong>分布式缓存的高可用方案</strong></p>
<ul>
<li>客户端方案：在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。</li>
<li>代理层方案：客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用。</li>
<li>服务度方案：Redis Sentinel 方案</li>
</ul>
<h3 id="缓存的使用姿势三缓存穿透了怎么办"><a class="markdownIt-Anchor" href="#缓存的使用姿势三缓存穿透了怎么办"></a> 缓存的使用姿势（三）：缓存穿透了怎么办？</h3>
<p>缓存穿透解決方案：</p>
<ul>
<li>保存 null 值</li>
<li>布隆过滤器</li>
</ul>
<h2 id="消息队列篇"><a class="markdownIt-Anchor" href="#消息队列篇"></a> 消息队列篇</h2>
<h3 id="消息队列秒杀时如何处理每秒上万次的下单请求"><a class="markdownIt-Anchor" href="#消息队列秒杀时如何处理每秒上万次的下单请求"></a> 消息队列：秒杀时如何处理每秒上万次的下单请求？</h3>
<p>削峰、异步处理、系统解耦</p>
<h3 id="消息投递如何保证消息仅仅被消费一次"><a class="markdownIt-Anchor" href="#消息投递如何保证消息仅仅被消费一次"></a> 消息投递：如何保证消息仅仅被消费一次？</h3>
<h3 id="系统架构每秒-1-万次请求的系统要做服务化拆分吗"><a class="markdownIt-Anchor" href="#系统架构每秒-1-万次请求的系统要做服务化拆分吗"></a> 系统架构：每秒 1 万次请求的系统要做服务化拆分吗？</h3>
<p>系统中，使用的资源出现扩展性问题，尤其是数据库的连接数出现瓶颈；</p>
<p>大团队共同维护一套代码，带来研发效率的降低，和研发成本的提升；</p>
<p>系统部署成本越来越高。</p>
<h3 id="微服务架构微服务化后系统架构要如何改造"><a class="markdownIt-Anchor" href="#微服务架构微服务化后系统架构要如何改造"></a> 微服务架构：微服务化后，系统架构要如何改造？</h3>
<p>服务拆分时要遵循哪些原则？</p>
<p>服务的边界如何确定？服务的粒度是怎样呢？</p>
<p>在服务化之后，会遇到哪些问题呢？我们又将如何来解决？</p>
<h2 id="分布式服务篇"><a class="markdownIt-Anchor" href="#分布式服务篇"></a> 分布式服务篇</h2>
<h2 id="维护篇"><a class="markdownIt-Anchor" href="#维护篇"></a> 维护篇</h2>
<h3 id="给系统加上眼睛服务端监控要怎么做"><a class="markdownIt-Anchor" href="#给系统加上眼睛服务端监控要怎么做"></a> 给系统加上眼睛：服务端监控要怎么做？</h3>
<p>CPU、内存、磁盘、网络</p>
<p><strong>道路千万条，监控第一条，监控不到位，领导两行泪</strong></p>
<p>监控指标</p>
<p>采集方式</p>
<ul>
<li>Agent</li>
<li>埋点</li>
<li>日志</li>
</ul>
<p>处理和展示</p>
<h3 id="应用性能管理用户的使用体验应该如何监控"><a class="markdownIt-Anchor" href="#应用性能管理用户的使用体验应该如何监控"></a> 应用性能管理：用户的使用体验应该如何监控？</h3>
<h3 id="压力测试怎样设计全链路压力测试平台"><a class="markdownIt-Anchor" href="#压力测试怎样设计全链路压力测试平台"></a> 压力测试：怎样设计全链路压力测试平台？</h3>
<h3 id="配置管理成千上万的配置项要如何管理"><a class="markdownIt-Anchor" href="#配置管理成千上万的配置项要如何管理"></a> 配置管理：成千上万的配置项要如何管理？</h3>
<ul>
<li>配置存储是分级的，有公共配置，有个性的配置，一般个性配置会覆盖公共配置，这样可以减少存储配置项的数量；</li>
<li>配置中心可以提供配置变更通知的功能，可以实现配置的热更新；</li>
<li>配置中心关注的性能指标中，可用性的优先级是高于性能的，一般我们会要求配置中心的可用性达到 99.999%，甚至会是 99.9999%。</li>
</ul>
<h2 id="实战篇"><a class="markdownIt-Anchor" href="#实战篇"></a> 实战篇</h2>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 常用技巧总结</title>
    <url>/os/mac/</url>
    <content><![CDATA[<h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2>
<h3 id="软件管理"><a class="markdownIt-Anchor" href="#软件管理"></a> 软件管理</h3>
<p>dmg 格式：双击安装包，然后拖到 applications 文件夹下即可。</p>
<h3 id="浏览器"><a class="markdownIt-Anchor" href="#浏览器"></a> 浏览器</h3>
<h4 id="更改默认搜索引擎"><a class="markdownIt-Anchor" href="#更改默认搜索引擎"></a> 更改默认搜索引擎</h4>
<p>选择「偏好设置–&gt;搜索–&gt;搜索引擎–&gt;Google」。</p>
<h4 id="导入-chrome-浏览器的书签"><a class="markdownIt-Anchor" href="#导入-chrome-浏览器的书签"></a> 导入 chrome 浏览器的书签</h4>
<p>选择「文件–&gt;导入自–&gt; Google Chrome」，然后选择要导入的项目。</p>
<h4 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h4>
<p>Command + R 刷新</p>
<h4 id="上方显示书签栏收藏栏"><a class="markdownIt-Anchor" href="#上方显示书签栏收藏栏"></a> 上方显示书签栏／收藏栏</h4>
<p>选择「显示–&gt; 显示个人收藏栏」。</p>
<h4 id="关闭软件的右上角通知"><a class="markdownIt-Anchor" href="#关闭软件的右上角通知"></a> 关闭软件的右上角通知</h4>
<p>在 Mac 系统中有对通知的设置，打开系统偏好设置 — 通知 找到 QQ，然后将 QQ 提示样式设置成无即可。</p>
<h4 id="复制文件文件夹路径"><a class="markdownIt-Anchor" href="#复制文件文件夹路径"></a> 复制文件/文件夹路径</h4>
<ul>
<li>OS X 10.11 系统，选中文件夹，「cmd +Option +c」 复制文件夹路径，cmd+v 粘贴。<br />
之前的系统，利用 Administrator 创建一个到右键菜单，然后到设置里面设置快捷键。具体操作请百度。</li>
</ul>
<h4 id="打开来自身份不明的开发者的应用程序"><a class="markdownIt-Anchor" href="#打开来自身份不明的开发者的应用程序"></a> 打开来自身份不明的开发者的应用程序</h4>
<p>在应用程序文件夹，按住 control 键的同时打开应用程序。</p>
<h4 id="复制文件路径"><a class="markdownIt-Anchor" href="#复制文件路径"></a> 复制文件路径</h4>
<ul>
<li>
<p>选择文件／文件夹按 Command+C 复制，在终端中 Command+V 粘贴即可。</p>
</li>
<li>
<p>如果只是想在 Finder 中看到文件的路径, 并方便切换层级, Finder 内置了「显示路径栏」的功能, 并配置了快捷键(Option+Cmd+P). 如下图所示：</p>
</li>
</ul>
<p>20161124-184148.png</p>
<p>参考链接：</p>
<ul>
<li>[<a href="https://www.zhihu.com/question/22883229">https://www.zhihu.com/question/22883229</a>]</li>
</ul>
<h3 id="隐藏和取消隐藏-mac-app-store-中的已购项目"><a class="markdownIt-Anchor" href="#隐藏和取消隐藏-mac-app-store-中的已购项目"></a> 隐藏和取消隐藏 Mac App Store 中的已购项目</h3>
<h3 id="mac-同时登陆两个-qq"><a class="markdownIt-Anchor" href="#mac-同时登陆两个-qq"></a> Mac 同时登陆两个 QQ</h3>
<p>在已经打开的 QQ 中，按住「command + N」即可。</p>
<h2 id="系统便好设置"><a class="markdownIt-Anchor" href="#系统便好设置"></a> 系统便好设置</h2>
<h3 id="语音播报"><a class="markdownIt-Anchor" href="#语音播报"></a> 语音播报</h3>
<p>打开「系统便好设置–&gt;辅助功能–&gt;语音」，即可设置不同国家的语言。</p>
<p>勾选上图中的红框部分，可以设置全局快捷键。这样的话，在任何一个软件当中，按下「 option+esc」时，就会朗读选中的文本。</p>
<h3 id="调整字体大小"><a class="markdownIt-Anchor" href="#调整字体大小"></a> 调整字体大小</h3>
<p>Mac 调整字体大小：「系统偏好设置 -&gt; 显示器 -&gt; 缩放」。如下图：</p>
<h3 id="如何分别设置-mac-的鼠标和触控板的滚动方向"><a class="markdownIt-Anchor" href="#如何分别设置-mac-的鼠标和触控板的滚动方向"></a> 如何分别设置 Mac 的鼠标和触控板的滚动方向</h3>
<p>很多人习惯鼠标使用相反的滚动方向，而触控板类似 iPad 那样的自然滚动，问如何设置，当时我的回答是不知道，因为目前 OS X 的系统设置里，鼠标和触控板的设置是统一<br />
的。今天发现了一个免费的软件 Scroll Reverser，可以实现鼠标和触控板的分别设置。下载地址：<a href="https://pilotmoon.com/scrollreverser/">https://pilotmoon.com/scrollreverser/</a><br />
启动后程序显示在顶部菜单栏，设置简单明了，有需要的用户体验一下吧。</p>
<h3 id="touch-bar-自定义"><a class="markdownIt-Anchor" href="#touch-bar-自定义"></a> Touch Bar 自定义</h3>
<p>打开「系统偏好设置-键盘」，下面有个自定义控制条。</p>
<h3 id="色温调节夜间模式"><a class="markdownIt-Anchor" href="#色温调节夜间模式"></a> 色温调节：夜间模式</h3>
<p>iOS9.3 的最明显变化，莫过于苹果在发布会上特意提到的 Night Shift 夜间护眼模式。</p>
<h3 id="icloud-邮箱"><a class="markdownIt-Anchor" href="#icloud-邮箱"></a> iCloud 邮箱</h3>
<p>如果您用于设置 iCloud 的 Apple ID 不以“@icloud.com”、“@me.com”或“@mac.com”结尾，您必须先设置一个“@icloud.com”电子邮件地址，然后才能使用 iCloud“邮件”。</p>
<p>如果您拥有以“@mac.com”或“@me.com”结尾的电子邮件地址，则您已经拥有了名称相同但以“@icloud.com”结尾的等效地址。如果您使用的电子邮件别名以“@mac.com”或“@me.com”结尾，您也将拥有以“@icloud.com”结尾的等效地址。</p>
<p><strong>操作如下：</strong></p>
<ul>
<li>
<p>在 iOS 设备上，前往“设置”&gt;“iCloud”，开启“邮件”，然后按照屏幕上的说明操作。</p>
</li>
<li>
<p>在 Mac 上，选取 Apple 菜单 &gt;“系统偏好设置”，点按“iCloud”，再选择“邮件”，然后按照屏幕上的说明操作。</p>
</li>
</ul>
<p>PS：创建 iCloud 电子邮件地址后，您无法对其进行更改。</p>
<p>设置 @icloud.com 电子邮件地址后即可用其登录 iCloud。您也可以用创建 iCloud 帐户时所用的 Apple ID 登录。</p>
<p>您可以从以下任意地址发送 iCloud 电子邮件：</p>
<p>您的 iCloud 电子邮件地址（您的帐号名称@icloud.com）</p>
<p>别名</p>
<p>参考链接：</p>
<p><strong>直接注册以@icloud.com 结尾的 Apple ID：</strong></p>
<p>参考链接：</p>
<h2 id="podcast"><a class="markdownIt-Anchor" href="#podcast"></a> PodCast</h2>
<p>PodCast 中文翻译为播客，是一种特殊的音频 or 视频节目。PodCast 这个单词是由 iPod+Broadcast 这两个单词组成的。</p>
<p>PodCast 可以在 iTunes 中收听。</p>
<h2 id="others"><a class="markdownIt-Anchor" href="#others"></a> others</h2>
<h3 id="词典"><a class="markdownIt-Anchor" href="#词典"></a> 词典</h3>
<p>系统有一个自带应用「词典」，可以进行单词的查询。</p>
<h3 id="如何解决-mac-软件dmgakpapp出现程序已损坏的提示"><a class="markdownIt-Anchor" href="#如何解决-mac-软件dmgakpapp出现程序已损坏的提示"></a> 如何解决 MAC 软件（dmg，akp，app）出现程序已损坏的提示</h3>
<p>「xxx.app 已损坏,打不开.你应该将它移到废纸篓」，并非你安装的软件已损坏，而是 Mac 系统的安全设置问题，因为这些应用都是破解或者汉化的,那么解决方法就是临时改变 Mac 系统安全设置。</p>
<p>出现这个问题的解决方法：修改系统配置：系统偏好设置… -&gt; 安全性与隐私。修改为任何来源。</p>
<p>如果没有这个选项的话（macOS Sierra 10.12）,打开终端，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>参考链接：</p>
<ul>
<li>
<p><a href="http://www.jianshu.com/p/379b49b88df9">Max OS-[xxx.app 已损坏,打不开.你应该将它移到废纸篓]</a></p>
</li>
<li>
<p><a href="http://www.yunrui.co/25693.html">如何解决 MAC 软件（dmg，akp，app）出现程序已损坏的提示</a></p>
</li>
</ul>
<p>备注：这个链接里的各种资源都很不错啊。</p>
<h4 id="终端"><a class="markdownIt-Anchor" href="#终端"></a> 终端</h4>
<h4 id="在-finder-的当前目录打开终端"><a class="markdownIt-Anchor" href="#在-finder-的当前目录打开终端"></a> 在 Finder 的当前目录打开终端</h4>
<p>在 Finder 打开 terminal 终端这个功能其实是有的，但是系统默认没有打开。我们可以通过如下方法将其打开：</p>
<p>进入系统偏好设置-&gt;键盘-&gt;快捷键-&gt;服务。</p>
<p>在右边新建位于文件夹位置的终端窗口上打勾。</p>
<p>如此设置后，在 Finder 中右击某文件，在出现的菜单中找到服务，然后点击新建位于文件夹位置的终端窗口即可！</p>
<h2 id="mac-常用快捷键"><a class="markdownIt-Anchor" href="#mac-常用快捷键"></a> Mac 常用快捷键</h2>
<h3 id="finder"><a class="markdownIt-Anchor" href="#finder"></a> Finder</h3>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Shift + Command + G</td>
<td style="text-align:left">前往指定路径的文件夹</td>
<td style="text-align:left">包括隐藏文件夹</td>
</tr>
<tr>
<td style="text-align:left">Shift + Command + .</td>
<td style="text-align:left">显示隐藏文件、文件夹</td>
<td style="text-align:left">再按一次，恢复隐藏</td>
</tr>
<tr>
<td style="text-align:left">Command + ↑</td>
<td style="text-align:left">返回上一层</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Command + ↓</td>
<td style="text-align:left">进入当前文件夹</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3 id="编辑"><a class="markdownIt-Anchor" href="#编辑"></a> 编辑</h3>
<p><strong>删除文字</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">delete</td>
<td style="text-align:left">删除光标的前一个字符</td>
<td style="text-align:left">相当于 Windows 键盘上的退格键</td>
</tr>
<tr>
<td style="text-align:left">fn + delete</td>
<td style="text-align:left">删除光标的后一个字符</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">option + delete</td>
<td style="text-align:left">删除光标之前的一个单词</td>
<td style="text-align:left">英文有效</td>
</tr>
<tr>
<td style="text-align:left"><strong>command + delete</strong></td>
<td style="text-align:left">删除光标之前的整行内容</td>
<td style="text-align:left">【荐】</td>
</tr>
<tr>
<td style="text-align:left">command + delete</td>
<td style="text-align:left">在 finder 中删掉该文件</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">shift + command + delete</td>
<td style="text-align:left">清空回收站</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p><strong>剪切文件</strong>：</p>
<p>首先选中文件，按 Command+C 复制文件；然后按「Command ＋ Option ＋ V」剪切文件。</p>
<p>备注：Command+X 只能剪切文字文本，不要混淆了。</p>
<h2 id="mac-用户必须知道的-15-组快捷键"><a class="markdownIt-Anchor" href="#mac-用户必须知道的-15-组快捷键"></a> Mac 用户必须知道的 15 组快捷键</h2>
<blockquote>
<p>参考链接：<a href="http://v.youku.com/v_show/id_XNDE4MzM0NDgw.html">《轻松玩 Mac》第 6 期：Mac 用户必须知道的 15 组快捷键</a></p>
</blockquote>
<h3 id="space键快速预览"><a class="markdownIt-Anchor" href="#space键快速预览"></a> 「space」键：快速预览</h3>
<p>选中文件后， 不需要启动任何应用程序，使用「space」空格键可进行快速预览，再次按下「space」空格键取消预览。</p>
<p>可以预览 mp3、视频、pdf 等文件。</p>
<p>我们还可以<strong>选中多张图片</strong>， 然后按「space」键，就可以同时对比预览多张图片。这一点，很赞。</p>
<h3 id="改名"><a class="markdownIt-Anchor" href="#改名"></a> 改名</h3>
<p>选中文件/文件夹后，按 enter 键，就可以改名了。</p>
<h3 id="command-i键查看文件属性"><a class="markdownIt-Anchor" href="#command-i键查看文件属性"></a> 「command + I」键：查看文件属性</h3>
<ul>
<li>
<p>选中文件后，按「command + I」键，可以查看文件的各种属性。</p>
</li>
<li>
<p>选中<strong>文件夹</strong>后，按「command + I」键，可以查看文件夹的大小。【荐】</p>
</li>
</ul>
<h3 id="切换输入法"><a class="markdownIt-Anchor" href="#切换输入法"></a> 切换输入法</h3>
<p>「control + space」</p>
<h3 id="打开-spotlight-搜索框"><a class="markdownIt-Anchor" href="#打开-spotlight-搜索框"></a> 打开 spotlight 搜索框</h3>
<p>spotlight 是系统自带的软件，搜索功能不是很强大。我们一般都会用第三方的 Alfred 软件。</p>
<h3 id="编辑相关"><a class="markdownIt-Anchor" href="#编辑相关"></a> 编辑相关</h3>
<p>Cmd+C、Cmd+V、Cmd+X、Cmd+A、Cmd+Z。</p>
<h3 id="翻页和光标"><a class="markdownIt-Anchor" href="#翻页和光标"></a> 翻页和光标</h3>
<ul>
<li>
<p>「control + ↑」：将光标定位到文章的最开头（翻页到文档的最上方）</p>
</li>
<li>
<p>「control + ↓」：将光标定位到文章的最末尾（翻页到文档的最下方）</p>
</li>
<li>
<p>「control + ←」：将光标定位到当前行的最左侧</p>
</li>
<li>
<p>「control + →」：将光标定位到当前行的最右侧</p>
</li>
</ul>
<h3 id="command-shift-y将文字快速保存到便笺"><a class="markdownIt-Anchor" href="#command-shift-y将文字快速保存到便笺"></a> 「command + shift + Y」：将文字快速保存到便笺</h3>
<p>选中你想要的内容（例如文字、链接等），然后按下 command + shift + Y」，那么你选中的内容就会快速保存到系统自带的「便笺」软件中。</p>
<p>如果你想临时性的保存一段内容，这个操作很实用。</p>
<h3 id="程序相关"><a class="markdownIt-Anchor" href="#程序相关"></a> 程序相关</h3>
<ul>
<li>
<p>「command + Q」：快速退出程序</p>
</li>
<li>
<p>「command + tab」：切换程序</p>
</li>
<li>
<p>「command + H」：隐藏当前应用程序。这是一个有趣的快捷键。</p>
</li>
<li>
<p>「command + ，」：打开当前应用程序的「偏好设置」。</p>
</li>
</ul>
<h3 id="窗口相关"><a class="markdownIt-Anchor" href="#窗口相关"></a> 窗口相关</h3>
<ul>
<li>
<p>「command + N」：新建一个当前应用程序的窗口</p>
</li>
<li>
<p>「command + `」：在当前应用程序的不同窗口之间切换【很实用】</p>
</li>
</ul>
<p>我们知道，「command + tab」是在不同的软件之间切换。但你不知道的是，「command + `」是在同一个软件的不同窗口之间切换。</p>
<ul>
<li>
<p>「command + M」：将当前窗口最小化</p>
</li>
<li>
<p>「command + W」：关闭当前窗口</p>
</li>
</ul>
<h3 id="浏览器相关"><a class="markdownIt-Anchor" href="#浏览器相关"></a> 浏览器相关</h3>
<ul>
<li>
<p>「command + T」：浏览器中，新建一个标签</p>
</li>
<li>
<p>「command + W」：关闭当前标签</p>
</li>
</ul>
<ul>
<li>「command + R」：强制刷新。</li>
</ul>
<ul>
<li>「command + L」：定位到地址栏。【重要】</li>
</ul>
<h3 id="截图相关"><a class="markdownIt-Anchor" href="#截图相关"></a> 截图相关</h3>
<ul>
<li>「command + shift + 3」：截全屏（对整个屏幕截图）。</li>
</ul>
<h3 id="声音相关"><a class="markdownIt-Anchor" href="#声音相关"></a> 声音相关</h3>
<p>选中文字后，按住「ctrl + esc」键，会将文字进行朗读。（我发现，在触控条版的 mac 上，并没有生效）</p>
<h3 id="dock-栏相关"><a class="markdownIt-Anchor" href="#dock-栏相关"></a> Dock 栏相关</h3>
<ul>
<li>「option + command + D」：隐藏 dock 栏</li>
</ul>
<h3 id="强制推出"><a class="markdownIt-Anchor" href="#强制推出"></a> 强制推出</h3>
<blockquote>
<p>强制退出的快捷键非常重要</p>
</blockquote>
<ul>
<li>「option + command + esc」：打开强制退出的窗口</li>
</ul>
<h3 id="option-相关"><a class="markdownIt-Anchor" href="#option-相关"></a> option 相关</h3>
<blockquote>
<p>强烈推荐</p>
</blockquote>
<ul>
<li>
<p>「option + command + H」：隐藏除当前应用程序之外的其他应用程序</p>
</li>
<li>
<p>在文本中，按住「option」键，配合鼠标的选中，可以进行块状文字选取。</p>
</li>
<li>
<p>「option + command + W」：快速关闭当前应用程序的所有窗口。【很实用】</p>
</li>
</ul>
<p>比如说，你一次性打开了很多文件的详情，然后就可以通过此快捷键，将这些窗口一次性关闭。</p>
<ul>
<li>「option + command + I」：查看多个文件的总的属性。</li>
</ul>
<ul>
<li>
<p>打开 launchpad，按住「option」键，可以快速卸载应用程序。</p>
</li>
<li>
<p>在 dock 栏，右键点击软件图标，同时按住「option」键，就可以<strong>强制退出</strong>该软件。【重要】</p>
</li>
</ul>
<ul>
<li>在 Safari 浏览器中，按住「option + command + Q」退出 Safari。等下次进入 Safari 的时候，上次退出时的网址会自动被打开。【实用】</li>
</ul>
<h3 id="推荐一个软件cheatsheet"><a class="markdownIt-Anchor" href="#推荐一个软件cheatsheet"></a> 推荐一个软件：CheatSheet</h3>
<p>打开 CheatSheet 后，长按 command 键，会弹出当前应用程序的所有快捷键。我们还可以对这些快捷键进行保存。</p>
<h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2>
<ul>
<li><a href="https://github.com/jaywcjlove/awesome-mac">Awesome Mac</a></li>
<li><a href="https://github.com/herrbischoff/awesome-macos-command-line">awesome-macos-command-line</a></li>
</ul>
<h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2>
<p>| <a href="https://github.com/dunwu/blog">回首頁</a> |</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 常用技巧总结</title>
    <url>/os/windows/</url>
    <content><![CDATA[<h1 id="windows-常用技巧总结"><a class="markdownIt-Anchor" href="#windows-常用技巧总结"></a> Windows 常用技巧总结</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#%E8%BD%AF%E4%BB%B6">软件</a>
<ul>
<li><a href="#%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91">视频音频</a></li>
<li><a href="#%E5%8E%8B%E7%BC%A9">压缩</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a></li>
<li><a href="#%E5%BC%80%E5%8F%91">开发</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li>
<li><a href="#%E6%96%87%E6%A1%A3">文档</a></li>
<li><a href="#%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87">效率提升</a></li>
<li><a href="#%E5%8A%9E%E5%85%AC">办公</a></li>
<li><a href="#%E4%B8%AA%E6%80%A7%E5%8C%96">个性化</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h2>
<blockquote>
<p>扩展阅读：</p>
<ul>
<li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md">Awesome Windows</a></li>
<li><a href="https://github.com/stackia/best-windows-apps">best-windows-apps</a></li>
</ul>
</blockquote>
<h3 id="视频音频"><a class="markdownIt-Anchor" href="#视频音频"></a> 视频音频</h3>
<ul>
<li><a href="http://getmusicbee.com/">Musicbee</a> - 类似 iTunes，但比 iTunes 更好用。</li>
<li><a href="http://www.screentogif.com/">ScreenToGif</a> - 它允许你录制屏幕的一部分区域并保存为 gif 或视频。</li>
<li><a href="http://potplayer.daum.net/">PotPlayer</a> - 多媒体播放器，具有广泛的编解码器集合，它还为用户提供大量配置选项。</li>
<li><a href="http://www.splayer.org/">射手影音播放器</a> - 来自射手网，小巧开源，首创自动匹配字幕功能。</li>
</ul>
<h3 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h3>
<ul>
<li><a href="http://www.7-zip.org/">7-Zip</a> - 用于处理压缩包的开源 Windows 实用程序。完美支持 7z，ZIP，GZIP，BZIP2 和 TAR 的全部特性，其他格式也可解压缩。</li>
<li><a href="http://www.rarlab.com/">WinRAR</a> - 强大的归档管理器。 它可以备份您的数据并减小电子邮件附件的大小，解压缩 RAR，ZIP 和其他文件。</li>
</ul>
<h3 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h3>
<ul>
<li><a href="http://en.ejie.me/">Clover</a> - 为资源管理器加上多标签功能。</li>
<li><a href="http://www.ghisler.com/">Total Commander</a> - 老牌、功能异常强大的文件管理增强软件。</li>
<li><a href="http://www.softwareok.com/?seite=Freeware/Q-Dir">Q-Dir</a> - 轻量级的文件管理器，各种布局视图切换灵活，默认四个小窗口组成一个大窗口，操作快捷。软件虽小，粉丝忠诚。</li>
<li><a href="https://github.com/Wox-launcher/Wox">WoX</a> - 新一代文件定位工具，堪称 Windows 上的 Alfred。</li>
<li><a href="http://www.voidtools.com/">Everything</a> - 最快的文件/文件夹搜索工具， 通过名称搜索。</li>
<li><a href="http://www.listary.com/">Listary</a> - 非常优秀的 Windows 文件浏览和搜索增强工具。</li>
<li>Beyond Compare - 好用又万能的文件对比工具。</li>
<li><a href="https://www.piriform.com/ccleaner/download">CCleaner</a> - 如果你有系统洁癖，那一定要选择一款干净、良心、老牌的清洁软件。</li>
<li><a href="https://chocolatey.org/">chocolatey</a> - 包管理器</li>
<li><a href="https://ninite.com/">Ninite</a> - 最简单，最快速的更新或安装软件的方式。</li>
<li><a href="http://www.piriform.com/RECUVA">Recuva</a> - 来自 piriform 梨子公司产品，免费的数据恢复工具。</li>
<li><a href="http://www.launchy.net/">Launchy</a>：自由的跨平台工具，帮助你忘记开始菜单、桌面图标甚至文件管理器。</li>
</ul>
<h3 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h3>
<ul>
<li><a href="http://www.telerik.com/fiddler">Fiddler</a> - web 调试代理工具。</li>
<li><a href="https://www.getpostman.com/postman">Postman</a> - 适合 API 开发的完整工具链，最常用的 REST 客户端。</li>
<li><a href="https://www.sourcetreeapp.com/">SourceTree</a> - 一个免费的 Git &amp; Mercurial 客户端。</li>
<li><a href="https://tortoisesvn.net/">TortoiseSVN</a> - Subversion(SVN)的图形客户端</li>
<li><a href="https://www.wireshark.org/">Wireshark</a> - 一个网络协议分析工具。</li>
<li>Switchhosts</li>
<li><a href="https://github.com/cmderdev/cmder">Cmder</a> - 控制台模拟器包。扩展阅读：<a href="https://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/">Win 下必备神器之 Cmder</a></li>
<li><a href="http://babun.github.io/">Babun</a> - 基于 Cygwin，用于替代 Windows shell。</li>
</ul>
<h3 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h3>
<ul>
<li><a href="http://www.jetbrains.com/">JetBrain IDE 系列</a> - 真香！</li>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a> - 用于构建和调试现代 Web 和云应用程序。</li>
<li><a href="https://eclipse.org/downloads/">Eclipse</a> - 一款功能强大的 IDE。</li>
<li><a href="https://www.visualstudio.com/vs/">Visual Studio</a> - 微软官方的 IDE，通过插件可支持大量编程语言。</li>
<li><a href="https://netbeans.org/">NetBeans IDE</a> - 免费开源的 IDE。</li>
<li><a href="https://www.typora.io/">Typora</a> - 个人觉得最好用的 Markdown 编辑器。</li>
<li><a href="https://www.zybuluo.com/cmd/">Cmd Markdown</a> - 跨平台优秀 Markdown 编辑器，本文即用其所写。</li>
<li><a href="https://notepad-plus-plus.org/">Notepad++</a> - 一款支持多种编程语言的源码编辑器。</li>
<li><a href="http://www.flos-freeware.ch/notepad2.html">Notepad2</a> - 用于替代默认文本编辑器的轻量快速的编辑器，拥有众多有用的功能。</li>
<li><a href="http://www.sublimetext.com/3">Sublime Text 3</a> - 高级文本编辑器。</li>
<li><a href="https://atom.io/">Atom</a> - 面向 21 世纪的极客文本编辑器。</li>
</ul>
<h3 id="文档"><a class="markdownIt-Anchor" href="#文档"></a> 文档</h3>
<ul>
<li><a href="http://www.office.com/">Microsoft Office</a> - 微软办公软件。</li>
<li><a href="https://www.wps.com/office-free">WPS Office</a> - 金山免费办公软件。</li>
<li><a href="http://calibre-ebook.com/">Calibre</a> - 用于电子书管理和转换的强大软件。</li>
<li><a href="http://www.foxitsoftware.cn/products/reader/">福昕阅读器</a> - 在全球拥有大量用户，最优秀的国产软件之一。Ribbon 界面，支持手写签名、插入印章等。</li>
</ul>
<h3 id="效率提升"><a class="markdownIt-Anchor" href="#效率提升"></a> 效率提升</h3>
<p><strong>【笔记】</strong></p>
<ul>
<li><a href="http://www.xmind.net/">XMind</a> - 优秀的思维导图。</li>
<li><a href="https://www.onenote.com/">OneNote</a> - Windows 下综合评价非常高的笔记应用。</li>
<li><a href="http://www.yinxiang.com/">印象笔记</a> - 老牌跨平台笔记工具，国际版 Evernote。一家立志于做百年公司的企业，安全、可靠。</li>
<li><a href="http://www.wiz.cn/index.html">为知笔记</a> - 越来越好的笔记应用，记录、查阅一切有价值的信息，同样跨平台支持。</li>
<li><a href="http://note.youdao.com/">有道云笔记</a> - 网易旗下笔记工具，同样跨主流平台支持，文字、手写、录音、拍照多种记录方式，支持任意附件格式。</li>
<li><a href="https://getsharex.com/">ShareX</a> - 你要的所有与截图、录屏相关的功能，这里都有了。</li>
</ul>
<p>【快捷键】</p>
<ul>
<li><a href="https://autohotkey.com/">AutoHotkey</a> - Windows 平台的终极自动化脚本语言。</li>
</ul>
<blockquote>
<p>技巧：</p>
<ul>
<li><a href="https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/">https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/</a></li>
<li><a href="https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296">https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296</a></li>
</ul>
</blockquote>
<h3 id="办公"><a class="markdownIt-Anchor" href="#办公"></a> 办公</h3>
<ul>
<li><a href="http://cidian.youdao.com/index.html">有道词典</a> - 最好用的免费全能翻译软件。</li>
<li><a href="http://office.microsoft.com/zh-cn/outlook/">Outlook</a> - 大名鼎鼎的 Microsoft Office 组件之一，除了电子邮件，还包含了日历、任务管理、联系人、记事本等功能。</li>
<li><a href="http://www.gmail.com/">Gmail</a> - 功能上可以称为业界标杆，用户数量世界第一，或许你真的找不到比它更好的邮件系统。</li>
<li><a href="https://www.google.com/intl/zh-CN/chrome/browser/">Chrome</a> - 最好的浏览器。</li>
<li><a href="http://www.teamviewer.com/Zhcn/index.aspx">Teamviewer</a> - 专业、功能强大的远程控制软件。使用简单，对个人用户免费。</li>
</ul>
<h3 id="个性化"><a class="markdownIt-Anchor" href="#个性化"></a> 个性化</h3>
<ul>
<li><a href="https://github.com/TranslucentTB/TranslucentTB">TranslucentTB</a> - 透明化你的 Windows 任务栏。</li>
<li><a href="http://qttabbar.wikidot.com/">QTTabBar</a> - 通过多标签和额外的文件夹视图扩展资源管理器的功能。</li>
<li><a href="https://www.stardock.com/products/fences/">Fences</a> - 管理桌面快捷方式。</li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md">https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md</a></li>
<li><a href="https://love.appinn.com/">https://love.appinn.com/</a></li>
<li><a href="https://github.com/stackia/best-windows-apps">https://github.com/stackia/best-windows-apps</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程入门指南</title>
    <url>/software/software-engineering/</url>
    <content><![CDATA[<h1 id="软件工程入门指南"><a class="markdownIt-Anchor" href="#软件工程入门指南"></a> 软件工程入门指南</h1>
<blockquote>
<p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog">blog</a>」</p>
<p>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。</p>
</blockquote>
<p>[TOC]</p>
<h2 id="软件工程的目标"><a class="markdownIt-Anchor" href="#软件工程的目标"></a> 软件工程的目标</h2>
<p>软件工程的目标是：在给定成本、进度的前提下，开发出具有适用性、有效性、可修改性、可靠性、可理解性、可维护性、可重用性、可移植性、可追踪性、可互操作性和满足用户需求的软件产品。</p>
<ul>
<li><strong>适用性</strong> - 软件在不同的系统约束条件下，使用户需求得到满足的难易程度。</li>
<li><strong>有效性</strong> - 软件系统能最有效的利用计算机的时间和空间资源。各种软件无不把系统的时/空开销作为衡量软件质量的一项重要技术指标。很多场合，在追求时间有效性和空间有效性时会发生矛盾，这时不得不牺牲时间有效性换取空间有效性或牺牲空间有效性换取时间有效性。时/空折衷是经常采用的技巧。</li>
<li><strong>可修改性</strong> - 允许对系统进行修改而不增加原系统的复杂性。它支持软件的调试和维护，是一个难以达到的目标。</li>
<li><strong>可靠性</strong> - 能防止因概念、设计和结构等方面的不完善造成的软件系统失效，具有挽回因操作不当造成软件系统失效的能力。</li>
<li><strong>可理解性</strong> - 系统具有清晰的结构，能直接反映问题的需求。可理解性有助于控制系统软件复杂性，并支持软件的维护、移植或重用。</li>
<li><strong>可维护性</strong> - 软件交付使用后，能够对它进行修改，以改正潜伏的错误，改进性能和其它属性，使软件产品适应环境的变化等。软件维护费用在软件开发费用中占有很大的比重。可维护性是软件工程中一项十分重要的目标。</li>
<li><strong>可重用性</strong> - 把概念或功能相对独立的一个或一组相关模块定义为一个软部件。可组装在系统的任何位置，降低工作量。</li>
<li><strong>可移植性</strong> - 软件从一个计算机系统或环境搬到另一个计算机系统或环境的难易程度。</li>
<li><strong>可追踪性</strong> - 根据软件需求对软件设计、程序进行正向追踪，或根据软件设计、程序对软件需求的逆向追踪的能力。</li>
<li><strong>可互操作性</strong> - 多个软件元素相互通信并协同完成任务的能力。</li>
</ul>
<h2 id="软件工程的原理"><a class="markdownIt-Anchor" href="#软件工程的原理"></a> 软件工程的原理</h2>
<p>软件工程的七条基本原理：</p>
<ol>
<li>用分阶段的生存周期计划进行严格的管理。</li>
<li>坚持进行阶段评审。</li>
<li>实行严格的产品控制。</li>
<li>采用现代程序设计技术。</li>
<li>软件工程结果应能清楚地审查。</li>
<li>开发小组的人员应该少而精。</li>
<li>承认不断改进软件工程实践的必要性。</li>
</ol>
<h2 id="软件工程的方法"><a class="markdownIt-Anchor" href="#软件工程的方法"></a> 软件工程的方法</h2>
<p>著名的<strong>重量级</strong>开发方法：</p>
<ul>
<li><a href="https://zh.wikipedia.org/zh-cn/ISO_9000">ISO9000</a> - ISO 9000 系列标准是国际标准化组织设立的标准，与品质管理系统有关。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B">能力成熟度模型（CMM）</a> - CMM 涵盖一个成熟的软件发展组织所应具备的重要功能与项目，它描述了软件发展的演进过程，从毫无章法、不成熟的软件开发阶段到成熟软件开发阶段的过程。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B">统一软件开发过程（RUP）</a> - RUP 是一种软件工程方法，为迭代式软件开发流程。</li>
</ul>
<p>著名的<strong>轻量级</strong>开发方法：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">敏捷开发（Agile Development）</a> - 是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B">极限编程（XP）</a> - 极限编程是敏捷软件开发中最有成效的方法学之一。极限编程技术以沟通（Communication）、简单（Simplicity）、反馈（Feedback）、勇气（Courage）和尊重（Respect）为价值标准。</li>
</ul>
<h2 id="软件需求"><a class="markdownIt-Anchor" href="#软件需求"></a> 软件需求</h2>
<p>软件需求包括三个不同的层次：业务需求、用户需求和功能需求。</p>
<ul>
<li>
<p>**业务需求（Business requirement）**表示组织或客户高层次的目标。业务需求通常来自项目投资人、购买产品的客户、实际用户的管理者、市场营销部门或产品策划部门。业务需求描述了组织为什么要开发一个系统，即组织希望达到的目标。使用前景和范围（ vision and scope ）文档来记录业务需求，这份文档有时也被称作项目轮廓图或市场需求（ project charter 或 market requirement ）文档。</p>
</li>
<li>
<p>**用户需求（user requirement）**描述的是用户的目标，或用户要求系统必须能完成的任务。用例、场景描述和事件――响应表都是表达用户需求的有效途径。也就是说用户需求描述了用户能使用系统来做些什么。</p>
</li>
<li>
<p>**功能需求（functional requirement）**规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。功能需求有时也被称作行为需求（ behavioral requirement ），因为习惯上总是用“应该”对其进行描述：“系统应该发送电子邮件来通知用户已接受其预定”。功能需求描述是开发人员需要实现什么。</p>
</li>
<li>
<p>**系统需求（system requirement）**用于描述包含多个子系统的产品（即系统）的顶级需求。系统可以只包含软件系统，也可以既包含软件又包含硬件子系统。人也可以是系统的一部分，因此某些系统功能可能要由人来承担。</p>
</li>
</ul>
<h3 id="软件需求说明书-srs"><a class="markdownIt-Anchor" href="#软件需求说明书-srs"></a> 软件需求说明书（ SRS ）</h3>
<p>软件需求说明书（ SRS ）完整地描述了软件系统的预期特性。开发、测试、质量保证、项目管理和其他相关的项目功能都要用到 SRS 。</p>
<p>除了功能需求外， SRS 中还包含非功能需求，包括性能指标和对质量属性的描述。</p>
<ul>
<li>**质量属性（quality attribute）**对产品的功能描述作了补充，它从不同方面描述了产品的各种特性。这些特性包括可用性、可移植性、完整性、效率和健壮性，它们对用户或开发人员都很重要。其他的非功能需求包括系统与外部世界的外部界面，以及对设计与实现的约束。</li>
<li>**约束（constraint）**限制了开发人员设计和构建系统时的选择范围。</li>
</ul>
<h2 id="软件生命周期"><a class="markdownIt-Anchor" href="#软件生命周期"></a> 软件生命周期</h2>
<blockquote>
<p><strong>软件生命周期（Software Life Cycle,SLC）是软件的产生直到报废或停止使用的生命周期。</strong></p>
</blockquote>
<ul>
<li>问题定义 - 要求系统分析员与用户进行交流，弄清“用户需要计算机解决什么问题”然后提出关于“系统目标与范围的说明”，提交用户审查和确认。</li>
<li>可行性研究 - 一方面在于把待开发的系统的目标以明确的语言描述出来；另一方面从经济、技术、法律等多方面进行可行性分析。</li>
<li>需求分析 - 弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册，提交评审。</li>
<li>开发阶段
<ul>
<li>概要设计</li>
<li>详细设计</li>
<li>编码实现</li>
<li>软件测试 - 测试的过程分单元测试、组装测试以及系统测试三个阶段进行。测试的方法主要有白盒测试和黑盒测试两种。</li>
</ul>
</li>
<li>维护</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/software-engineering/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.gif" alt="软件生命周期" /></p>
<h2 id="软件生命周期模型"><a class="markdownIt-Anchor" href="#软件生命周期模型"></a> 软件生命周期模型</h2>
<h3 id="瀑布模型"><a class="markdownIt-Anchor" href="#瀑布模型"></a> 瀑布模型</h3>
<blockquote>
<p>瀑布模型（Waterfall Model）强调系统开发应有完整的周期，且必须完整的经历周期的每一开发阶段，并系统化的考量分析与设计的技术、时间与资源之投入等。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/software-engineering/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.jpg" alt="瀑布模型" /></p>
<h4 id="瀑布模型思想"><a class="markdownIt-Anchor" href="#瀑布模型思想"></a> 瀑布模型思想</h4>
<p>瀑布模型核心思想是按工序将问题拆分，将功能的实现与设计分开，便于分工协作，即采用结构化的分析与设计方法将逻辑实现与物理实现分开。将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。</p>
<h4 id="瀑布模型特点"><a class="markdownIt-Anchor" href="#瀑布模型特点"></a> 瀑布模型特点</h4>
<p>优点：</p>
<ul>
<li>为项目提供了按阶段划分的检查点。</li>
<li>当前一阶段完成后，您只需要去关注后续阶段。</li>
<li>可在迭代模型中应用瀑布模型。</li>
<li>它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。</li>
</ul>
<p>缺点：</p>
<ul>
<li>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。</li>
<li>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。</li>
<li>通过过多的强制完成日期和里程碑来跟踪各个项目阶段。</li>
<li>瀑布模型的突出缺点是不适应用户需求的变化。</li>
</ul>
<p>适用场景：</p>
<p>是否使用这一模型主要取决于是否能理解客户的需求以及在项目的进程中这些需求的变化程度。对于需求经常变化的项目，不要适用瀑布模型。</p>
<h3 id="螺旋模型"><a class="markdownIt-Anchor" href="#螺旋模型"></a> 螺旋模型</h3>
<blockquote>
<p>螺旋模型基本做法是在“瀑布模型”的每一个开发阶段前引入一个非常严格的风险识别、风险分析和风险控制，它把软件项目分解成一个个小项目。每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/software-engineering/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png" alt="螺旋模型" /></p>
<h4 id="螺旋模型思想"><a class="markdownIt-Anchor" href="#螺旋模型思想"></a> 螺旋模型思想</h4>
<p>螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：</p>
<ol>
<li>制定计划 - 确定软件目标，选定实施方案，弄清项目开发的限制条件；</li>
<li>风险分析 - 分析评估所选方案，考虑如何识别和消除风险；</li>
<li>实施工程 - 实施软件开发和验证；</li>
<li>客户评估 - 评价开发工作，提出修正建议，制定下一步计划。</li>
</ol>
<p>螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。</p>
<h4 id="螺旋模型特点"><a class="markdownIt-Anchor" href="#螺旋模型特点"></a> 螺旋模型特点</h4>
<p>优点：</p>
<ul>
<li>设计上的灵活性,可以在项目的各个阶段进行变更。</li>
<li>以小的分段来构建大型系统,使成本计算变得简单容易。</li>
<li>客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。</li>
<li>随着项目推进,客户始终掌握项目的最新信息, 从而他或她能够和管理层有效地交互。</li>
<li>客户认可这种公司内部的开发方式带来的良好的沟通和高质量的产品。</li>
</ul>
<p>缺点：</p>
<p>很难让用户确信这种演化方法的结果是可以控制的。建设周期长，而软件技术发展比较快，所以经常出现软件开发完毕后，和当前的技术水平有了较大的差距，无法满足当前用户需求。</p>
<p>适用场景：</p>
<p>对于新项目，需求不明确的情况下，适合用螺旋模型进行开发，便于风险控制和需求变更。</p>
<h2 id="软件工程术语"><a class="markdownIt-Anchor" href="#软件工程术语"></a> 软件工程术语</h2>
<ul>
<li><strong>里程碑（Milestone）</strong> - 在制定项目进度计划时，在进度时间表上设立一些重要的时间检查点，这样一来，就可以在项目执行过程中利用这些重要的时间检查点来对项目的进程进行检查和控制。这些重要的时间检查点被称作项目的里程碑。</li>
<li><strong>人月</strong> - 软件开发的工作量单位。如 200 人月，10 个人开发，那算来就是花 20 个月就可完工。</li>
<li><strong>基线</strong> - 基线是项目储存库中每个工件版本在特定时期的一个“快照”。它提供一个正式标准，随后的工作基于此标准，并且只有经过授权后才能变更这个标准。建立一个初始基线后，以后每次对其进行的变更都将记录为一个差值，直到建成下一个基线。</li>
</ul>
<h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2>
<ul>
<li><strong>书籍</strong>
<ul>
<li><a href="https://book.douban.com/subject/2230248/">《人月神话》</a></li>
<li><a href="https://book.douban.com/subject/1477390/">《代码大全》</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="https://juejin.im/post/5a4991e151882574d23cafbf">使用甘特图做项目管理</a></li>
<li><a href="https://juejin.im/post/5c1f6a1e6fb9a04a03793573">使用燃尽图监控项目整体进度</a></li>
</ul>
</li>
<li><strong>工具</strong>
<ul>
<li><a href="https://my.oschina.net/editorial-story/blog/1559395">10 大开源免费的项目管理软件推荐</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html">http://www.ruanyifeng.com/blog/2017/08/issue.html</a></li>
</ul>
</li>
<li><strong>文档模板</strong>
<ul>
<li><a href="https://pan.baidu.com/s/1sXTOs1PSDyw9P2zWtzbsmw">软件工程文档标准模板百度网盘下载</a> - 下载密码：uu1f</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>合理对文档进行归类</title>
    <url>/efficiency/style/dir-style/</url>
    <content><![CDATA[<blockquote>
<p>作为程序员，想必每个人都会有大量的资料、数据。按照条理清晰的目录结构去分类化存储，十分有助于管理文件。</p>
</blockquote>
<h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2>
<p>以下是我个人整理的目录结构：</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Codes           <span class="comment">#代码目录</span></span><br><span class="line">│   ├── Other       <span class="comment">#第三方代码目录</span></span><br><span class="line">│   ├── My          <span class="comment">#个人代码目录</span></span><br><span class="line">│   └── Work        <span class="comment">#工作代码目录</span></span><br><span class="line">├── <span class="built_in">Data</span>            <span class="comment">#数据目录</span></span><br><span class="line">├── Downloads       <span class="comment">#下载文件目录</span></span><br><span class="line">├── Docs            <span class="comment">#文档目录</span></span><br><span class="line">│   ├── Books       <span class="comment">#电子书目录</span></span><br><span class="line">│   ├── My          <span class="comment">#个人文档目录</span></span><br><span class="line">│   └── Work        <span class="comment">#工作文档目录</span></span><br><span class="line">├── Movies          <span class="comment">#视频目录</span></span><br><span class="line">├── Music           <span class="comment">#音乐目录</span></span><br><span class="line">├── Pictures        <span class="comment">#图片目录</span></span><br><span class="line">├── Public          <span class="comment">#共享目录</span></span><br><span class="line">├── Temp            <span class="comment">#临时文件目录</span></span><br><span class="line">└── Tools           <span class="comment">#工具软件目录</span></span><br><span class="line">    └── Packages    <span class="comment">#安装包目录</span></span><br></pre></td></tr></table></figure>
<p>注：如果您使用的操作系统是 Mac 这种可以为目录或文件添加 tag 的操作系统，那么您可以根据自己的喜好更细致化的管理。</p>
<h2 id="2-文件管理软件"><a class="markdownIt-Anchor" href="#2-文件管理软件"></a> 2. 文件管理软件</h2>
<blockquote>
<p>选用便利的文件管理软件，可以让你的文件管理如虎添翼。这里推荐几款经典的文件管理工具。</p>
</blockquote>
<h3 id="21-clover"><a class="markdownIt-Anchor" href="#21-clover"></a> 2.1. Clover</h3>
<blockquote>
<p><a href="http://cn.ejie.me/">Clover</a> 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。</p>
</blockquote>
<div align="center">
<img src="http://cn.ejie.me/images/clover.jpg" width="640" />
</div>
<h3 id="22-everything"><a class="markdownIt-Anchor" href="#22-everything"></a> 2.2. Everything</h3>
<blockquote>
<p><a href="http://www.voidtools.com/">Everything</a> 可以立即在 windows 系统中找到制定名称的文件和文件夹。</p>
</blockquote>
<div align="center">
<img src="http://www.voidtools.com/sssmall2.gif" width="640" />
</div>
<h3 id="23-wox"><a class="markdownIt-Anchor" href="#23-wox"></a> 2.3. Wox</h3>
<blockquote>
<p><a href="https://github.com/Wox-launcher/Wox">Wox</a> 是一款简单易用的 Windows 启动器。可以把它视为 windows 版的 Alfred。</p>
</blockquote>
<div align="center">
<img src="https://camo.githubusercontent.com/9db33546d3a905a9ad915e0948d3ba3f47f57b64/687474703a2f2f692e696d6775722e636f6d2f4474784e424a692e676966" width="640" />
</div>
<h3 id="24-q-dir"><a class="markdownIt-Anchor" href="#24-q-dir"></a> 2.4. Q-dir</h3>
<blockquote>
<p><a href="http://www.softpedia.com/get/File-managers/Q-Dir.shtml">Q-dir</a> 是轻量的文件管理器,特点鲜明,各种布局视图切换灵活,默认四个小窗口组成一个大窗口,操作快捷。</p>
</blockquote>
<div align="center">
<img src="http://i1-win.softpedia-static.com/screenshots/q-dir_1.png" width="640" />
</div>
]]></content>
      <categories>
        <category>效率提升</category>
        <category>规范</category>
      </categories>
      <tags>
        <tag>效率提升</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>合理规划项目</title>
    <url>/efficiency/style/project-style/</url>
    <content><![CDATA[<blockquote>
<p>软件项目开发规范。</p>
</blockquote>
<h2 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h2>
<p>以下为项目根目录下的文件和目录的组织结构：</p>
<h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3>
<p><strong>codes</strong> - 代码目录。<br />
<strong>configurations</strong> - 配置目录。一般存放项目相关的配置文件。如 maven 的 settings.xml，nginx 的 nginx.conf 等。<br />
<strong>demos</strong> - 示例目录。<br />
<strong>docs</strong> - 文档目录。<br />
<strong>libs</strong> - 第三方库文件。<br />
<strong>scripts</strong> - 脚本目录。一般存放用于启动、构建项目的可执行脚本文件。<br />
<strong>packages</strong> - 打包文件目录。Java 项目中可能是 jar、war 等；前端项目中可能是 zip、rar 等；电子书项目中可能是 pdf 等。</p>
<h3 id="文件"><a class="markdownIt-Anchor" href="#文件"></a> 文件</h3>
<p><strong>.gitignore</strong> - git 忽略规则。<br />
<strong>.gitattributes</strong> - git 属性规则。<br />
<strong>.editorconfig</strong> - 编辑器书写规则。<br />
<strong><a href="http://README.md">README.md</a></strong> - 项目说明文件。<br />
<strong>LICENSE</strong> - 开源协议。如果项目是开源文件，需要添加。</p>
<h2 id="命名规则"><a class="markdownIt-Anchor" href="#命名规则"></a> 命名规则</h2>
<h3 id="目录名"><a class="markdownIt-Anchor" href="#目录名"></a> 目录名</h3>
<p>目录名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>
<p>目录名建议只使用小写字母，不使用大写字母。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">不佳： <span class="keyword">Test</span></span><br><span class="line">正确： <span class="keyword">test</span></span><br></pre></td></tr></table></figure>
<p>目录名可以使用数字，但不应该是首字符。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">不佳： <span class="number">1</span>-demo</span><br><span class="line">正确： dem<span class="meta">o1</span></span><br></pre></td></tr></table></figure>
<p>目录名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">不佳： common_demo</span><br><span class="line">正确： <span class="meta">common</span>-demo</span><br></pre></td></tr></table></figure>
<h3 id="文件名"><a class="markdownIt-Anchor" href="#文件名"></a> 文件名</h3>
<p>文档的文件名不得含有空格。</p>
<p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">错误： 名词解释.<span class="built_in">md</span></span><br><span class="line">正确： glossary.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>
<p>文件名建议只使用小写字母，不使用大写字母。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">错误：TroubleShooting.<span class="built_in">md</span></span><br><span class="line">正确：troubleshooting.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>
<p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p>
<p>一些约定俗成的习惯可以保持传统写法，如：Java 的文件名一般使用驼峰命名法，且首字母大写；配置文件 <code>applicationContext.xml</code> ；React 中的 JSX 组件文件名一般使用驼峰命名法，且首字母大写等。</p>
<p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">不佳：advanced_usage.<span class="built_in">md</span></span><br><span class="line">正确：advanced-usage.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>
<h2 id="java-日志规范"><a class="markdownIt-Anchor" href="#java-日志规范"></a> Java 日志规范</h2>
<blockquote>
<p>这里基于<a href="https://yq.aliyun.com/attachment/download/?id=4942">阿里巴巴 Java 开发手册</a>日志规约章节，结合自己的开发经验做了一些增删和调整。</p>
</blockquote>
<ol>
<li>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Abc.class);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>【强制】日志文件推荐至少保存 <code>30</code> 天，因为有些异常具备以“周”为频次发生的特点。</p>
</li>
<li>
<p>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：<code>appName_logType_logName.log</code>。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。</p>
</li>
</ol>
<p><strong>正例</strong>：mppserver 应用中单独监控时区转换异常，如：<code>mppserver_monitor_timeZoneConvert.log</code></p>
<p><strong>说明</strong>：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。</p>
<ol start="4">
<li>【强制】对 <code>trace/debug/info</code> 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。</li>
</ol>
<p>说明：<code>logger.debug(&quot;Processing trade with id: &quot; + id + &quot; and symbol: &quot; + symbol);</code> 如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。</p>
<p><strong>正例：（条件）</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="selector-tag">logger</span><span class="selector-class">.debug</span>(<span class="string">&quot;Processing trade with id: &quot;</span> + id + <span class="string">&quot; and symbol: &quot;</span> + symbol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：（占位符）</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">logger.<span class="builtin-name">debug</span>(<span class="string">&quot;Processing trade with id: &#123;&#125; and symbol : &#123;&#125; &quot;</span>, id, symbol);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>【强制】避免重复打印日志，浪费磁盘空间。务必在 <code>log4j.xml</code> 或 <code>logback.xml</code> 中设置 <code>additivity=false</code>。</li>
</ol>
<p><strong>正例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.taobao.dubbo.config&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。</li>
</ol>
<p><strong>正例</strong>：logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e);</p>
<ol start="9">
<li>【强制】日志格式遵循如下格式：</li>
</ol>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javalib/log/logback/log-pattern.png"/></div>
<p>打印出的日志信息如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">57.277</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[TRACE]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span>.LogbackDemo<span class="selector-id">#main</span> - 这是一条 trace 日志记录</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">57.282</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[DEBUG]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span>.LogbackDemo<span class="selector-id">#main</span> - 这是一条 debug 日志记录</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">57.282</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[INFO]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span>.LogbackDemo<span class="selector-id">#main</span> - 这是一条 info 日志记录</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">57.282</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[WARN]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span>.LogbackDemo<span class="selector-id">#main</span> - 这是一条 warn 日志记录</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">57.282</span> <span class="selector-attr">[javalib]</span> <span class="selector-attr">[main]</span> <span class="selector-attr">[ERROR]</span> <span class="selector-tag">i</span><span class="selector-class">.g</span><span class="selector-class">.dunwu</span><span class="selector-class">.javalib</span><span class="selector-class">.log</span>.LogbackDemo<span class="selector-id">#main</span> - 这是一条 error 日志记录</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>【参考】slf4j 支持的日志级别，按照级别从低到高，分别为：<code>trace &lt; debug &lt; info &lt; warn &lt; error</code>。</li>
</ol>
<p>建议只使用 <code>debug &lt; info &lt; warn &lt; error</code> 四个级别。</p>
<ul>
<li><code>error</code> 日志级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。</li>
<li><code>warn</code> 日志级别记录用户输入参数错误的情况，避免用户投诉时，无所适从。</li>
<li><code>info</code> 日志级别记录业务逻辑中一些重要步骤信息。</li>
<li><code>debug</code> 日志级别记录一些用于调试的信息。</li>
</ul>
<ol start="10">
<li>【参考】有一些第三方框架或库的日志对于排查问题具有一定的帮助，如 Spring、Dubbo、Mybatis 等。这些框架所使用的日志库未必和本项目一样，为了避免出现日志无法输出的问题，请引入对应的桥接 jar 包。</li>
</ol>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://yq.aliyun.com/attachment/download/?id=4942">阿里巴巴 Java 开发手册</a>日志规约章节</li>
</ul>
]]></content>
      <categories>
        <category>效率提升</category>
        <category>规范</category>
      </categories>
      <tags>
        <tag>效率提升</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>合理编排技术文档</title>
    <url>/efficiency/style/doc-style/</url>
    <content><![CDATA[<blockquote>
<p>文档采用 Markdown 语法书写。</p>
<p>📚 「参考」Markdown 语法可以参考：</p>
<ul>
<li><a href="https://github.com/guodongxiaren/README">https://github.com/guodongxiaren/README</a></li>
<li><a href="https://github.com/tchapi/markdown-cheatsheet">https://github.com/tchapi/markdown-cheatsheet</a></li>
</ul>
</blockquote>
<h2 id="1-标题"><a class="markdownIt-Anchor" href="#1-标题"></a> 1. 标题</h2>
<h3 id="11-标题层级"><a class="markdownIt-Anchor" href="#11-标题层级"></a> 1.1. 标题层级</h3>
<p>标题分为四级。</p>
<ol>
<li>一级标题：文章的标题</li>
<li>二级标题：文章内容的大标题</li>
<li>三级标题：二级标题下一级的标题</li>
<li>四级标题：三级标题下一级的标题</li>
</ol>
<h3 id="12-标题原则"><a class="markdownIt-Anchor" href="#12-标题原则"></a> 1.2. 标题原则</h3>
<ul>
<li>一篇文章中应该尽力避免同名标题。</li>
<li>一级标题下，不能直接出现三级标题。</li>
<li>标题要避免孤立编号（即同级标题只有一个）。</li>
<li>下级标题不重复上一级标题的内容。</li>
<li>谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</li>
</ul>
<h2 id="2-文本"><a class="markdownIt-Anchor" href="#2-文本"></a> 2. 文本</h2>
<h3 id="21-字间距"><a class="markdownIt-Anchor" href="#21-字间距"></a> 2.1. 字间距</h3>
<p>全角中文字符与半角英文字符之间，应有一个半角空格。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：本文介绍如何快速启动Windows系统。</span><br><span class="line"></span><br><span class="line">正例：本文介绍如何快速启动 Windows 系统。</span><br></pre></td></tr></table></figure>
<p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">正例：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</span><br><span class="line"></span><br><span class="line">正例：2011 年<span class="number"> 5 </span>月<span class="number"> 15 </span>日，我订购了<span class="number"> 5 </span>台笔记本电脑与<span class="number"> 10 </span>台平板电脑。</span><br></pre></td></tr></table></figure>
<p>半角的百分号，视同阿拉伯数字。</p>
<p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">反例：一部容量为<span class="number"> 16 </span>GB 的智能手机</span><br><span class="line"></span><br><span class="line">正例：一部容量为 16GB 的智能手机</span><br></pre></td></tr></table></figure>
<p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：他的电脑是 MacBook Air 。</span><br><span class="line"></span><br><span class="line">正例：他的电脑是 MacBook Air。</span><br></pre></td></tr></table></figure>
<h3 id="22-句子"><a class="markdownIt-Anchor" href="#22-句子"></a> 2.2. 句子</h3>
<ul>
<li>避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。</li>
<li>尽量使用简单句和并列句，避免使用复合句。</li>
</ul>
<h3 id="23-写作风格"><a class="markdownIt-Anchor" href="#23-写作风格"></a> 2.3. 写作风格</h3>
<p>尽量不使用被动语态，改为使用主动语态。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：假如此软件尚未被安装，</span><br><span class="line"></span><br><span class="line">正例：假如尚未安装这个软件，</span><br></pre></td></tr></table></figure>
<p>不使用非正式的语言风格。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</span><br><span class="line"></span><br><span class="line">正例：无法参加本次活动，我深感遗憾。</span><br></pre></td></tr></table></figure>
<p>用对“的”、“地”、“得”。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">她露出了开心的笑容。</span><br><span class="line">（形容词＋的＋名词）</span><br><span class="line"></span><br><span class="line">她开心地笑了。</span><br><span class="line">（副词＋地＋动词）</span><br><span class="line"></span><br><span class="line">她笑得很开心。</span><br><span class="line">（动词＋得＋副词）</span><br></pre></td></tr></table></figure>
<p>使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：从管理系统可以监视中继系统和受其直接控制的分配系统。</span><br><span class="line"></span><br><span class="line">正例：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</span><br></pre></td></tr></table></figure>
<p>名词前不要使用过多的形容词。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</span><br><span class="line"></span><br><span class="line">正例：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</span><br></pre></td></tr></table></figure>
<p>单个句子的长度尽量保持在 20 个字以内；20 ～ 29 个字的句子，可以接受；30 ～ 39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</span><br><span class="line"></span><br><span class="line">正例：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</span><br></pre></td></tr></table></figure>
<p>同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：请确认没有接通装置的电源。</span><br><span class="line"></span><br><span class="line">正例：请确认装置的电源已关闭。</span><br></pre></td></tr></table></figure>
<p>避免使用双重否定句。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：没有删除权限的用户，不能删除此文件。</span><br><span class="line"></span><br><span class="line">正例：用户必须拥有删除权限，才能删除此文件。</span><br></pre></td></tr></table></figure>
<h3 id="24-英文处理"><a class="markdownIt-Anchor" href="#24-英文处理"></a> 2.4. 英文处理</h3>
<p>英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">英文：⋯information stored <span class="keyword">in</span> random <span class="keyword">access</span> memory (RAMs)⋯</span><br><span class="line"></span><br><span class="line">中文：……存储在随机存取存储器（RAM）里的信息……</span><br></pre></td></tr></table></figure>
<p>外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">U.S.A.</span><br><span class="line">Apple, Inc.</span><br></pre></td></tr></table></figure>
<p>表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">英文：<span class="number">5</span> minutes <span class="keyword">later</span>⋯</span><br><span class="line"></span><br><span class="line">中文：<span class="number">5</span> 分钟过去了⋯⋯</span><br></pre></td></tr></table></figure>
<p>英文书名或电影名改用中文表达时，双引号应改为书名号。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">英文：<span class="keyword">He</span> published <span class="keyword">an</span> article entitled <span class="string">&quot;The Future of the Aviation&quot;</span>.</span><br><span class="line"></span><br><span class="line">中文：他发表了一篇名为《航空业的未来》的文章。</span><br></pre></td></tr></table></figure>
<p>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</span><br></pre></td></tr></table></figure>
<p>专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">“American Association <span class="keyword">of</span> Physicists <span class="keyword">in</span> Medicine”（美国医学物理学家协会）是专有名词，需要大写。</span><br><span class="line"></span><br><span class="line">“online <span class="keyword">transaction</span> processing”（在线事务处理）不是专有名词，不应大写。</span><br></pre></td></tr></table></figure>
<h2 id="3-段落"><a class="markdownIt-Anchor" href="#3-段落"></a> 3. 段落</h2>
<h3 id="31-段落原则"><a class="markdownIt-Anchor" href="#31-段落原则"></a> 3.1. 段落原则</h3>
<ul>
<li>一个段落只能有一个主题，或一个中心句子。</li>
<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>
<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>
<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>
<li>段落之间使用一个空行隔开。</li>
<li>段落开头不要留出空白字符。</li>
</ul>
<h3 id="32-引用"><a class="markdownIt-Anchor" href="#32-引用"></a> 3.2. 引用</h3>
<p>引用第三方内容时，应注明出处。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">One <span class="keyword">man</span>’s constant <span class="keyword">is</span> another <span class="keyword">man</span>’s variable. — Alan Perlis</span><br></pre></td></tr></table></figure>
<p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">本文转载自 WikiQuote</span><br></pre></td></tr></table></figure>
<p>使用外部图片时，必须在图片下方或文末标明来源。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">本文部分图片来自 Wikipedia</span><br></pre></td></tr></table></figure>
<h3 id="33-强调"><a class="markdownIt-Anchor" href="#33-强调"></a> 3.3. 强调</h3>
<p>一些特殊的强调内容可以按照如下方式书写：</p>
<blockquote>
<p>🔔 『注意』</p>
</blockquote>
<blockquote>
<p>💡 『提示』</p>
</blockquote>
<blockquote>
<p>📚 『参考』</p>
</blockquote>
<h2 id="4-数值"><a class="markdownIt-Anchor" href="#4-数值"></a> 4. 数值</h2>
<h3 id="41-半角数字"><a class="markdownIt-Anchor" href="#41-半角数字"></a> 4.1. 半角数字</h3>
<p>数字一律使用半角形式，不得使用全角形式。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">反例：</span> <span class="string">这件商品的价格是１０００元。</span></span><br><span class="line"></span><br><span class="line"><span class="string">正例：</span> <span class="string">这件商品的价格是</span> <span class="number">1000</span> <span class="string">元。</span></span><br></pre></td></tr></table></figure>
<h3 id="42-千分号"><a class="markdownIt-Anchor" href="#42-千分号"></a> 4.2. 千分号</h3>
<p>数值为千位以上，应添加千分号（半角逗号）。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">XXX</span> 公司的实收资本为 RMB<span class="number">1</span>,<span class="number">258</span>,<span class="number">000</span>。</span><br></pre></td></tr></table></figure>
<p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于 7 位及以上的数值，千分号是必须的。</p>
<p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p>
<h3 id="43-货币"><a class="markdownIt-Anchor" href="#43-货币"></a> 4.3. 货币</h3>
<p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$1</span>,000</span></span><br><span class="line"><span class="number">1</span>,<span class="number">000</span> 美元</span><br></pre></td></tr></table></figure>
<h3 id="44-数值范围"><a class="markdownIt-Anchor" href="#44-数值范围"></a> 4.4. 数值范围</h3>
<p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p>
<p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">反例：<span class="number">132</span>～<span class="number">234</span>kg</span><br><span class="line">正例：<span class="number">132</span>kg～<span class="number">234</span>kg</span><br><span class="line"></span><br><span class="line">反例：<span class="number">67</span>～<span class="number">89</span><span class="meta">%</span></span><br><span class="line">正例：<span class="number">67</span><span class="meta">%</span>～<span class="number">89</span><span class="meta">%</span></span><br></pre></td></tr></table></figure>
<h3 id="45-变化程度的表示法"><a class="markdownIt-Anchor" href="#45-变化程度的表示法"></a> 4.5. 变化程度的表示法</h3>
<p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">增加到过去的两倍</span><br><span class="line">（过去为一，现在为二）</span><br><span class="line"></span><br><span class="line">增加了两倍</span><br><span class="line">（过去为一，现在为三）</span><br></pre></td></tr></table></figure>
<p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">降低到百分之八十</span><br><span class="line">（定额是一百，现在是八十）</span><br><span class="line"></span><br><span class="line">降低了百分之八十</span><br><span class="line">（原来是一百，现在是二十）</span><br></pre></td></tr></table></figure>
<p>不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p>
<h2 id="5-符号"><a class="markdownIt-Anchor" href="#5-符号"></a> 5. 符号</h2>
<h3 id="51-符号原则"><a class="markdownIt-Anchor" href="#51-符号原则"></a> 5.1. 符号原则</h3>
<ul>
<li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li>
<li>如果整句为英文，则该句使用英文/半角标点。</li>
<li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li>
</ul>
<h3 id="52-句号"><a class="markdownIt-Anchor" href="#52-句号"></a> 5.2. 句号</h3>
<p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p>
<p>句子末尾用括号加注时，句号应在括号之外。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">反例：关于文件的输出，请参照第 1.3 节（见第<span class="number"> 26 </span>页。）</span><br><span class="line"></span><br><span class="line">正例：关于文件的输出，请参照第 1.3 节（见第<span class="number"> 26 </span>页）。</span><br></pre></td></tr></table></figure>
<h3 id="53-逗号"><a class="markdownIt-Anchor" href="#53-逗号"></a> 5.3. 逗号</h3>
<p>逗号<code>，</code>表示句子内部的一般性停顿。</p>
<p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p>
<h3 id="54-顿号"><a class="markdownIt-Anchor" href="#54-顿号"></a> 5.4. 顿号</h3>
<p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</span><br><span class="line"></span><br><span class="line">正例：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></table></figure>
<p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook <span class="keyword">and</span> other components.</span><br></pre></td></tr></table></figure>
<h3 id="55-分号"><a class="markdownIt-Anchor" href="#55-分号"></a> 5.5. 分号</h3>
<p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p>
<h3 id="56-引号"><a class="markdownIt-Anchor" href="#56-引号"></a> 5.6. 引号</h3>
<p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</span><br></pre></td></tr></table></figure>
<p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</span><br></pre></td></tr></table></figure>
<h3 id="57-圆括号"><a class="markdownIt-Anchor" href="#57-圆括号"></a> 5.7. 圆括号</h3>
<p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</span><br></pre></td></tr></table></figure>
<h3 id="58-冒号"><a class="markdownIt-Anchor" href="#58-冒号"></a> 5.8. 冒号</h3>
<p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</span><br></pre></td></tr></table></figure>
<p>表示时间时，应使用半角冒号（<code>:</code>）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例句：早上 8:00</span><br></pre></td></tr></table></figure>
<h3 id="59-省略号"><a class="markdownIt-Anchor" href="#59-省略号"></a> 5.9. 省略号</h3>
<p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p>
<p>省略号不应与“等”这个词一起使用。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">反例：我们为会餐准备了香蕉、苹果、梨…等各色水果。</span><br><span class="line"></span><br><span class="line">正例：我们为会餐准备了各色水果，有香蕉、苹果、梨……</span><br><span class="line"></span><br><span class="line">正例：我们为会餐准备了香蕉、苹果、梨等各色水果。</span><br></pre></td></tr></table></figure>
<h3 id="510-感叹号"><a class="markdownIt-Anchor" href="#510-感叹号"></a> 5.10. 感叹号</h3>
<p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p>
<p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p>
<h3 id="511-破折号"><a class="markdownIt-Anchor" href="#511-破折号"></a> 5.11. 破折号</h3>
<p>破折号<code>————</code>一般用于做进一步解释。破折号应占两个汉字的位置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</span><br></pre></td></tr></table></figure>
<h3 id="512-连接号"><a class="markdownIt-Anchor" href="#512-连接号"></a> 5.12. 连接号</h3>
<p>连接号用于连接两个类似的词。</p>
<p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p>
<ul>
<li>两个名词的复合</li>
<li>图表编号</li>
</ul>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">例句：氧化-还原反应</span><br><span class="line"></span><br><span class="line">例句：图 1<span class="string">-1</span></span><br></pre></td></tr></table></figure>
<p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>
<ul>
<li>数值范围（例如日期、时间或数字）</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例句：2009 年～2011 年</span><br></pre></td></tr></table></figure>
<p>注意，波浪连接号前后两个值都应该加上单位。</p>
<p>波浪连接号也可以用汉字“至”代替。</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">例句：周围温度：<span class="operator">-</span><span class="number">20</span>°<span class="built_in">C</span> 至 <span class="operator">-</span><span class="number">10</span>°<span class="built_in">C</span></span><br></pre></td></tr></table></figure>
<h2 id="6-结构"><a class="markdownIt-Anchor" href="#6-结构"></a> 6. 结构</h2>
<h3 id="61-目录结构"><a class="markdownIt-Anchor" href="#61-目录结构"></a> 6.1. 目录结构</h3>
<p>技术手册目录结构是一部完整的书，建议采用下面的结构。</p>
<ul>
<li><strong>简介</strong>（Introduction） - [必选][目录|文件] 提供对产品和文档本身的总体的、扼要的说明</li>
<li><strong>入门篇</strong>（Quickstart） - [可选][文件] 如何最快速地使用产品</li>
<li><strong>基础篇</strong>（Basics） - [必选][目录] 又称”使用篇“，提供初级的使用教程
<ul>
<li><strong>环境准备</strong>（Prerequisite） - [可选][文件] 软件使用需要满足的前置条件</li>
<li><strong>安装</strong>（Installation） - [可选][文件] 软件的安装方法</li>
<li><strong>配置</strong>（Configuration） - [可选][目录|文件] 软件的配置</li>
<li><strong>特性</strong>（Feature） - [必选][目录|文件] 软件的功能特性</li>
</ul>
</li>
<li><strong>进阶篇</strong>（Advanced） - [可选][目录] 又称”开发篇“，提供中高级的开发教程
<ul>
<li><strong>原理</strong>（Principle） - [可选][目录|文件] 软件的原理</li>
<li><strong>设计</strong>（Design） - [可选][目录|文件] 软件的设计，如：架构、设计思想等</li>
</ul>
</li>
<li><strong>实战篇</strong>（Action） - [可选][目录] 提供一些具有实战意义的示例说明</li>
<li><strong>API</strong>（API） - [可选][目录|文件] 软件 API 的逐一介绍</li>
<li><strong>常见问题</strong>（FAQ） - [可选][目录|文件] 常见问题解答</li>
<li><strong>附录</strong>（Appendix） - [可选][目录] 不属于教程本身、但对阅读教程有帮助的内容
<ul>
<li><strong>命令</strong>（Command） - [可选][目录] 命令</li>
<li><strong>资源</strong>（Resource） - [必选][文件] 资源</li>
<li><strong>术语</strong>（Glossary） - [可选][文件] 名词解释</li>
<li><strong>技巧</strong>（Recipe） - [可选][文件] 最佳实践</li>
<li><strong>版本</strong>（Changelog） - [可选][文件] 版本说明</li>
<li><strong>反馈</strong>（Feedback） - [可选][文件] 反馈方式</li>
</ul>
</li>
</ul>
<p>下面是两个真实范例，可参考。</p>
<ul>
<li><a href="http://redux.js.org/index.html">Redux 手册</a></li>
<li><a href="http://flight-manual.atom.io/">Atom 手册</a></li>
</ul>
<h3 id="62-文件名"><a class="markdownIt-Anchor" href="#62-文件名"></a> 6.2. 文件名</h3>
<p>文档的文件名不得含有空格。</p>
<p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">反例： 名词解释.<span class="built_in">md</span></span><br><span class="line"></span><br><span class="line">正例： glossary.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>
<p>文件名建议只使用小写字母，不使用大写字母。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">反例：TroubleShooting.<span class="built_in">md</span></span><br><span class="line"></span><br><span class="line">正例：troubleshooting.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>
<p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p>
<p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">反例：advanced_usage.<span class="built_in">md</span></span><br><span class="line"></span><br><span class="line">正例：advanced-usage.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>
<h2 id="7-emoji"><a class="markdownIt-Anchor" href="#7-emoji"></a> 7. Emoji</h2>
<p>在 markdown 文档中，普遍会使用 emoji，帮助理解内容。但是，如果滥用 emoji，可能会适得其反。</p>
<p>这里，将一些比较约定俗成的 emoji 表情使用场景列举一下：</p>
<ul>
<li>💡 提示 - [推荐]</li>
<li>🔔 注意、警告 - [推荐]</li>
<li>⭕ 正确 - [推荐]</li>
<li>❌ 错误 - [推荐]</li>
<li>❓ 问题 - [推荐]</li>
<li>⛔ 禁止 - [推荐]</li>
<li>🚧 未完待续、有待补充 - [推荐]</li>
<li>📚 参考、参考资料 - [可选]</li>
<li>⌨ 源码 - [可选]</li>
</ul>
<h2 id="8-参考"><a class="markdownIt-Anchor" href="#8-参考"></a> 8. 参考</h2>
<ul>
<li><a href="http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html">产品手册中文写作规范</a>, by 华为</li>
<li><a href="http://docs.daocloud.io/write-docs/format">写作规范和格式规范</a>, by DaoCloud</li>
<li><a href="http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf">技术写作技巧在日汉翻译中的应用</a>, by 刘方</li>
<li><a href="https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf">简体中文规范指南</a>, by lengoo</li>
<li><a href="https://open.leancloud.cn/copywriting-style-guide.html">文档风格指南</a>, by LeanCloud</li>
<li><a href="https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit">豌豆荚文案风格指南</a>, by 豌豆荚</li>
<li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines">中文文案排版指北</a>, by sparanoid</li>
<li><a href="http://w3c.github.io/clreq/">中文排版需求</a>, by W3C</li>
<li><a href="http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html">为什么文件名要小写？</a>, by 阮一峰</li>
</ul>
]]></content>
      <categories>
        <category>效率提升</category>
        <category>规范</category>
      </categories>
      <tags>
        <tag>效率提升</tag>
        <tag>规范</tag>
      </tags>
  </entry>
</search>
